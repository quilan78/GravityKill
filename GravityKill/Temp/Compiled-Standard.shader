// Compiled shader for PC, Mac & Linux Standalone

//////////////////////////////////////////////////////////////////////////
// 
// NOTE: This is *not* a valid shader file, the contents are provided just
// for information and for debugging purposes only.
// 
//////////////////////////////////////////////////////////////////////////
// Skipping shader variants that would not be included into build of current scene.

Shader "Standard" {
Properties {
 _Color ("Color", Color) = (1.000000,1.000000,1.000000,1.000000)
 _MainTex ("Albedo", 2D) = "white" { }
 _Cutoff ("Alpha Cutoff", Range(0.000000,1.000000)) = 0.500000
 _Glossiness ("Smoothness", Range(0.000000,1.000000)) = 0.500000
 _GlossMapScale ("Smoothness Scale", Range(0.000000,1.000000)) = 1.000000
[Enum(Metallic Alpha,0,Albedo Alpha,1)]  _SmoothnessTextureChannel ("Smoothness texture channel", Float) = 0.000000
[Gamma]  _Metallic ("Metallic", Range(0.000000,1.000000)) = 0.000000
 _MetallicGlossMap ("Metallic", 2D) = "white" { }
[ToggleOff]  _SpecularHighlights ("Specular Highlights", Float) = 1.000000
[ToggleOff]  _GlossyReflections ("Glossy Reflections", Float) = 1.000000
 _BumpScale ("Scale", Float) = 1.000000
 _BumpMap ("Normal Map", 2D) = "bump" { }
 _Parallax ("Height Scale", Range(0.005000,0.080000)) = 0.020000
 _ParallaxMap ("Height Map", 2D) = "black" { }
 _OcclusionStrength ("Strength", Range(0.000000,1.000000)) = 1.000000
 _OcclusionMap ("Occlusion", 2D) = "white" { }
 _EmissionColor ("Color", Color) = (0.000000,0.000000,0.000000,1.000000)
 _EmissionMap ("Emission", 2D) = "white" { }
 _DetailMask ("Detail Mask", 2D) = "white" { }
 _DetailAlbedoMap ("Detail Albedo x2", 2D) = "grey" { }
 _DetailNormalMapScale ("Scale", Float) = 1.000000
 _DetailNormalMap ("Normal Map", 2D) = "bump" { }
[Enum(UV0,0,UV1,1)]  _UVSec ("UV Set for secondary textures", Float) = 0.000000
[HideInInspector]  _Mode ("__mode", Float) = 0.000000
[HideInInspector]  _SrcBlend ("__src", Float) = 1.000000
[HideInInspector]  _DstBlend ("__dst", Float) = 0.000000
[HideInInspector]  _ZWrite ("__zw", Float) = 1.000000
}
SubShader { 
 LOD 300
 Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }
 Pass {
  Name "FORWARD"
  Tags { "LIGHTMODE"="FORWARDBASE" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite [_ZWrite]
  Blend [_SrcBlend] [_DstBlend]
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat0.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set CUBE Texture "unity_SpecCube0" to slot 2
Set CUBE Texture "unity_SpecCube1" to slot 3
Set 3D Texture "unity_ProbeVolumeSH" to slot 4

Constant Buffer "Globals" (310 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 192
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SHAr at 8
  VectorHalf4 unity_SHAg at 16
  VectorHalf4 unity_SHAb at 24
  VectorHalf4 unity_OcclusionMaskSelector at 32
  Vector4 unity_SpecCube0_BoxMax at 48
  Vector4 unity_SpecCube0_BoxMin at 64
  Vector4 unity_SpecCube0_ProbePosition at 80
  VectorHalf4 unity_SpecCube0_HDR at 96
  Vector4 unity_SpecCube1_BoxMax at 112
  Vector4 unity_SpecCube1_BoxMin at 128
  Vector4 unity_SpecCube1_ProbePosition at 144
  VectorHalf4 unity_SpecCube1_HDR at 160
  Vector4 unity_ProbeVolumeParams at 176
  Vector3 unity_ProbeVolumeSizeInv at 256
  Vector3 unity_ProbeVolumeMin at 272
  VectorHalf4 _LightColor0 at 288
  VectorHalf4 _Color at 296
  ScalarHalf _Metallic at 304
  ScalarHalf _Glossiness at 306
  ScalarHalf _OcclusionStrength at 308
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_OcclusionMaskSelector;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (2) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (2) ]] ,
    texturecube<half, access::sample > unity_SpecCube1 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (3) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (4) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    float4 u_xlat5;
    half4 u_xlat16_5;
    half3 u_xlat16_6;
    float3 u_xlat7;
    half4 u_xlat16_7;
    half3 u_xlat16_8;
    float4 u_xlat9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    half3 u_xlat16_11;
    half3 u_xlat16_12;
    float3 u_xlat13;
    half3 u_xlat16_13;
    float3 u_xlat14;
    bool3 u_xlatb14;
    half3 u_xlat16_15;
    bool3 u_xlatb16;
    half3 u_xlat16_17;
    float3 u_xlat19;
    half u_xlat16_19;
    bool u_xlatb19;
    half3 u_xlat16_22;
    half3 u_xlat16_24;
    half3 u_xlat16_27;
    float u_xlat28;
    half u_xlat16_31;
    float u_xlat37;
    half u_xlat16_40;
    half u_xlat16_42;
    float u_xlat55;
    half u_xlat16_55;
    bool u_xlatb55;
    half u_xlat16_56;
    half u_xlat16_57;
    half u_xlat16_58;
    half u_xlat16_60;
    half u_xlat16_62;
    half u_xlat16_65;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_56 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_56));
    u_xlat16_57 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_57 = rsqrt(u_xlat16_57);
    u_xlat16_0.xyz = half3(half3(u_xlat16_57) * input.TEXCOORD4.xyz);
    u_xlat16_57 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_57 = rsqrt(u_xlat16_57);
    u_xlat16_4.xyz = half3(half3(u_xlat16_57) * input.TEXCOORD1.xyz);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb19 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat5.xyz;
        u_xlat5.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_24.x = input.TEXCOORD2.w;
        u_xlat16_24.y = input.TEXCOORD3.w;
        u_xlat16_24.z = input.TEXCOORD4.w;
        u_xlat19.xyz = (bool(u_xlatb19)) ? u_xlat5.xyz : float3(u_xlat16_24.xyz);
        u_xlat19.xyz = u_xlat19.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat5.yzw = u_xlat19.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat19.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat37 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat37, u_xlat19.x);
        u_xlat5 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xzw);
        u_xlat16_5 = half4(u_xlat5);
    } else {
        u_xlat16_5.x = half(1.0);
        u_xlat16_5.y = half(1.0);
        u_xlat16_5.z = half(1.0);
        u_xlat16_5.w = half(1.0);
    }
    u_xlat16_58 = dot(u_xlat16_5, Globals.unity_OcclusionMaskSelector);
    u_xlat16_58 = clamp(u_xlat16_58, 0.0h, 1.0h);
    u_xlat16_19 = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_6.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_6.x = half(u_xlat16_19 * Globals._OcclusionStrength + u_xlat16_6.x);
    u_xlat16_24.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_42 = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_42 = half(u_xlat16_42 + u_xlat16_42);
    u_xlat16_7.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_42)) + u_xlat16_4.xyz);
    u_xlat16_8.xyz = half3(half3(u_xlat16_58) * Globals._LightColor0.xyz);
    if(u_xlatb1){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat19.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat19.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat19.xyz;
        u_xlat19.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat19.xyz;
        u_xlat19.xyz = u_xlat19.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_27.x = input.TEXCOORD2.w;
        u_xlat16_27.y = input.TEXCOORD3.w;
        u_xlat16_27.z = input.TEXCOORD4.w;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat19.xyz : float3(u_xlat16_27.xyz);
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat19.x = u_xlat1.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat28 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat19.x = max(u_xlat19.x, u_xlat10.x);
        u_xlat1.x = min(u_xlat28, u_xlat19.x);
        u_xlat5 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat10.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat9 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz);
        u_xlat16_0.w = 1.0;
        u_xlat16_11.x = half(dot(u_xlat5, float4(u_xlat16_0)));
        u_xlat16_11.y = half(dot(u_xlat9, float4(u_xlat16_0)));
        u_xlat16_11.z = half(dot(u_xlat1, float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_11.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_11.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_11.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_11.xyz = half3(u_xlat16_11.xyz + input.TEXCOORD5.xyz);
    u_xlat16_11.xyz = half3(max(float3(u_xlat16_11.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_11.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb55 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb55){
        u_xlat16_58 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
        u_xlat16_58 = rsqrt(u_xlat16_58);
        u_xlat16_11.xyz = half3(half3(u_xlat16_58) * u_xlat16_7.xyz);
        u_xlat16_12.x = input.TEXCOORD2.w;
        u_xlat16_12.y = input.TEXCOORD3.w;
        u_xlat16_12.z = input.TEXCOORD4.w;
        u_xlat10.xyz = (-float3(u_xlat16_12.xyz)) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_11.xyz);
        u_xlat13.xyz = (-float3(u_xlat16_12.xyz)) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat13.xyz = u_xlat13.xyz / float3(u_xlat16_11.xyz);
        u_xlatb14.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
        u_xlat16_15.x = (u_xlatb14.x) ? half(u_xlat10.x) : half(u_xlat13.x);
        u_xlat16_15.y = (u_xlatb14.y) ? half(u_xlat10.y) : half(u_xlat13.y);
        u_xlat16_15.z = (u_xlatb14.z) ? half(u_xlat10.z) : half(u_xlat13.z);
        u_xlat16_58 = min(u_xlat16_15.y, u_xlat16_15.x);
        u_xlat16_58 = min(u_xlat16_15.z, u_xlat16_58);
        u_xlat10.xyz = float3(u_xlat16_12.xyz) + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat10.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_58) + u_xlat10.xyz;
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    } else {
        u_xlat16_10.xyz = u_xlat16_7.xyz;
    }
    u_xlat16_58 = half((-float(u_xlat16_24.x)) * 0.699999988 + 1.70000005);
    u_xlat16_58 = half(u_xlat16_58 * u_xlat16_24.x);
    u_xlat16_58 = half(float(u_xlat16_58) * 6.0);
    u_xlat16_5 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_10.xyz), level(float(u_xlat16_58)));
    u_xlat16_42 = half(float(u_xlat16_5.w) + -1.0);
    u_xlat16_42 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_42) + 1.0);
    u_xlat16_42 = half(u_xlat16_42 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_11.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_42));
    u_xlatb55 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb55){
        u_xlatb55 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb55){
            u_xlat16_60 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
            u_xlat16_60 = rsqrt(u_xlat16_60);
            u_xlat16_12.xyz = half3(half3(u_xlat16_60) * u_xlat16_7.xyz);
            u_xlat16_15.x = input.TEXCOORD2.w;
            u_xlat16_15.y = input.TEXCOORD3.w;
            u_xlat16_15.z = input.TEXCOORD4.w;
            u_xlat13.xyz = (-float3(u_xlat16_15.xyz)) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat13.xyz = u_xlat13.xyz / float3(u_xlat16_12.xyz);
            u_xlat14.xyz = (-float3(u_xlat16_15.xyz)) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat14.xyz = u_xlat14.xyz / float3(u_xlat16_12.xyz);
            u_xlatb16.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_12.xyz));
            u_xlat16_17.x = (u_xlatb16.x) ? half(u_xlat13.x) : half(u_xlat14.x);
            u_xlat16_17.y = (u_xlatb16.y) ? half(u_xlat13.y) : half(u_xlat14.y);
            u_xlat16_17.z = (u_xlatb16.z) ? half(u_xlat13.z) : half(u_xlat14.z);
            u_xlat16_60 = min(u_xlat16_17.y, u_xlat16_17.x);
            u_xlat16_60 = min(u_xlat16_17.z, u_xlat16_60);
            u_xlat13.xyz = float3(u_xlat16_15.xyz) + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat7.xyz = float3(u_xlat16_12.xyz) * float3(u_xlat16_60) + u_xlat13.xyz;
            u_xlat16_7.xyz = half3(u_xlat7.xyz);
        }
        u_xlat16_7 = unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_7.xyz), level(float(u_xlat16_58)));
        u_xlat16_58 = half(float(u_xlat16_7.w) + -1.0);
        u_xlat16_58 = half(float(Globals.unity_SpecCube1_HDR.w) * float(u_xlat16_58) + 1.0);
        u_xlat16_58 = half(u_xlat16_58 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_12.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_58));
        u_xlat16_13.xyz = half3(half3(u_xlat16_42) * u_xlat16_5.xyz + (-u_xlat16_12.xyz));
        u_xlat11.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_13.xyz) + float3(u_xlat16_12.xyz);
        u_xlat16_11.xyz = half3(u_xlat11.xyz);
    }
    u_xlat16_11.xyz = half3(u_xlat16_6.xxx * u_xlat16_11.xyz);
    u_xlat16_12.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_57) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_57 = dot(u_xlat16_12.xyz, u_xlat16_12.xyz);
    u_xlat16_55 = half(max(float(u_xlat16_57), 0.00100000005));
    u_xlat16_57 = rsqrt(u_xlat16_55);
    u_xlat16_12.xyz = half3(half3(u_xlat16_57) * u_xlat16_12.xyz);
    u_xlat16_57 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_22.x = dot(u_xlat16_0.xyz, u_xlat16_12.xyz);
    u_xlat16_22.x = clamp(u_xlat16_22.x, 0.0h, 1.0h);
    u_xlat16_40 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_12.xyz);
    u_xlat16_40 = clamp(u_xlat16_40, 0.0h, 1.0h);
    u_xlat16_58 = half(u_xlat16_40 * u_xlat16_40);
    u_xlat16_58 = dot(half2(u_xlat16_58), u_xlat16_24.xx);
    u_xlat16_58 = half(float(u_xlat16_58) + -0.5);
    u_xlat16_42 = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_60 = half(u_xlat16_42 * u_xlat16_42);
    u_xlat16_60 = half(u_xlat16_60 * u_xlat16_60);
    u_xlat16_42 = half(u_xlat16_42 * u_xlat16_60);
    u_xlat16_42 = half(float(u_xlat16_58) * float(u_xlat16_42) + 1.0);
    u_xlat16_60 = half(-abs(float(u_xlat16_57)) + 1.0);
    u_xlat16_62 = half(u_xlat16_60 * u_xlat16_60);
    u_xlat16_62 = half(u_xlat16_62 * u_xlat16_62);
    u_xlat16_60 = half(u_xlat16_60 * u_xlat16_62);
    u_xlat16_58 = half(float(u_xlat16_58) * float(u_xlat16_60) + 1.0);
    u_xlat16_58 = half(u_xlat16_58 * u_xlat16_42);
    u_xlat16_58 = half(u_xlat16_4.x * u_xlat16_58);
    u_xlat16_42 = half(u_xlat16_24.x * u_xlat16_24.x);
    u_xlat16_62 = half((-float(u_xlat16_24.x)) * float(u_xlat16_24.x) + 1.0);
    u_xlat16_65 = half(abs(u_xlat16_57) * u_xlat16_62 + u_xlat16_42);
    u_xlat16_62 = half(u_xlat16_4.x * u_xlat16_62 + u_xlat16_42);
    u_xlat16_57 = half(abs(u_xlat16_57) * u_xlat16_62);
    u_xlat16_57 = half(u_xlat16_4.x * u_xlat16_65 + u_xlat16_57);
    u_xlat16_55 = half(float(u_xlat16_57) + 9.99999975e-06);
    u_xlat16_55 = half(0.5 / float(u_xlat16_55));
    u_xlat16_57 = half(u_xlat16_42 * u_xlat16_42);
    u_xlat16_62 = half(u_xlat16_22.x * u_xlat16_57 + (-u_xlat16_22.x));
    u_xlat16_13.x = half(float(u_xlat16_62) * float(u_xlat16_22.x) + 1.0);
    u_xlat16_31 = half(float(u_xlat16_57) * 0.318309873);
    u_xlat16_13.x = half(float(u_xlat16_13.x) * float(u_xlat16_13.x) + 1.00000001e-07);
    u_xlat16_13.x = half(u_xlat16_31 / u_xlat16_13.x);
    u_xlat16_57 = half(u_xlat16_55 * u_xlat16_13.x);
    u_xlat16_55 = half(float(u_xlat16_57) * 3.14159274);
    u_xlat16_55 = half(max(float(u_xlat16_55), 9.99999975e-05));
    u_xlat16_55 = sqrt(u_xlat16_55);
    u_xlat16_57 = half(u_xlat16_4.x * u_xlat16_55);
    u_xlat16_4.x = half(u_xlat16_42 * u_xlat16_24.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_22.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb55 = u_xlat16_22.x!=0.0;
    u_xlat55 = u_xlatb55 ? 1.0 : float(0.0);
    u_xlat16_57 = half(u_xlat55 * float(u_xlat16_57));
    u_xlat16_56 = half((-u_xlat16_56) + Globals._Glossiness);
    u_xlat16_56 = half(float(u_xlat16_56) + 1.0);
    u_xlat16_56 = clamp(u_xlat16_56, 0.0h, 1.0h);
    u_xlat16_12.xyz = half3(half3(u_xlat16_58) * u_xlat16_8.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_1.xyz * u_xlat16_6.xxx + u_xlat16_12.xyz);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_57));
    u_xlat16_57 = half((-float(u_xlat16_40)) + 1.0);
    u_xlat16_22.x = half(u_xlat16_57 * u_xlat16_57);
    u_xlat16_22.x = half(u_xlat16_22.x * u_xlat16_22.x);
    u_xlat16_57 = half(u_xlat16_57 * u_xlat16_22.x);
    u_xlat16_22.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_22.xyz = half3(u_xlat16_22.xyz * half3(u_xlat16_57) + u_xlat16_2.xyz);
    u_xlat16_22.xyz = half3(u_xlat16_22.xyz * u_xlat16_8.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_6.xyz + u_xlat16_22.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_11.xyz * u_xlat16_4.xxx);
    u_xlat16_6.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_56));
    u_xlat16_2.xyz = half3(half3(u_xlat16_60) * u_xlat16_6.xyz + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
bool u_xlatb4;
vec3 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
vec4 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat19;
vec3 u_xlat20;
vec3 u_xlat23;
float u_xlat32;
float u_xlat33;
float u_xlat34;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlatb48 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb48){
        u_xlatb4 = unity_ProbeVolumeParams.y==1.0;
        u_xlat19.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat19.xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat19.xyz;
        u_xlat19.xyz = u_xlat19.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat20.x = vs_TEXCOORD2.w;
        u_xlat20.y = vs_TEXCOORD3.w;
        u_xlat20.z = vs_TEXCOORD4.w;
        u_xlat4.xyz = (bool(u_xlatb4)) ? u_xlat19.xyz : u_xlat20.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19.x = u_xlat4.y * 0.25 + 0.75;
        u_xlat5.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19.x, u_xlat5.x);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat4.x = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat4.x = clamp(u_xlat4.x, 0.0, 1.0);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat19.x = (-_OcclusionStrength) + 1.0;
    u_xlat19.x = u_xlat10_5.y * _OcclusionStrength + u_xlat19.x;
    u_xlat34 = (-_Glossiness) + 1.0;
    u_xlat49 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat49 = u_xlat49 + u_xlat49;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat49)) + u_xlat3.xyz;
    u_xlat6.xyz = u_xlat4.xxx * _LightColor0.xyz;
    if(u_xlatb48){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat23.x = vs_TEXCOORD2.w;
        u_xlat23.y = vs_TEXCOORD3.w;
        u_xlat23.z = vs_TEXCOORD4.w;
        u_xlat7.xyz = (bool(u_xlatb48)) ? u_xlat7.xyz : u_xlat23.xyz;
        u_xlat7.xyz = u_xlat7.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat7.yzw = u_xlat7.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat7.y * 0.25;
        u_xlat4.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat49 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat4.x);
        u_xlat7.x = min(u_xlat49, u_xlat48);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat7.xzw);
        u_xlat9.xyz = u_xlat7.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat7.xyz = u_xlat7.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(u_xlat10_8, u_xlat2);
        u_xlat8.y = dot(u_xlat10_9, u_xlat2);
        u_xlat8.z = dot(u_xlat10_7, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(unity_SHAr, u_xlat2);
        u_xlat8.y = dot(unity_SHAg, u_xlat2);
        u_xlat8.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat7.xyz = u_xlat8.xyz + vs_TEXCOORD5.xyz;
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat7.xyz = log2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat7.xyz = exp2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat47) * u_xlat5.xyz;
        u_xlat9.x = vs_TEXCOORD2.w;
        u_xlat9.y = vs_TEXCOORD3.w;
        u_xlat9.z = vs_TEXCOORD4.w;
        u_xlat10.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
        u_xlat11.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat8.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat9.xyz = u_xlat9.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat8.xyz = u_xlat8.xyz * vec3(u_xlat47) + u_xlat9.xyz;
    } else {
        u_xlat8.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat34) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat34;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_8 = textureLod(unity_SpecCube0, u_xlat8.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_8.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat9.xyz = u_xlat10_8.xyz * vec3(u_xlat48);
    u_xlatb4 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb4){
        u_xlatb4 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb4){
            u_xlat4.x = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat4.x = inversesqrt(u_xlat4.x);
            u_xlat10.xyz = u_xlat4.xxx * u_xlat5.xyz;
            u_xlat11.x = vs_TEXCOORD2.w;
            u_xlat11.y = vs_TEXCOORD3.w;
            u_xlat11.z = vs_TEXCOORD4.w;
            u_xlat12.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat10.xyz;
            u_xlat13.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat10.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat10.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat4.x = min(u_xlat12.y, u_xlat12.x);
            u_xlat4.x = min(u_xlat12.z, u_xlat4.x);
            u_xlat11.xyz = u_xlat11.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat10.xyz * u_xlat4.xxx + u_xlat11.xyz;
        //ENDIF
        }
        u_xlat10_5 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_5.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat48) * u_xlat10_8.xyz + (-u_xlat5.xyz);
        u_xlat9.xyz = unity_SpecCube0_BoxMin.www * u_xlat8.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = u_xlat19.xxx * u_xlat9.xyz;
    u_xlat8.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat8.xyz = vec3(u_xlat46) * u_xlat8.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat8.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat8.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), vec2(u_xlat34));
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat34 * u_xlat34;
    u_xlat33 = (-u_xlat34) * u_xlat34 + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat34;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat6.xyz;
    u_xlat3.xzw = u_xlat7.xyz * u_xlat19.xxx + u_xlat3.xzw;
    u_xlat4.xyz = u_xlat6.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 64
  Matrix4x4 unity_WorldToObject at 128
  Matrix4x4 unity_MatrixVP at 192
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHBr at 32
  VectorHalf4 unity_SHBg at 40
  VectorHalf4 unity_SHBb at 48
  VectorHalf4 unity_SHC at 56
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    float4 u_xlat2;
    half u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat17;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat17 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat17 = rsqrt(u_xlat17);
    u_xlat1.xyz = float3(u_xlat17) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat16_3 = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3 = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_1);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_3) + u_xlat16_4.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat2.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat2.zz + u_xlat2.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set CUBE Texture "unity_SpecCube0" to slot 3
Set CUBE Texture "unity_SpecCube1" to slot 4
Set 3D Texture "unity_ProbeVolumeSH" to slot 5

Constant Buffer "Globals" (406 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 80
  Matrix4x4 unity_ProbeVolumeWorldToObject at 288
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  VectorHalf4 unity_SHAr at 24
  VectorHalf4 unity_SHAg at 32
  VectorHalf4 unity_SHAb at 40
  VectorHalf4 unity_OcclusionMaskSelector at 48
  VectorHalf4 _LightShadowData at 56
  Vector4 unity_ShadowFadeCenterAndType at 64
  Vector4 unity_SpecCube0_BoxMax at 144
  Vector4 unity_SpecCube0_BoxMin at 160
  Vector4 unity_SpecCube0_ProbePosition at 176
  VectorHalf4 unity_SpecCube0_HDR at 192
  Vector4 unity_SpecCube1_BoxMax at 208
  Vector4 unity_SpecCube1_BoxMin at 224
  Vector4 unity_SpecCube1_ProbePosition at 240
  VectorHalf4 unity_SpecCube1_HDR at 256
  Vector4 unity_ProbeVolumeParams at 272
  Vector3 unity_ProbeVolumeSizeInv at 352
  Vector3 unity_ProbeVolumeMin at 368
  VectorHalf4 _LightColor0 at 384
  VectorHalf4 _Color at 392
  ScalarHalf _Metallic at 400
  ScalarHalf _Glossiness at 402
  ScalarHalf _OcclusionStrength at 404
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (3) ]] ,
    texturecube<half, access::sample > unity_SpecCube1 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (4) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (5) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    half4 u_xlat16_7;
    half3 u_xlat16_8;
    float4 u_xlat9;
    half4 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    half3 u_xlat16_11;
    float3 u_xlat12;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    bool3 u_xlatb14;
    half3 u_xlat16_15;
    float3 u_xlat17;
    bool u_xlatb17;
    half3 u_xlat16_20;
    float3 u_xlat23;
    half3 u_xlat16_23;
    float u_xlat25;
    half u_xlat16_27;
    float2 u_xlat33;
    half u_xlat16_33;
    bool u_xlatb33;
    half u_xlat16_36;
    half u_xlat16_39;
    float u_xlat49;
    half u_xlat16_49;
    bool u_xlatb49;
    half u_xlat16_50;
    half u_xlat16_51;
    half u_xlat16_52;
    half u_xlat16_53;
    half u_xlat16_55;
    half u_xlat16_56;
    half u_xlat16_58;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_50 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_50));
    u_xlat16_51 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_0.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD4.xyz);
    u_xlat16_51 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_4.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD1.xyz);
    u_xlat16_5.x = input.TEXCOORD2.w;
    u_xlat16_5.y = input.TEXCOORD3.w;
    u_xlat16_5.z = input.TEXCOORD4.w;
    u_xlat1.xyz = (-float3(u_xlat16_5.xyz)) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat17.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat17.x = dot(u_xlat17.xyz, u_xlat17.xyz);
    u_xlat17.x = sqrt(u_xlat17.x);
    u_xlat17.x = (-u_xlat1.x) + u_xlat17.x;
    u_xlat1.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat17.x + u_xlat1.x;
    u_xlat1.x = u_xlat1.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat1.x = clamp(u_xlat1.x, 0.0f, 1.0f);
    u_xlatb17 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb17){
        u_xlatb33 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb33)) ? u_xlat6.xyz : float3(u_xlat16_5.xyz);
        u_xlat6.xyz = u_xlat6.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat6.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat33.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat49 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat49, u_xlat33.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_52 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_52 = clamp(u_xlat16_52, 0.0h, 1.0h);
    u_xlat33.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_33 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat33.xy).x;
    u_xlat16_53 = half(u_xlat1.x + float(u_xlat16_33));
    u_xlat16_53 = clamp(u_xlat16_53, 0.0h, 1.0h);
    u_xlat16_52 = min(u_xlat16_52, u_xlat16_53);
    u_xlat16_52 = (u_xlatb17) ? u_xlat16_52 : u_xlat16_53;
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_53 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_53 = half(u_xlat16_1.x * Globals._OcclusionStrength + u_xlat16_53);
    u_xlat16_7.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_23.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_23.x = half(u_xlat16_23.x + u_xlat16_23.x);
    u_xlat16_23.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_23.xxx) + u_xlat16_4.xyz);
    u_xlat16_8.xyz = half3(half3(u_xlat16_52) * Globals._LightColor0.xyz);
    if(u_xlatb17){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat17.xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat17.xyz : float3(u_xlat16_5.xyz);
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat17.x = u_xlat1.y * 0.25;
        u_xlat9.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat25 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat9.x);
        u_xlat1.x = min(u_xlat25, u_xlat17.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat9.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat9 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz);
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = half(dot(u_xlat6, float4(u_xlat16_0)));
        u_xlat16_10.y = half(dot(u_xlat9, float4(u_xlat16_0)));
        u_xlat16_10.z = half(dot(u_xlat1, float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_10.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_10.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_10.xyz = half3(u_xlat16_10.xyz + input.TEXCOORD5.xyz);
    u_xlat16_10.xyz = half3(max(float3(u_xlat16_10.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_10.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb49 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb49){
        u_xlat16_52 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
        u_xlat16_52 = rsqrt(u_xlat16_52);
        u_xlat16_10.xyz = half3(half3(u_xlat16_52) * u_xlat16_23.xyz);
        u_xlat9.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_10.xyz);
        u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_10.xyz);
        u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_10.xyz));
        u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat9.x) : half(u_xlat11.x);
        u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat9.y) : half(u_xlat11.y);
        u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat9.z) : half(u_xlat11.z);
        u_xlat16_52 = min(u_xlat16_13.y, u_xlat16_13.x);
        u_xlat16_52 = min(u_xlat16_13.z, u_xlat16_52);
        u_xlat9.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = float3(u_xlat16_10.xyz) * float3(u_xlat16_52) + u_xlat9.xyz;
        u_xlat16_9.xyz = half3(u_xlat9.xyz);
    } else {
        u_xlat16_9.xyz = u_xlat16_23.xyz;
    }
    u_xlat16_52 = half((-float(u_xlat16_7.x)) * 0.699999988 + 1.70000005);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_7.x);
    u_xlat16_52 = half(float(u_xlat16_52) * 6.0);
    u_xlat16_6 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_9.xyz), level(float(u_xlat16_52)));
    u_xlat16_56 = half(float(u_xlat16_6.w) + -1.0);
    u_xlat16_56 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_56) + 1.0);
    u_xlat16_56 = half(u_xlat16_56 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_10.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_56));
    u_xlatb49 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat16_58 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
            u_xlat16_58 = rsqrt(u_xlat16_58);
            u_xlat16_13.xyz = half3(u_xlat16_23.xyz * half3(u_xlat16_58));
            u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_13.xyz);
            u_xlat12.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat12.xyz = u_xlat12.xyz / float3(u_xlat16_13.xyz);
            u_xlatb14.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_13.xyz));
            u_xlat16_15.x = (u_xlatb14.x) ? half(u_xlat11.x) : half(u_xlat12.x);
            u_xlat16_15.y = (u_xlatb14.y) ? half(u_xlat11.y) : half(u_xlat12.y);
            u_xlat16_15.z = (u_xlatb14.z) ? half(u_xlat11.z) : half(u_xlat12.z);
            u_xlat16_58 = min(u_xlat16_15.y, u_xlat16_15.x);
            u_xlat16_58 = min(u_xlat16_15.z, u_xlat16_58);
            u_xlat11.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat23.xyz = float3(u_xlat16_13.xyz) * float3(u_xlat16_58) + u_xlat11.xyz;
            u_xlat16_23.xyz = half3(u_xlat23.xyz);
        }
        u_xlat16_9 = unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_23.xyz), level(float(u_xlat16_52)));
        u_xlat16_52 = half(float(u_xlat16_9.w) + -1.0);
        u_xlat16_52 = half(float(Globals.unity_SpecCube1_HDR.w) * float(u_xlat16_52) + 1.0);
        u_xlat16_52 = half(u_xlat16_52 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_5.xyz = half3(u_xlat16_9.xyz * half3(u_xlat16_52));
        u_xlat16_11.xyz = half3(half3(u_xlat16_56) * u_xlat16_6.xyz + (-u_xlat16_5.xyz));
        u_xlat10.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_11.xyz) + float3(u_xlat16_5.xyz);
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    }
    u_xlat16_5.xyz = half3(half3(u_xlat16_53) * u_xlat16_10.xyz);
    u_xlat16_23.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_51) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_51 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
    u_xlat16_49 = half(max(float(u_xlat16_51), 0.00100000005));
    u_xlat16_51 = rsqrt(u_xlat16_49);
    u_xlat16_23.xyz = half3(half3(u_xlat16_51) * u_xlat16_23.xyz);
    u_xlat16_51 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_20.x = dot(u_xlat16_0.xyz, u_xlat16_23.xyz);
    u_xlat16_20.x = clamp(u_xlat16_20.x, 0.0h, 1.0h);
    u_xlat16_36 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_23.xyz);
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_52 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_52 = dot(half2(u_xlat16_52), u_xlat16_7.xx);
    u_xlat16_52 = half(float(u_xlat16_52) + -0.5);
    u_xlat16_23.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_39 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_39);
    u_xlat16_23.x = half(float(u_xlat16_52) * float(u_xlat16_23.x) + 1.0);
    u_xlat16_39 = half(-abs(float(u_xlat16_51)) + 1.0);
    u_xlat16_55 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_55 = half(u_xlat16_55 * u_xlat16_55);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_55);
    u_xlat16_52 = half(float(u_xlat16_52) * float(u_xlat16_39) + 1.0);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_23.x);
    u_xlat16_52 = half(u_xlat16_4.x * u_xlat16_52);
    u_xlat16_23.x = half(u_xlat16_7.x * u_xlat16_7.x);
    u_xlat16_55 = half((-float(u_xlat16_7.x)) * float(u_xlat16_7.x) + 1.0);
    u_xlat16_56 = half(abs(u_xlat16_51) * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_4.x * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_51 = half(abs(u_xlat16_51) * u_xlat16_55);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_56 + u_xlat16_51);
    u_xlat16_49 = half(float(u_xlat16_51) + 9.99999975e-06);
    u_xlat16_49 = half(0.5 / float(u_xlat16_49));
    u_xlat16_51 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_20.x * u_xlat16_51 + (-u_xlat16_20.x));
    u_xlat16_11.x = half(float(u_xlat16_55) * float(u_xlat16_20.x) + 1.0);
    u_xlat16_27 = half(float(u_xlat16_51) * 0.318309873);
    u_xlat16_11.x = half(float(u_xlat16_11.x) * float(u_xlat16_11.x) + 1.00000001e-07);
    u_xlat16_11.x = half(u_xlat16_27 / u_xlat16_11.x);
    u_xlat16_51 = half(u_xlat16_49 * u_xlat16_11.x);
    u_xlat16_49 = half(float(u_xlat16_51) * 3.14159274);
    u_xlat16_49 = half(max(float(u_xlat16_49), 9.99999975e-05));
    u_xlat16_49 = sqrt(u_xlat16_49);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_49);
    u_xlat16_4.x = half(u_xlat16_23.x * u_xlat16_7.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_20.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb49 = u_xlat16_20.x!=0.0;
    u_xlat49 = u_xlatb49 ? 1.0 : float(0.0);
    u_xlat16_51 = half(u_xlat49 * float(u_xlat16_51));
    u_xlat16_50 = half((-u_xlat16_50) + Globals._Glossiness);
    u_xlat16_50 = half(float(u_xlat16_50) + 1.0);
    u_xlat16_50 = clamp(u_xlat16_50, 0.0h, 1.0h);
    u_xlat16_7.xyw = half3(half3(u_xlat16_52) * u_xlat16_8.xyz);
    u_xlat16_7.xyw = half3(u_xlat16_1.xyz * half3(u_xlat16_53) + u_xlat16_7.xyw);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_51));
    u_xlat16_51 = half((-float(u_xlat16_36)) + 1.0);
    u_xlat16_20.x = half(u_xlat16_51 * u_xlat16_51);
    u_xlat16_20.x = half(u_xlat16_20.x * u_xlat16_20.x);
    u_xlat16_51 = half(u_xlat16_51 * u_xlat16_20.x);
    u_xlat16_20.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * half3(u_xlat16_51) + u_xlat16_2.xyz);
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * u_xlat16_8.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_7.xyw + u_xlat16_20.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_5.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_50));
    u_xlat16_2.xyz = half3(half3(u_xlat16_39) * u_xlat16_5.xyz + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    u_xlat1.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = u_xlat1.x * u_xlat1.x + (-u_xlat10);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(unity_SHBr, u_xlat2);
    u_xlat1.y = dot(unity_SHBg, u_xlat2);
    u_xlat1.z = dot(unity_SHBb, u_xlat2);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat10) + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set CUBE Texture "unity_SpecCube0" to slot 3
Set CUBE Texture "unity_SpecCube1" to slot 4
Set 3D Texture "unity_ProbeVolumeSH" to slot 5

Constant Buffer "Globals" (320 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 192
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SHAr at 8
  VectorHalf4 unity_SHAg at 16
  VectorHalf4 unity_SHAb at 24
  VectorHalf4 unity_OcclusionMaskSelector at 32
  Vector4 unity_SpecCube0_BoxMax at 48
  Vector4 unity_SpecCube0_BoxMin at 64
  Vector4 unity_SpecCube0_ProbePosition at 80
  VectorHalf4 unity_SpecCube0_HDR at 96
  Vector4 unity_SpecCube1_BoxMax at 112
  Vector4 unity_SpecCube1_BoxMin at 128
  Vector4 unity_SpecCube1_ProbePosition at 144
  VectorHalf4 unity_SpecCube1_HDR at 160
  Vector4 unity_ProbeVolumeParams at 176
  Vector3 unity_ProbeVolumeSizeInv at 256
  Vector3 unity_ProbeVolumeMin at 272
  VectorHalf4 _LightColor0 at 288
  VectorHalf4 _Color at 296
  ScalarHalf _Metallic at 304
  ScalarHalf _Glossiness at 306
  ScalarHalf _OcclusionStrength at 308
  VectorHalf4 _EmissionColor at 312
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_OcclusionMaskSelector;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (3) ]] ,
    texturecube<half, access::sample > unity_SpecCube1 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (4) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (5) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    float4 u_xlat5;
    half4 u_xlat16_5;
    half3 u_xlat16_6;
    float3 u_xlat7;
    half4 u_xlat16_7;
    half3 u_xlat16_8;
    float4 u_xlat9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    half3 u_xlat16_11;
    half3 u_xlat16_12;
    float3 u_xlat13;
    half3 u_xlat16_13;
    float3 u_xlat14;
    bool3 u_xlatb14;
    half3 u_xlat16_15;
    bool3 u_xlatb16;
    half3 u_xlat16_17;
    float3 u_xlat19;
    half u_xlat16_19;
    bool u_xlatb19;
    half3 u_xlat16_22;
    half3 u_xlat16_24;
    half3 u_xlat16_27;
    float u_xlat28;
    half u_xlat16_31;
    float u_xlat37;
    half u_xlat16_40;
    half u_xlat16_42;
    float u_xlat55;
    half u_xlat16_55;
    bool u_xlatb55;
    half u_xlat16_56;
    half u_xlat16_57;
    half u_xlat16_58;
    half u_xlat16_60;
    half u_xlat16_62;
    half u_xlat16_65;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_56 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_56));
    u_xlat16_57 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_57 = rsqrt(u_xlat16_57);
    u_xlat16_0.xyz = half3(half3(u_xlat16_57) * input.TEXCOORD4.xyz);
    u_xlat16_57 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_57 = rsqrt(u_xlat16_57);
    u_xlat16_4.xyz = half3(half3(u_xlat16_57) * input.TEXCOORD1.xyz);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb19 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat5.xyz;
        u_xlat5.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_24.x = input.TEXCOORD2.w;
        u_xlat16_24.y = input.TEXCOORD3.w;
        u_xlat16_24.z = input.TEXCOORD4.w;
        u_xlat19.xyz = (bool(u_xlatb19)) ? u_xlat5.xyz : float3(u_xlat16_24.xyz);
        u_xlat19.xyz = u_xlat19.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat5.yzw = u_xlat19.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat19.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat37 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat37, u_xlat19.x);
        u_xlat5 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xzw);
        u_xlat16_5 = half4(u_xlat5);
    } else {
        u_xlat16_5.x = half(1.0);
        u_xlat16_5.y = half(1.0);
        u_xlat16_5.z = half(1.0);
        u_xlat16_5.w = half(1.0);
    }
    u_xlat16_58 = dot(u_xlat16_5, Globals.unity_OcclusionMaskSelector);
    u_xlat16_58 = clamp(u_xlat16_58, 0.0h, 1.0h);
    u_xlat16_19 = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_6.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_6.x = half(u_xlat16_19 * Globals._OcclusionStrength + u_xlat16_6.x);
    u_xlat16_24.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_42 = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_42 = half(u_xlat16_42 + u_xlat16_42);
    u_xlat16_7.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_42)) + u_xlat16_4.xyz);
    u_xlat16_8.xyz = half3(half3(u_xlat16_58) * Globals._LightColor0.xyz);
    if(u_xlatb1){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat19.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat19.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat19.xyz;
        u_xlat19.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat19.xyz;
        u_xlat19.xyz = u_xlat19.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_27.x = input.TEXCOORD2.w;
        u_xlat16_27.y = input.TEXCOORD3.w;
        u_xlat16_27.z = input.TEXCOORD4.w;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat19.xyz : float3(u_xlat16_27.xyz);
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat19.x = u_xlat1.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat28 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat19.x = max(u_xlat19.x, u_xlat10.x);
        u_xlat1.x = min(u_xlat28, u_xlat19.x);
        u_xlat5 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat10.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat9 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz);
        u_xlat16_0.w = 1.0;
        u_xlat16_11.x = half(dot(u_xlat5, float4(u_xlat16_0)));
        u_xlat16_11.y = half(dot(u_xlat9, float4(u_xlat16_0)));
        u_xlat16_11.z = half(dot(u_xlat1, float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_11.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_11.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_11.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_11.xyz = half3(u_xlat16_11.xyz + input.TEXCOORD5.xyz);
    u_xlat16_11.xyz = half3(max(float3(u_xlat16_11.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_11.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb55 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb55){
        u_xlat16_58 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
        u_xlat16_58 = rsqrt(u_xlat16_58);
        u_xlat16_11.xyz = half3(half3(u_xlat16_58) * u_xlat16_7.xyz);
        u_xlat16_12.x = input.TEXCOORD2.w;
        u_xlat16_12.y = input.TEXCOORD3.w;
        u_xlat16_12.z = input.TEXCOORD4.w;
        u_xlat10.xyz = (-float3(u_xlat16_12.xyz)) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_11.xyz);
        u_xlat13.xyz = (-float3(u_xlat16_12.xyz)) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat13.xyz = u_xlat13.xyz / float3(u_xlat16_11.xyz);
        u_xlatb14.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
        u_xlat16_15.x = (u_xlatb14.x) ? half(u_xlat10.x) : half(u_xlat13.x);
        u_xlat16_15.y = (u_xlatb14.y) ? half(u_xlat10.y) : half(u_xlat13.y);
        u_xlat16_15.z = (u_xlatb14.z) ? half(u_xlat10.z) : half(u_xlat13.z);
        u_xlat16_58 = min(u_xlat16_15.y, u_xlat16_15.x);
        u_xlat16_58 = min(u_xlat16_15.z, u_xlat16_58);
        u_xlat10.xyz = float3(u_xlat16_12.xyz) + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat10.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_58) + u_xlat10.xyz;
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    } else {
        u_xlat16_10.xyz = u_xlat16_7.xyz;
    }
    u_xlat16_58 = half((-float(u_xlat16_24.x)) * 0.699999988 + 1.70000005);
    u_xlat16_58 = half(u_xlat16_58 * u_xlat16_24.x);
    u_xlat16_58 = half(float(u_xlat16_58) * 6.0);
    u_xlat16_5 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_10.xyz), level(float(u_xlat16_58)));
    u_xlat16_42 = half(float(u_xlat16_5.w) + -1.0);
    u_xlat16_42 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_42) + 1.0);
    u_xlat16_42 = half(u_xlat16_42 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_11.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_42));
    u_xlatb55 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb55){
        u_xlatb55 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb55){
            u_xlat16_60 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
            u_xlat16_60 = rsqrt(u_xlat16_60);
            u_xlat16_12.xyz = half3(half3(u_xlat16_60) * u_xlat16_7.xyz);
            u_xlat16_15.x = input.TEXCOORD2.w;
            u_xlat16_15.y = input.TEXCOORD3.w;
            u_xlat16_15.z = input.TEXCOORD4.w;
            u_xlat13.xyz = (-float3(u_xlat16_15.xyz)) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat13.xyz = u_xlat13.xyz / float3(u_xlat16_12.xyz);
            u_xlat14.xyz = (-float3(u_xlat16_15.xyz)) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat14.xyz = u_xlat14.xyz / float3(u_xlat16_12.xyz);
            u_xlatb16.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_12.xyz));
            u_xlat16_17.x = (u_xlatb16.x) ? half(u_xlat13.x) : half(u_xlat14.x);
            u_xlat16_17.y = (u_xlatb16.y) ? half(u_xlat13.y) : half(u_xlat14.y);
            u_xlat16_17.z = (u_xlatb16.z) ? half(u_xlat13.z) : half(u_xlat14.z);
            u_xlat16_60 = min(u_xlat16_17.y, u_xlat16_17.x);
            u_xlat16_60 = min(u_xlat16_17.z, u_xlat16_60);
            u_xlat13.xyz = float3(u_xlat16_15.xyz) + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat7.xyz = float3(u_xlat16_12.xyz) * float3(u_xlat16_60) + u_xlat13.xyz;
            u_xlat16_7.xyz = half3(u_xlat7.xyz);
        }
        u_xlat16_7 = unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_7.xyz), level(float(u_xlat16_58)));
        u_xlat16_58 = half(float(u_xlat16_7.w) + -1.0);
        u_xlat16_58 = half(float(Globals.unity_SpecCube1_HDR.w) * float(u_xlat16_58) + 1.0);
        u_xlat16_58 = half(u_xlat16_58 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_12.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_58));
        u_xlat16_13.xyz = half3(half3(u_xlat16_42) * u_xlat16_5.xyz + (-u_xlat16_12.xyz));
        u_xlat11.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_13.xyz) + float3(u_xlat16_12.xyz);
        u_xlat16_11.xyz = half3(u_xlat11.xyz);
    }
    u_xlat16_11.xyz = half3(u_xlat16_6.xxx * u_xlat16_11.xyz);
    u_xlat16_12.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_57) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_57 = dot(u_xlat16_12.xyz, u_xlat16_12.xyz);
    u_xlat16_55 = half(max(float(u_xlat16_57), 0.00100000005));
    u_xlat16_57 = rsqrt(u_xlat16_55);
    u_xlat16_12.xyz = half3(half3(u_xlat16_57) * u_xlat16_12.xyz);
    u_xlat16_57 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_22.x = dot(u_xlat16_0.xyz, u_xlat16_12.xyz);
    u_xlat16_22.x = clamp(u_xlat16_22.x, 0.0h, 1.0h);
    u_xlat16_40 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_12.xyz);
    u_xlat16_40 = clamp(u_xlat16_40, 0.0h, 1.0h);
    u_xlat16_58 = half(u_xlat16_40 * u_xlat16_40);
    u_xlat16_58 = dot(half2(u_xlat16_58), u_xlat16_24.xx);
    u_xlat16_58 = half(float(u_xlat16_58) + -0.5);
    u_xlat16_42 = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_60 = half(u_xlat16_42 * u_xlat16_42);
    u_xlat16_60 = half(u_xlat16_60 * u_xlat16_60);
    u_xlat16_42 = half(u_xlat16_42 * u_xlat16_60);
    u_xlat16_42 = half(float(u_xlat16_58) * float(u_xlat16_42) + 1.0);
    u_xlat16_60 = half(-abs(float(u_xlat16_57)) + 1.0);
    u_xlat16_62 = half(u_xlat16_60 * u_xlat16_60);
    u_xlat16_62 = half(u_xlat16_62 * u_xlat16_62);
    u_xlat16_60 = half(u_xlat16_60 * u_xlat16_62);
    u_xlat16_58 = half(float(u_xlat16_58) * float(u_xlat16_60) + 1.0);
    u_xlat16_58 = half(u_xlat16_58 * u_xlat16_42);
    u_xlat16_58 = half(u_xlat16_4.x * u_xlat16_58);
    u_xlat16_42 = half(u_xlat16_24.x * u_xlat16_24.x);
    u_xlat16_62 = half((-float(u_xlat16_24.x)) * float(u_xlat16_24.x) + 1.0);
    u_xlat16_65 = half(abs(u_xlat16_57) * u_xlat16_62 + u_xlat16_42);
    u_xlat16_62 = half(u_xlat16_4.x * u_xlat16_62 + u_xlat16_42);
    u_xlat16_57 = half(abs(u_xlat16_57) * u_xlat16_62);
    u_xlat16_57 = half(u_xlat16_4.x * u_xlat16_65 + u_xlat16_57);
    u_xlat16_55 = half(float(u_xlat16_57) + 9.99999975e-06);
    u_xlat16_55 = half(0.5 / float(u_xlat16_55));
    u_xlat16_57 = half(u_xlat16_42 * u_xlat16_42);
    u_xlat16_62 = half(u_xlat16_22.x * u_xlat16_57 + (-u_xlat16_22.x));
    u_xlat16_13.x = half(float(u_xlat16_62) * float(u_xlat16_22.x) + 1.0);
    u_xlat16_31 = half(float(u_xlat16_57) * 0.318309873);
    u_xlat16_13.x = half(float(u_xlat16_13.x) * float(u_xlat16_13.x) + 1.00000001e-07);
    u_xlat16_13.x = half(u_xlat16_31 / u_xlat16_13.x);
    u_xlat16_57 = half(u_xlat16_55 * u_xlat16_13.x);
    u_xlat16_55 = half(float(u_xlat16_57) * 3.14159274);
    u_xlat16_55 = half(max(float(u_xlat16_55), 9.99999975e-05));
    u_xlat16_55 = sqrt(u_xlat16_55);
    u_xlat16_57 = half(u_xlat16_4.x * u_xlat16_55);
    u_xlat16_4.x = half(u_xlat16_42 * u_xlat16_24.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_22.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb55 = u_xlat16_22.x!=0.0;
    u_xlat55 = u_xlatb55 ? 1.0 : float(0.0);
    u_xlat16_57 = half(u_xlat55 * float(u_xlat16_57));
    u_xlat16_56 = half((-u_xlat16_56) + Globals._Glossiness);
    u_xlat16_56 = half(float(u_xlat16_56) + 1.0);
    u_xlat16_56 = clamp(u_xlat16_56, 0.0h, 1.0h);
    u_xlat16_12.xyz = half3(half3(u_xlat16_58) * u_xlat16_8.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_1.xyz * u_xlat16_6.xxx + u_xlat16_12.xyz);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_57));
    u_xlat16_57 = half((-float(u_xlat16_40)) + 1.0);
    u_xlat16_22.x = half(u_xlat16_57 * u_xlat16_57);
    u_xlat16_22.x = half(u_xlat16_22.x * u_xlat16_22.x);
    u_xlat16_57 = half(u_xlat16_57 * u_xlat16_22.x);
    u_xlat16_22.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_22.xyz = half3(u_xlat16_22.xyz * half3(u_xlat16_57) + u_xlat16_2.xyz);
    u_xlat16_22.xyz = half3(u_xlat16_22.xyz * u_xlat16_8.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_6.xyz + u_xlat16_22.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_11.xyz * u_xlat16_4.xxx);
    u_xlat16_6.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_56));
    u_xlat16_2.xyz = half3(half3(u_xlat16_60) * u_xlat16_6.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_1.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set 2D Texture "_EmissionMap" to slot 3
Set CUBE Texture "unity_SpecCube0" to slot 4
Set CUBE Texture "unity_SpecCube1" to slot 5
Set 3D Texture "unity_ProbeVolumeSH" to slot 6

Constant Buffer "Globals" (416 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 80
  Matrix4x4 unity_ProbeVolumeWorldToObject at 288
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  VectorHalf4 unity_SHAr at 24
  VectorHalf4 unity_SHAg at 32
  VectorHalf4 unity_SHAb at 40
  VectorHalf4 unity_OcclusionMaskSelector at 48
  VectorHalf4 _LightShadowData at 56
  Vector4 unity_ShadowFadeCenterAndType at 64
  Vector4 unity_SpecCube0_BoxMax at 144
  Vector4 unity_SpecCube0_BoxMin at 160
  Vector4 unity_SpecCube0_ProbePosition at 176
  VectorHalf4 unity_SpecCube0_HDR at 192
  Vector4 unity_SpecCube1_BoxMax at 208
  Vector4 unity_SpecCube1_BoxMin at 224
  Vector4 unity_SpecCube1_ProbePosition at 240
  VectorHalf4 unity_SpecCube1_HDR at 256
  Vector4 unity_ProbeVolumeParams at 272
  Vector3 unity_ProbeVolumeSizeInv at 352
  Vector3 unity_ProbeVolumeMin at 368
  VectorHalf4 _LightColor0 at 384
  VectorHalf4 _Color at 392
  ScalarHalf _Metallic at 400
  ScalarHalf _Glossiness at 402
  ScalarHalf _OcclusionStrength at 404
  VectorHalf4 _EmissionColor at 408
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (3) ]] ,
    sampler sampler_EmissionMap [[ sampler (3) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (4) ]] ,
    texturecube<half, access::sample > unity_SpecCube1 [[ texture (5) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (5) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (6) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (6) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    half4 u_xlat16_7;
    half3 u_xlat16_8;
    float4 u_xlat9;
    half4 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    half3 u_xlat16_11;
    float3 u_xlat12;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    bool3 u_xlatb14;
    half3 u_xlat16_15;
    float3 u_xlat17;
    bool u_xlatb17;
    half3 u_xlat16_20;
    float3 u_xlat23;
    half3 u_xlat16_23;
    float u_xlat25;
    half u_xlat16_27;
    float2 u_xlat33;
    half u_xlat16_33;
    bool u_xlatb33;
    half u_xlat16_36;
    half u_xlat16_39;
    float u_xlat49;
    half u_xlat16_49;
    bool u_xlatb49;
    half u_xlat16_50;
    half u_xlat16_51;
    half u_xlat16_52;
    half u_xlat16_53;
    half u_xlat16_55;
    half u_xlat16_56;
    half u_xlat16_58;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_50 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_50));
    u_xlat16_51 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_0.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD4.xyz);
    u_xlat16_51 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_4.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD1.xyz);
    u_xlat16_5.x = input.TEXCOORD2.w;
    u_xlat16_5.y = input.TEXCOORD3.w;
    u_xlat16_5.z = input.TEXCOORD4.w;
    u_xlat1.xyz = (-float3(u_xlat16_5.xyz)) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat17.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat17.x = dot(u_xlat17.xyz, u_xlat17.xyz);
    u_xlat17.x = sqrt(u_xlat17.x);
    u_xlat17.x = (-u_xlat1.x) + u_xlat17.x;
    u_xlat1.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat17.x + u_xlat1.x;
    u_xlat1.x = u_xlat1.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat1.x = clamp(u_xlat1.x, 0.0f, 1.0f);
    u_xlatb17 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb17){
        u_xlatb33 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb33)) ? u_xlat6.xyz : float3(u_xlat16_5.xyz);
        u_xlat6.xyz = u_xlat6.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat6.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat33.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat49 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat49, u_xlat33.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_52 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_52 = clamp(u_xlat16_52, 0.0h, 1.0h);
    u_xlat33.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_33 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat33.xy).x;
    u_xlat16_53 = half(u_xlat1.x + float(u_xlat16_33));
    u_xlat16_53 = clamp(u_xlat16_53, 0.0h, 1.0h);
    u_xlat16_52 = min(u_xlat16_52, u_xlat16_53);
    u_xlat16_52 = (u_xlatb17) ? u_xlat16_52 : u_xlat16_53;
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_53 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_53 = half(u_xlat16_1.x * Globals._OcclusionStrength + u_xlat16_53);
    u_xlat16_7.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_23.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_23.x = half(u_xlat16_23.x + u_xlat16_23.x);
    u_xlat16_23.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_23.xxx) + u_xlat16_4.xyz);
    u_xlat16_8.xyz = half3(half3(u_xlat16_52) * Globals._LightColor0.xyz);
    if(u_xlatb17){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat17.xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat17.xyz : float3(u_xlat16_5.xyz);
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat17.x = u_xlat1.y * 0.25;
        u_xlat9.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat25 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat9.x);
        u_xlat1.x = min(u_xlat25, u_xlat17.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat9.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat9 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz);
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = half(dot(u_xlat6, float4(u_xlat16_0)));
        u_xlat16_10.y = half(dot(u_xlat9, float4(u_xlat16_0)));
        u_xlat16_10.z = half(dot(u_xlat1, float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_10.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_10.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_10.xyz = half3(u_xlat16_10.xyz + input.TEXCOORD5.xyz);
    u_xlat16_10.xyz = half3(max(float3(u_xlat16_10.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_10.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb49 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb49){
        u_xlat16_52 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
        u_xlat16_52 = rsqrt(u_xlat16_52);
        u_xlat16_10.xyz = half3(half3(u_xlat16_52) * u_xlat16_23.xyz);
        u_xlat9.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_10.xyz);
        u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_10.xyz);
        u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_10.xyz));
        u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat9.x) : half(u_xlat11.x);
        u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat9.y) : half(u_xlat11.y);
        u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat9.z) : half(u_xlat11.z);
        u_xlat16_52 = min(u_xlat16_13.y, u_xlat16_13.x);
        u_xlat16_52 = min(u_xlat16_13.z, u_xlat16_52);
        u_xlat9.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = float3(u_xlat16_10.xyz) * float3(u_xlat16_52) + u_xlat9.xyz;
        u_xlat16_9.xyz = half3(u_xlat9.xyz);
    } else {
        u_xlat16_9.xyz = u_xlat16_23.xyz;
    }
    u_xlat16_52 = half((-float(u_xlat16_7.x)) * 0.699999988 + 1.70000005);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_7.x);
    u_xlat16_52 = half(float(u_xlat16_52) * 6.0);
    u_xlat16_6 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_9.xyz), level(float(u_xlat16_52)));
    u_xlat16_56 = half(float(u_xlat16_6.w) + -1.0);
    u_xlat16_56 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_56) + 1.0);
    u_xlat16_56 = half(u_xlat16_56 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_10.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_56));
    u_xlatb49 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat16_58 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
            u_xlat16_58 = rsqrt(u_xlat16_58);
            u_xlat16_13.xyz = half3(u_xlat16_23.xyz * half3(u_xlat16_58));
            u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_13.xyz);
            u_xlat12.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat12.xyz = u_xlat12.xyz / float3(u_xlat16_13.xyz);
            u_xlatb14.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_13.xyz));
            u_xlat16_15.x = (u_xlatb14.x) ? half(u_xlat11.x) : half(u_xlat12.x);
            u_xlat16_15.y = (u_xlatb14.y) ? half(u_xlat11.y) : half(u_xlat12.y);
            u_xlat16_15.z = (u_xlatb14.z) ? half(u_xlat11.z) : half(u_xlat12.z);
            u_xlat16_58 = min(u_xlat16_15.y, u_xlat16_15.x);
            u_xlat16_58 = min(u_xlat16_15.z, u_xlat16_58);
            u_xlat11.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat23.xyz = float3(u_xlat16_13.xyz) * float3(u_xlat16_58) + u_xlat11.xyz;
            u_xlat16_23.xyz = half3(u_xlat23.xyz);
        }
        u_xlat16_9 = unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_23.xyz), level(float(u_xlat16_52)));
        u_xlat16_52 = half(float(u_xlat16_9.w) + -1.0);
        u_xlat16_52 = half(float(Globals.unity_SpecCube1_HDR.w) * float(u_xlat16_52) + 1.0);
        u_xlat16_52 = half(u_xlat16_52 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_5.xyz = half3(u_xlat16_9.xyz * half3(u_xlat16_52));
        u_xlat16_11.xyz = half3(half3(u_xlat16_56) * u_xlat16_6.xyz + (-u_xlat16_5.xyz));
        u_xlat10.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_11.xyz) + float3(u_xlat16_5.xyz);
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    }
    u_xlat16_5.xyz = half3(half3(u_xlat16_53) * u_xlat16_10.xyz);
    u_xlat16_23.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_51) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_51 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
    u_xlat16_49 = half(max(float(u_xlat16_51), 0.00100000005));
    u_xlat16_51 = rsqrt(u_xlat16_49);
    u_xlat16_23.xyz = half3(half3(u_xlat16_51) * u_xlat16_23.xyz);
    u_xlat16_51 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_20.x = dot(u_xlat16_0.xyz, u_xlat16_23.xyz);
    u_xlat16_20.x = clamp(u_xlat16_20.x, 0.0h, 1.0h);
    u_xlat16_36 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_23.xyz);
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_52 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_52 = dot(half2(u_xlat16_52), u_xlat16_7.xx);
    u_xlat16_52 = half(float(u_xlat16_52) + -0.5);
    u_xlat16_23.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_39 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_39);
    u_xlat16_23.x = half(float(u_xlat16_52) * float(u_xlat16_23.x) + 1.0);
    u_xlat16_39 = half(-abs(float(u_xlat16_51)) + 1.0);
    u_xlat16_55 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_55 = half(u_xlat16_55 * u_xlat16_55);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_55);
    u_xlat16_52 = half(float(u_xlat16_52) * float(u_xlat16_39) + 1.0);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_23.x);
    u_xlat16_52 = half(u_xlat16_4.x * u_xlat16_52);
    u_xlat16_23.x = half(u_xlat16_7.x * u_xlat16_7.x);
    u_xlat16_55 = half((-float(u_xlat16_7.x)) * float(u_xlat16_7.x) + 1.0);
    u_xlat16_56 = half(abs(u_xlat16_51) * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_4.x * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_51 = half(abs(u_xlat16_51) * u_xlat16_55);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_56 + u_xlat16_51);
    u_xlat16_49 = half(float(u_xlat16_51) + 9.99999975e-06);
    u_xlat16_49 = half(0.5 / float(u_xlat16_49));
    u_xlat16_51 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_20.x * u_xlat16_51 + (-u_xlat16_20.x));
    u_xlat16_11.x = half(float(u_xlat16_55) * float(u_xlat16_20.x) + 1.0);
    u_xlat16_27 = half(float(u_xlat16_51) * 0.318309873);
    u_xlat16_11.x = half(float(u_xlat16_11.x) * float(u_xlat16_11.x) + 1.00000001e-07);
    u_xlat16_11.x = half(u_xlat16_27 / u_xlat16_11.x);
    u_xlat16_51 = half(u_xlat16_49 * u_xlat16_11.x);
    u_xlat16_49 = half(float(u_xlat16_51) * 3.14159274);
    u_xlat16_49 = half(max(float(u_xlat16_49), 9.99999975e-05));
    u_xlat16_49 = sqrt(u_xlat16_49);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_49);
    u_xlat16_4.x = half(u_xlat16_23.x * u_xlat16_7.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_20.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb49 = u_xlat16_20.x!=0.0;
    u_xlat49 = u_xlatb49 ? 1.0 : float(0.0);
    u_xlat16_51 = half(u_xlat49 * float(u_xlat16_51));
    u_xlat16_50 = half((-u_xlat16_50) + Globals._Glossiness);
    u_xlat16_50 = half(float(u_xlat16_50) + 1.0);
    u_xlat16_50 = clamp(u_xlat16_50, 0.0h, 1.0h);
    u_xlat16_7.xyw = half3(half3(u_xlat16_52) * u_xlat16_8.xyz);
    u_xlat16_7.xyw = half3(u_xlat16_1.xyz * half3(u_xlat16_53) + u_xlat16_7.xyw);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_51));
    u_xlat16_51 = half((-float(u_xlat16_36)) + 1.0);
    u_xlat16_20.x = half(u_xlat16_51 * u_xlat16_51);
    u_xlat16_20.x = half(u_xlat16_20.x * u_xlat16_20.x);
    u_xlat16_51 = half(u_xlat16_51 * u_xlat16_20.x);
    u_xlat16_20.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * half3(u_xlat16_51) + u_xlat16_2.xyz);
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * u_xlat16_8.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_7.xyw + u_xlat16_20.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_5.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_50));
    u_xlat16_2.xyz = half3(half3(u_xlat16_39) * u_xlat16_5.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_1.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (402 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 176
  Matrix4x4 unity_WorldToObject at 240
  Matrix4x4 unity_MatrixVP at 304
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHBr at 136
  VectorHalf4 unity_SHBg at 144
  VectorHalf4 unity_SHBb at 152
  VectorHalf4 unity_SHC at 160
  Vector4 _MainTex_ST at 368
  Vector4 _DetailAlbedoMap_ST at 384
  ScalarHalf _UVSec at 400
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    u_xlat1.w = u_xlat0.z;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat2 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat3 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat0 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat3 = u_xlat2 * u_xlat2 + u_xlat3;
    u_xlat2 = u_xlat2 * u_xlat1.xxxx + u_xlat4;
    u_xlat2 = u_xlat0 * u_xlat1.zzzz + u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = rsqrt(u_xlat0);
    u_xlat0 = u_xlat0 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat2 = u_xlat2 * u_xlat3;
    u_xlat2 = max(u_xlat2, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat2;
    u_xlat2.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat2.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_5.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_5.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_5.x)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_6.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_6.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_6.z = dot(Globals.unity_SHBb, u_xlat16_1);
    u_xlat16_5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_5.xxx + u_xlat16_6.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz * u_xlat2.xyz + float3(u_xlat16_5.xyz));
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
float u_xlat15;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = inversesqrt(u_xlat15);
    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat2 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat3 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat0 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat3 = u_xlat2 * u_xlat2 + u_xlat3;
    u_xlat2 = u_xlat2 * u_xlat1.xxxx + u_xlat4;
    u_xlat2 = u_xlat0 * u_xlat1.zzzz + u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat0);
    u_xlat0 = u_xlat0 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat2 = u_xlat2 * u_xlat3;
    u_xlat2 = max(u_xlat2, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat2;
    u_xlat2.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat2.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat15 = u_xlat1.y * u_xlat1.y;
    u_xlat15 = u_xlat1.x * u_xlat1.x + (-u_xlat15);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat1);
    u_xlat3.y = dot(unity_SHBg, u_xlat1);
    u_xlat3.z = dot(unity_SHBb, u_xlat1);
    u_xlat1.xyz = unity_SHC.xyz * vec3(u_xlat15) + u_xlat3.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
bool u_xlatb4;
vec3 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
vec4 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat19;
vec3 u_xlat20;
vec3 u_xlat23;
float u_xlat32;
float u_xlat33;
float u_xlat34;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlatb48 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb48){
        u_xlatb4 = unity_ProbeVolumeParams.y==1.0;
        u_xlat19.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat19.xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat19.xyz;
        u_xlat19.xyz = u_xlat19.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat20.x = vs_TEXCOORD2.w;
        u_xlat20.y = vs_TEXCOORD3.w;
        u_xlat20.z = vs_TEXCOORD4.w;
        u_xlat4.xyz = (bool(u_xlatb4)) ? u_xlat19.xyz : u_xlat20.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19.x = u_xlat4.y * 0.25 + 0.75;
        u_xlat5.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19.x, u_xlat5.x);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat4.x = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat4.x = clamp(u_xlat4.x, 0.0, 1.0);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat19.x = (-_OcclusionStrength) + 1.0;
    u_xlat19.x = u_xlat10_5.y * _OcclusionStrength + u_xlat19.x;
    u_xlat34 = (-_Glossiness) + 1.0;
    u_xlat49 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat49 = u_xlat49 + u_xlat49;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat49)) + u_xlat3.xyz;
    u_xlat6.xyz = u_xlat4.xxx * _LightColor0.xyz;
    if(u_xlatb48){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat23.x = vs_TEXCOORD2.w;
        u_xlat23.y = vs_TEXCOORD3.w;
        u_xlat23.z = vs_TEXCOORD4.w;
        u_xlat7.xyz = (bool(u_xlatb48)) ? u_xlat7.xyz : u_xlat23.xyz;
        u_xlat7.xyz = u_xlat7.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat7.yzw = u_xlat7.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat7.y * 0.25;
        u_xlat4.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat49 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat4.x);
        u_xlat7.x = min(u_xlat49, u_xlat48);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat7.xzw);
        u_xlat9.xyz = u_xlat7.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat7.xyz = u_xlat7.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(u_xlat10_8, u_xlat2);
        u_xlat8.y = dot(u_xlat10_9, u_xlat2);
        u_xlat8.z = dot(u_xlat10_7, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(unity_SHAr, u_xlat2);
        u_xlat8.y = dot(unity_SHAg, u_xlat2);
        u_xlat8.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat7.xyz = u_xlat8.xyz + vs_TEXCOORD5.xyz;
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat7.xyz = log2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat7.xyz = exp2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat47) * u_xlat5.xyz;
        u_xlat9.x = vs_TEXCOORD2.w;
        u_xlat9.y = vs_TEXCOORD3.w;
        u_xlat9.z = vs_TEXCOORD4.w;
        u_xlat10.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
        u_xlat11.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat8.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat9.xyz = u_xlat9.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat8.xyz = u_xlat8.xyz * vec3(u_xlat47) + u_xlat9.xyz;
    } else {
        u_xlat8.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat34) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat34;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_8 = textureLod(unity_SpecCube0, u_xlat8.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_8.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat9.xyz = u_xlat10_8.xyz * vec3(u_xlat48);
    u_xlatb4 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb4){
        u_xlatb4 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb4){
            u_xlat4.x = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat4.x = inversesqrt(u_xlat4.x);
            u_xlat10.xyz = u_xlat4.xxx * u_xlat5.xyz;
            u_xlat11.x = vs_TEXCOORD2.w;
            u_xlat11.y = vs_TEXCOORD3.w;
            u_xlat11.z = vs_TEXCOORD4.w;
            u_xlat12.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat10.xyz;
            u_xlat13.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat10.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat10.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat4.x = min(u_xlat12.y, u_xlat12.x);
            u_xlat4.x = min(u_xlat12.z, u_xlat4.x);
            u_xlat11.xyz = u_xlat11.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat10.xyz * u_xlat4.xxx + u_xlat11.xyz;
        //ENDIF
        }
        u_xlat10_5 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_5.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat48) * u_xlat10_8.xyz + (-u_xlat5.xyz);
        u_xlat9.xyz = unity_SpecCube0_BoxMin.www * u_xlat8.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = u_xlat19.xxx * u_xlat9.xyz;
    u_xlat8.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat8.xyz = vec3(u_xlat46) * u_xlat8.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat8.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat8.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), vec2(u_xlat34));
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat34 * u_xlat34;
    u_xlat33 = (-u_xlat34) * u_xlat34 + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat34;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat6.xyz;
    u_xlat3.xzw = u_xlat7.xyz * u_xlat19.xxx + u_xlat3.xzw;
    u_xlat4.xyz = u_xlat6.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 192
  Matrix4x4 unity_WorldToObject at 256
  Matrix4x4 unity_MatrixVP at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHBr at 152
  VectorHalf4 unity_SHBg at 160
  VectorHalf4 unity_SHBb at 168
  VectorHalf4 unity_SHC at 176
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    u_xlat2.w = u_xlat1.z;
    u_xlat3.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat3.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat3.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat3.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat3 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat1);
    u_xlat1 = u_xlat1 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_2 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz * u_xlat3.xyz + float3(u_xlat16_6.xyz));
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat3 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat1);
    u_xlat1 = u_xlat1 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat3.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat19 = u_xlat2.y * u_xlat2.y;
    u_xlat19 = u_xlat2.x * u_xlat2.x + (-u_xlat19);
    u_xlat2 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat2);
    u_xlat4.y = dot(unity_SHBg, u_xlat2);
    u_xlat4.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat19) + u_xlat4.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz * u_xlat3.xyz + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat0.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
bool u_xlatb4;
vec3 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
vec4 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat19;
vec3 u_xlat20;
vec3 u_xlat23;
float u_xlat32;
float u_xlat33;
float u_xlat34;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlatb48 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb48){
        u_xlatb4 = unity_ProbeVolumeParams.y==1.0;
        u_xlat19.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat19.xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat19.xyz;
        u_xlat19.xyz = u_xlat19.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat20.x = vs_TEXCOORD2.w;
        u_xlat20.y = vs_TEXCOORD3.w;
        u_xlat20.z = vs_TEXCOORD4.w;
        u_xlat4.xyz = (bool(u_xlatb4)) ? u_xlat19.xyz : u_xlat20.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19.x = u_xlat4.y * 0.25 + 0.75;
        u_xlat5.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19.x, u_xlat5.x);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat4.x = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat4.x = clamp(u_xlat4.x, 0.0, 1.0);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat19.x = (-_OcclusionStrength) + 1.0;
    u_xlat19.x = u_xlat10_5.y * _OcclusionStrength + u_xlat19.x;
    u_xlat34 = (-_Glossiness) + 1.0;
    u_xlat49 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat49 = u_xlat49 + u_xlat49;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat49)) + u_xlat3.xyz;
    u_xlat6.xyz = u_xlat4.xxx * _LightColor0.xyz;
    if(u_xlatb48){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat23.x = vs_TEXCOORD2.w;
        u_xlat23.y = vs_TEXCOORD3.w;
        u_xlat23.z = vs_TEXCOORD4.w;
        u_xlat7.xyz = (bool(u_xlatb48)) ? u_xlat7.xyz : u_xlat23.xyz;
        u_xlat7.xyz = u_xlat7.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat7.yzw = u_xlat7.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat7.y * 0.25;
        u_xlat4.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat49 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat4.x);
        u_xlat7.x = min(u_xlat49, u_xlat48);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat7.xzw);
        u_xlat9.xyz = u_xlat7.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat7.xyz = u_xlat7.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(u_xlat10_8, u_xlat2);
        u_xlat8.y = dot(u_xlat10_9, u_xlat2);
        u_xlat8.z = dot(u_xlat10_7, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(unity_SHAr, u_xlat2);
        u_xlat8.y = dot(unity_SHAg, u_xlat2);
        u_xlat8.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat7.xyz = u_xlat8.xyz + vs_TEXCOORD5.xyz;
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat7.xyz = log2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat7.xyz = exp2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat47) * u_xlat5.xyz;
        u_xlat9.x = vs_TEXCOORD2.w;
        u_xlat9.y = vs_TEXCOORD3.w;
        u_xlat9.z = vs_TEXCOORD4.w;
        u_xlat10.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
        u_xlat11.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat8.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat9.xyz = u_xlat9.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat8.xyz = u_xlat8.xyz * vec3(u_xlat47) + u_xlat9.xyz;
    } else {
        u_xlat8.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat34) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat34;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_8 = textureLod(unity_SpecCube0, u_xlat8.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_8.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat9.xyz = u_xlat10_8.xyz * vec3(u_xlat48);
    u_xlatb4 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb4){
        u_xlatb4 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb4){
            u_xlat4.x = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat4.x = inversesqrt(u_xlat4.x);
            u_xlat10.xyz = u_xlat4.xxx * u_xlat5.xyz;
            u_xlat11.x = vs_TEXCOORD2.w;
            u_xlat11.y = vs_TEXCOORD3.w;
            u_xlat11.z = vs_TEXCOORD4.w;
            u_xlat12.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat10.xyz;
            u_xlat13.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat10.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat10.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat4.x = min(u_xlat12.y, u_xlat12.x);
            u_xlat4.x = min(u_xlat12.z, u_xlat4.x);
            u_xlat11.xyz = u_xlat11.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat10.xyz * u_xlat4.xxx + u_xlat11.xyz;
        //ENDIF
        }
        u_xlat10_5 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_5.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat48) * u_xlat10_8.xyz + (-u_xlat5.xyz);
        u_xlat9.xyz = unity_SpecCube0_BoxMin.www * u_xlat8.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = u_xlat19.xxx * u_xlat9.xyz;
    u_xlat8.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat8.xyz = vec3(u_xlat46) * u_xlat8.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat8.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat8.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), vec2(u_xlat34));
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat34 * u_xlat34;
    u_xlat33 = (-u_xlat34) * u_xlat34 + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat34;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat6.xyz;
    u_xlat3.xzw = u_xlat7.xyz * u_xlat19.xxx + u_xlat3.xzw;
    u_xlat4.xyz = u_xlat6.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 64
  Matrix4x4 unity_WorldToObject at 128
  Matrix4x4 unity_MatrixVP at 192
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHBr at 32
  VectorHalf4 unity_SHBg at 40
  VectorHalf4 unity_SHBb at 48
  VectorHalf4 unity_SHC at 56
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    float4 u_xlat2;
    half u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat17;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat17 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat17 = rsqrt(u_xlat17);
    u_xlat1.xyz = float3(u_xlat17) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat16_3 = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3 = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_1);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_3) + u_xlat16_4.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat2.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat2.zz + u_xlat2.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    u_xlat1.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = u_xlat1.x * u_xlat1.x + (-u_xlat10);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(unity_SHBr, u_xlat2);
    u_xlat1.y = dot(unity_SHBg, u_xlat2);
    u_xlat1.z = dot(unity_SHBb, u_xlat2);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat10) + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (402 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 176
  Matrix4x4 unity_WorldToObject at 240
  Matrix4x4 unity_MatrixVP at 304
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHBr at 136
  VectorHalf4 unity_SHBg at 144
  VectorHalf4 unity_SHBb at 152
  VectorHalf4 unity_SHC at 160
  Vector4 _MainTex_ST at 368
  Vector4 _DetailAlbedoMap_ST at 384
  ScalarHalf _UVSec at 400
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    u_xlat1.w = u_xlat0.z;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat2 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat3 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat0 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat3 = u_xlat2 * u_xlat2 + u_xlat3;
    u_xlat2 = u_xlat2 * u_xlat1.xxxx + u_xlat4;
    u_xlat2 = u_xlat0 * u_xlat1.zzzz + u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = rsqrt(u_xlat0);
    u_xlat0 = u_xlat0 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat2 = u_xlat2 * u_xlat3;
    u_xlat2 = max(u_xlat2, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat2;
    u_xlat2.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat2.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_5.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_5.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_5.x)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_6.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_6.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_6.z = dot(Globals.unity_SHBb, u_xlat16_1);
    u_xlat16_5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_5.xxx + u_xlat16_6.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz * u_xlat2.xyz + float3(u_xlat16_5.xyz));
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
float u_xlat15;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = inversesqrt(u_xlat15);
    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat2 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat3 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat0 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat3 = u_xlat2 * u_xlat2 + u_xlat3;
    u_xlat2 = u_xlat2 * u_xlat1.xxxx + u_xlat4;
    u_xlat2 = u_xlat0 * u_xlat1.zzzz + u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat0);
    u_xlat0 = u_xlat0 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat2 = u_xlat2 * u_xlat3;
    u_xlat2 = max(u_xlat2, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat2;
    u_xlat2.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat2.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat15 = u_xlat1.y * u_xlat1.y;
    u_xlat15 = u_xlat1.x * u_xlat1.x + (-u_xlat15);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat1);
    u_xlat3.y = dot(unity_SHBg, u_xlat1);
    u_xlat3.z = dot(unity_SHBb, u_xlat1);
    u_xlat1.xyz = unity_SHC.xyz * vec3(u_xlat15) + u_xlat3.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
bool u_xlatb4;
vec3 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
vec4 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat19;
vec3 u_xlat20;
vec3 u_xlat23;
float u_xlat32;
float u_xlat33;
float u_xlat34;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlatb48 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb48){
        u_xlatb4 = unity_ProbeVolumeParams.y==1.0;
        u_xlat19.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat19.xyz;
        u_xlat19.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat19.xyz;
        u_xlat19.xyz = u_xlat19.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat20.x = vs_TEXCOORD2.w;
        u_xlat20.y = vs_TEXCOORD3.w;
        u_xlat20.z = vs_TEXCOORD4.w;
        u_xlat4.xyz = (bool(u_xlatb4)) ? u_xlat19.xyz : u_xlat20.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19.x = u_xlat4.y * 0.25 + 0.75;
        u_xlat5.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19.x, u_xlat5.x);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat4.x = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat4.x = clamp(u_xlat4.x, 0.0, 1.0);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat19.x = (-_OcclusionStrength) + 1.0;
    u_xlat19.x = u_xlat10_5.y * _OcclusionStrength + u_xlat19.x;
    u_xlat34 = (-_Glossiness) + 1.0;
    u_xlat49 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat49 = u_xlat49 + u_xlat49;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat49)) + u_xlat3.xyz;
    u_xlat6.xyz = u_xlat4.xxx * _LightColor0.xyz;
    if(u_xlatb48){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat23.x = vs_TEXCOORD2.w;
        u_xlat23.y = vs_TEXCOORD3.w;
        u_xlat23.z = vs_TEXCOORD4.w;
        u_xlat7.xyz = (bool(u_xlatb48)) ? u_xlat7.xyz : u_xlat23.xyz;
        u_xlat7.xyz = u_xlat7.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat7.yzw = u_xlat7.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat7.y * 0.25;
        u_xlat4.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat49 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat4.x);
        u_xlat7.x = min(u_xlat49, u_xlat48);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat7.xzw);
        u_xlat9.xyz = u_xlat7.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat7.xyz = u_xlat7.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(u_xlat10_8, u_xlat2);
        u_xlat8.y = dot(u_xlat10_9, u_xlat2);
        u_xlat8.z = dot(u_xlat10_7, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat8.x = dot(unity_SHAr, u_xlat2);
        u_xlat8.y = dot(unity_SHAg, u_xlat2);
        u_xlat8.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat7.xyz = u_xlat8.xyz + vs_TEXCOORD5.xyz;
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat7.xyz = log2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat7.xyz = exp2(u_xlat7.xyz);
    u_xlat7.xyz = u_xlat7.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat7.xyz = max(u_xlat7.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat47) * u_xlat5.xyz;
        u_xlat9.x = vs_TEXCOORD2.w;
        u_xlat9.y = vs_TEXCOORD3.w;
        u_xlat9.z = vs_TEXCOORD4.w;
        u_xlat10.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
        u_xlat11.xyz = (-u_xlat9.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat8.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat9.xyz = u_xlat9.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat8.xyz = u_xlat8.xyz * vec3(u_xlat47) + u_xlat9.xyz;
    } else {
        u_xlat8.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat34) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat34;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_8 = textureLod(unity_SpecCube0, u_xlat8.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_8.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat9.xyz = u_xlat10_8.xyz * vec3(u_xlat48);
    u_xlatb4 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb4){
        u_xlatb4 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb4){
            u_xlat4.x = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat4.x = inversesqrt(u_xlat4.x);
            u_xlat10.xyz = u_xlat4.xxx * u_xlat5.xyz;
            u_xlat11.x = vs_TEXCOORD2.w;
            u_xlat11.y = vs_TEXCOORD3.w;
            u_xlat11.z = vs_TEXCOORD4.w;
            u_xlat12.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat10.xyz;
            u_xlat13.xyz = (-u_xlat11.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat10.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat10.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat4.x = min(u_xlat12.y, u_xlat12.x);
            u_xlat4.x = min(u_xlat12.z, u_xlat4.x);
            u_xlat11.xyz = u_xlat11.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat10.xyz * u_xlat4.xxx + u_xlat11.xyz;
        //ENDIF
        }
        u_xlat10_5 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_5.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat47);
        u_xlat8.xyz = vec3(u_xlat48) * u_xlat10_8.xyz + (-u_xlat5.xyz);
        u_xlat9.xyz = unity_SpecCube0_BoxMin.www * u_xlat8.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = u_xlat19.xxx * u_xlat9.xyz;
    u_xlat8.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat8.xyz = vec3(u_xlat46) * u_xlat8.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat8.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat8.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), vec2(u_xlat34));
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat34 * u_xlat34;
    u_xlat33 = (-u_xlat34) * u_xlat34 + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat34;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat6.xyz;
    u_xlat3.xzw = u_xlat7.xyz * u_xlat19.xxx + u_xlat3.xzw;
    u_xlat4.xyz = u_xlat6.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 192
  Matrix4x4 unity_WorldToObject at 256
  Matrix4x4 unity_MatrixVP at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHBr at 152
  VectorHalf4 unity_SHBg at 160
  VectorHalf4 unity_SHBb at 168
  VectorHalf4 unity_SHC at 176
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    u_xlat2.w = u_xlat1.z;
    u_xlat3.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat3.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat3.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat3.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat3 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat1);
    u_xlat1 = u_xlat1 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_2 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz * u_xlat3.xyz + float3(u_xlat16_6.xyz));
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat3 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat1);
    u_xlat1 = u_xlat1 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat3.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat19 = u_xlat2.y * u_xlat2.y;
    u_xlat19 = u_xlat2.x * u_xlat2.x + (-u_xlat19);
    u_xlat2 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat2);
    u_xlat4.y = dot(unity_SHBg, u_xlat2);
    u_xlat4.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat19) + u_xlat4.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz * u_xlat3.xyz + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

 }
 Pass {
  Name "FORWARD_DELTA"
  Tags { "LIGHTMODE"="FORWARDADD" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite Off
  Blend [_SrcBlend] One
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: POINT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_9;
    float u_xlat10;
    half u_xlat16_13;
    half u_xlat16_14;
    half u_xlat16_18;
    half u_xlat16_22;
    half u_xlat16_23;
    float u_xlat27;
    bool u_xlatb27;
    half u_xlat16_29;
    half u_xlat16_30;
    half u_xlat16_31;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_29 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_29));
    u_xlat16_29 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_4.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD4.xyz);
    u_xlat16_29 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_5.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb27 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb27){
        u_xlatb27 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat1.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat1.xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat1.xyz;
        u_xlat1.xyz = u_xlat1.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb27)) ? u_xlat1.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat27 = u_xlat1.y * 0.25 + 0.75;
        u_xlat10 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat27, u_xlat10);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_29 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_29 = clamp(u_xlat16_29, 0.0h, 1.0h);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xx).w;
    u_xlat16_0.x = half(u_xlat16_29 * u_xlat16_0.x);
    u_xlat16_6.x = input.TEXCOORD2.w;
    u_xlat16_6.y = input.TEXCOORD3.w;
    u_xlat16_6.z = input.TEXCOORD4.w;
    u_xlat16_29 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_7.xyz = half3(half3(u_xlat16_29) * u_xlat16_6.xyz);
    u_xlat16_8.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_30 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + (-u_xlat16_5.xyz));
    u_xlat16_29 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_29), 0.00100000005));
    u_xlat16_29 = rsqrt(u_xlat16_0.x);
    u_xlat16_6.xyz = half3(half3(u_xlat16_29) * u_xlat16_6.xyz);
    u_xlat16_29 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_31 = dot(u_xlat16_4.xyz, u_xlat16_7.xyz);
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_6.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_13 = dot(u_xlat16_7.xyz, u_xlat16_6.xyz);
    u_xlat16_13 = clamp(u_xlat16_13, 0.0h, 1.0h);
    u_xlat16_22 = half(u_xlat16_13 * u_xlat16_13);
    u_xlat16_22 = dot(half2(u_xlat16_22), half2(u_xlat16_30));
    u_xlat16_22 = half(float(u_xlat16_22) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_31)) + 1.0);
    u_xlat16_14 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_14);
    u_xlat16_5.x = half(float(u_xlat16_22) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_14 = half(-abs(float(u_xlat16_29)) + 1.0);
    u_xlat16_23 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_23);
    u_xlat16_22 = half(float(u_xlat16_22) * float(u_xlat16_14) + 1.0);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_5.x);
    u_xlat16_22 = half(u_xlat16_31 * u_xlat16_22);
    u_xlat16_5.x = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_30 = half((-float(u_xlat16_30)) * float(u_xlat16_30) + 1.0);
    u_xlat16_14 = half(abs(u_xlat16_29) * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_31 * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_29 = half(abs(u_xlat16_29) * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_14 + u_xlat16_29);
    u_xlat16_0.x = half(float(u_xlat16_29) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_29 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_4.x * u_xlat16_29 + (-u_xlat16_4.x));
    u_xlat16_9 = half(float(u_xlat16_30) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_18 = half(float(u_xlat16_29) * 0.318309873);
    u_xlat16_9 = half(float(u_xlat16_9) * float(u_xlat16_9) + 1.00000001e-07);
    u_xlat16_9 = half(u_xlat16_18 / u_xlat16_9);
    u_xlat16_29 = half(u_xlat16_9 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_29) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_0.x);
    u_xlat16_30 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_30!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_29 = half(u_xlat0.x * float(u_xlat16_29));
    u_xlat16_4.xzw = half3(half3(u_xlat16_22) * u_xlat16_8.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_29));
    u_xlat16_29 = half((-float(u_xlat16_13)) + 1.0);
    u_xlat16_30 = half(u_xlat16_29 * u_xlat16_29);
    u_xlat16_30 = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_29 * u_xlat16_30);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
bool u_xlatb21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
    u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb21 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb21){
        u_xlatb21 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb21)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat21 = u_xlat5.y * 0.25 + 0.75;
        u_xlat22 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat21, u_xlat22);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat21 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_4 = texture(_LightTexture0, vec2(u_xlat22));
    u_xlat21 = u_xlat21 * u_xlat10_4.w;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat5.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat21) * _LightColor0.xyz;
    u_xlat21 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat22) + (-u_xlat3.xyz);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = max(u_xlat22, 0.00100000005);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat4.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat22 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat21));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat22) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat21 * u_xlat21;
    u_xlat21 = (-u_xlat21) * u_xlat21 + 1.0;
    u_xlat10 = abs(u_xlat22) * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat23 * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat21 * abs(u_xlat22);
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 3D Texture "unity_ProbeVolumeSH" to slot 1

Constant Buffer "Globals" (148 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (1) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (1) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    float3 u_xlat9;
    half u_xlat16_10;
    half u_xlat16_13;
    half u_xlat16_14;
    half u_xlat16_19;
    half u_xlat16_22;
    half u_xlat16_23;
    half u_xlat16_29;
    half u_xlat16_30;
    half u_xlat16_31;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_29 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_29));
    u_xlat16_29 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_4.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD4.xyz);
    u_xlat16_29 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_5.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD1.xyz);
    u_xlatb0 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb0){
        u_xlatb0 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat9.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat9.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat9.xyz;
        u_xlat9.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat9.xyz;
        u_xlat9.xyz = u_xlat9.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat0.xyz = (bool(u_xlatb0)) ? u_xlat9.xyz : input.TEXCOORD5.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat0.yzw = u_xlat0.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat9.x = u_xlat0.y * 0.25 + 0.75;
        u_xlat1 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat0.x = max(u_xlat9.x, u_xlat1);
        u_xlat0 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat0.xzw);
        u_xlat16_0 = half4(u_xlat0);
    } else {
        u_xlat16_0.x = half(1.0);
        u_xlat16_0.y = half(1.0);
        u_xlat16_0.z = half(1.0);
        u_xlat16_0.w = half(1.0);
    }
    u_xlat16_30 = dot(u_xlat16_0, Globals.unity_OcclusionMaskSelector);
    u_xlat16_30 = clamp(u_xlat16_30, 0.0h, 1.0h);
    u_xlat16_6.xyz = half3(half3(u_xlat16_30) * Globals._LightColor0.xyz);
    u_xlat16_30 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_8.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_29) + u_xlat16_7.xyz);
    u_xlat16_29 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_1.x = half(max(float(u_xlat16_29), 0.00100000005));
    u_xlat16_29 = rsqrt(u_xlat16_1.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_29) * u_xlat16_8.xyz);
    u_xlat16_29 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_31 = dot(u_xlat16_4.xyz, u_xlat16_7.xyz);
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_13 = dot(u_xlat16_7.xyz, u_xlat16_8.xyz);
    u_xlat16_13 = clamp(u_xlat16_13, 0.0h, 1.0h);
    u_xlat16_22 = half(u_xlat16_13 * u_xlat16_13);
    u_xlat16_22 = dot(half2(u_xlat16_22), half2(u_xlat16_30));
    u_xlat16_22 = half(float(u_xlat16_22) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_31)) + 1.0);
    u_xlat16_14 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_14);
    u_xlat16_5.x = half(float(u_xlat16_22) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_14 = half(-abs(float(u_xlat16_29)) + 1.0);
    u_xlat16_23 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_23);
    u_xlat16_22 = half(float(u_xlat16_22) * float(u_xlat16_14) + 1.0);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_5.x);
    u_xlat16_22 = half(u_xlat16_31 * u_xlat16_22);
    u_xlat16_5.x = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_30 = half((-float(u_xlat16_30)) * float(u_xlat16_30) + 1.0);
    u_xlat16_14 = half(abs(u_xlat16_29) * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_31 * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_29 = half(abs(u_xlat16_29) * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_14 + u_xlat16_29);
    u_xlat16_1.x = half(float(u_xlat16_29) + 9.99999975e-06);
    u_xlat16_1.x = half(0.5 / float(u_xlat16_1.x));
    u_xlat16_29 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_4.x * u_xlat16_29 + (-u_xlat16_4.x));
    u_xlat16_10 = half(float(u_xlat16_30) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_19 = half(float(u_xlat16_29) * 0.318309873);
    u_xlat16_10 = half(float(u_xlat16_10) * float(u_xlat16_10) + 1.00000001e-07);
    u_xlat16_10 = half(u_xlat16_19 / u_xlat16_10);
    u_xlat16_29 = half(u_xlat16_10 * u_xlat16_1.x);
    u_xlat16_1.x = half(float(u_xlat16_29) * 3.14159274);
    u_xlat16_1.x = half(max(float(u_xlat16_1.x), 9.99999975e-05));
    u_xlat16_1.x = sqrt(u_xlat16_1.x);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_1.x);
    u_xlat16_30 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb1 = u_xlat16_30!=0.0;
    u_xlat1 = u_xlatb1 ? 1.0 : float(0.0);
    u_xlat16_29 = half(u_xlat1 * float(u_xlat16_29));
    u_xlat16_4.xzw = half3(half3(u_xlat16_22) * u_xlat16_6.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29));
    u_xlat16_29 = half((-float(u_xlat16_13)) + 1.0);
    u_xlat16_30 = half(u_xlat16_29 * u_xlat16_29);
    u_xlat16_30 = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_29 * u_xlat16_30);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec4 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlatb22 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb22){
        u_xlatb22 = unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb22)) ? u_xlat4.xyz : vs_TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat22 = u_xlat4.y * 0.25 + 0.75;
        u_xlat23 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat22, u_xlat23);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat22 = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat4.xyz = vec3(u_xlat22) * _LightColor0.xyz;
    u_xlat22 = (-_Glossiness) + 1.0;
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat21) + u_xlat5.xyz;
    u_xlat21 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat21 = max(u_xlat21, 0.00100000005);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat6.xyz = vec3(u_xlat21) * u_xlat6.xyz;
    u_xlat21 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat22));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat21) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat22 * u_xlat22;
    u_xlat22 = (-u_xlat22) * u_xlat22 + 1.0;
    u_xlat10 = abs(u_xlat21) * u_xlat22 + u_xlat3.x;
    u_xlat22 = u_xlat23 * u_xlat22 + u_xlat3.x;
    u_xlat21 = abs(u_xlat21) * u_xlat22;
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat4.xyz;
    u_xlat3.xyz = u_xlat4.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float2 u_xlat6;
    bool u_xlatb6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half u_xlat16_10;
    float3 u_xlat11;
    half u_xlat16_14;
    half u_xlat16_15;
    half u_xlat16_20;
    half u_xlat16_24;
    half u_xlat16_25;
    half u_xlat16_30;
    half u_xlat16_32;
    half u_xlat16_33;
    half u_xlat16_34;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_32 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_32));
    u_xlat16_32 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_32 = rsqrt(u_xlat16_32);
    u_xlat16_4.xyz = half3(half3(u_xlat16_32) * input.TEXCOORD4.xyz);
    u_xlat16_32 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_32 = rsqrt(u_xlat16_32);
    u_xlat16_5.xyz = half3(half3(u_xlat16_32) * input.TEXCOORD1.xyz);
    u_xlat0 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * input.TEXCOORD5.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * input.TEXCOORD5.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat11.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat11.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat11.xyz;
        u_xlat11.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat11.xyz;
        u_xlat11.xyz = u_xlat11.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat11.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat11.x = u_xlat1.y * 0.25 + 0.75;
        u_xlat6.x = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat11.x, u_xlat6.x);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_32 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat16_33 = (u_xlatb6) ? 1.0 : 0.0;
    u_xlat6.xy = u_xlat0.xy / u_xlat0.ww;
    u_xlat6.xy = u_xlat6.xy + float2(0.5, 0.5);
    u_xlat16_30 = _LightTexture0.sample(sampler_LightTexture0, u_xlat6.xy).w;
    u_xlat16_33 = half(u_xlat16_30 * u_xlat16_33);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_33 = half(u_xlat16_0.x * u_xlat16_33);
    u_xlat16_32 = half(u_xlat16_32 * u_xlat16_33);
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_33 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
    u_xlat16_33 = rsqrt(u_xlat16_33);
    u_xlat16_8.xyz = half3(half3(u_xlat16_33) * u_xlat16_7.xyz);
    u_xlat16_9.xyz = half3(half3(u_xlat16_32) * Globals._LightColor0.xyz);
    u_xlat16_32 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_33) + (-u_xlat16_5.xyz));
    u_xlat16_33 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_33), 0.00100000005));
    u_xlat16_33 = rsqrt(u_xlat16_0.x);
    u_xlat16_7.xyz = half3(half3(u_xlat16_33) * u_xlat16_7.xyz);
    u_xlat16_33 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_34 = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_34 = clamp(u_xlat16_34, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_7.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_14 = dot(u_xlat16_8.xyz, u_xlat16_7.xyz);
    u_xlat16_14 = clamp(u_xlat16_14, 0.0h, 1.0h);
    u_xlat16_24 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_24 = dot(half2(u_xlat16_24), half2(u_xlat16_32));
    u_xlat16_24 = half(float(u_xlat16_24) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_34)) + 1.0);
    u_xlat16_15 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_15 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_15);
    u_xlat16_5.x = half(float(u_xlat16_24) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_15 = half(-abs(float(u_xlat16_33)) + 1.0);
    u_xlat16_25 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_25 = half(u_xlat16_25 * u_xlat16_25);
    u_xlat16_15 = half(u_xlat16_15 * u_xlat16_25);
    u_xlat16_24 = half(float(u_xlat16_24) * float(u_xlat16_15) + 1.0);
    u_xlat16_24 = half(u_xlat16_24 * u_xlat16_5.x);
    u_xlat16_24 = half(u_xlat16_34 * u_xlat16_24);
    u_xlat16_5.x = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_32 = half((-float(u_xlat16_32)) * float(u_xlat16_32) + 1.0);
    u_xlat16_15 = half(abs(u_xlat16_33) * u_xlat16_32 + u_xlat16_5.x);
    u_xlat16_32 = half(u_xlat16_34 * u_xlat16_32 + u_xlat16_5.x);
    u_xlat16_32 = half(u_xlat16_32 * abs(u_xlat16_33));
    u_xlat16_32 = half(u_xlat16_34 * u_xlat16_15 + u_xlat16_32);
    u_xlat16_0.x = half(float(u_xlat16_32) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_32 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_33 = half(u_xlat16_4.x * u_xlat16_32 + (-u_xlat16_4.x));
    u_xlat16_10 = half(float(u_xlat16_33) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_20 = half(float(u_xlat16_32) * 0.318309873);
    u_xlat16_10 = half(float(u_xlat16_10) * float(u_xlat16_10) + 1.00000001e-07);
    u_xlat16_10 = half(u_xlat16_20 / u_xlat16_10);
    u_xlat16_32 = half(u_xlat16_10 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_32) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_32 = half(u_xlat16_34 * u_xlat16_0.x);
    u_xlat16_33 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_33!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_32 = half(u_xlat0.x * float(u_xlat16_32));
    u_xlat16_4.xzw = half3(half3(u_xlat16_24) * u_xlat16_9.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_9.xyz * half3(u_xlat16_32));
    u_xlat16_32 = half((-float(u_xlat16_14)) + 1.0);
    u_xlat16_33 = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_33 = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_32 = half(u_xlat16_32 * u_xlat16_33);
    u_xlat16_7.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_32) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
bool u_xlatb21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat4 = hlslcc_mtx4x4unity_WorldToLight[0] * vs_TEXCOORD5.xxxx + u_xlat4;
    u_xlat4 = hlslcc_mtx4x4unity_WorldToLight[2] * vs_TEXCOORD5.zzzz + u_xlat4;
    u_xlat4 = u_xlat4 + hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlatb21 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb21){
        u_xlatb21 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb21)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat21 = u_xlat5.y * 0.25 + 0.75;
        u_xlat22 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat21, u_xlat22);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat21 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlatb22 = 0.0<u_xlat4.z;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat5.xy = u_xlat4.xy / u_xlat4.ww;
    u_xlat5.xy = u_xlat5.xy + vec2(0.5, 0.5);
    u_xlat10_5 = texture(_LightTexture0, u_xlat5.xy);
    u_xlat22 = u_xlat22 * u_xlat10_5.w;
    u_xlat23 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_4 = texture(_LightTextureB0, vec2(u_xlat23));
    u_xlat22 = u_xlat22 * u_xlat10_4.w;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat5.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat21) * _LightColor0.xyz;
    u_xlat21 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat22) + (-u_xlat3.xyz);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = max(u_xlat22, 0.00100000005);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat4.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat22 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat21));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat22) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat21 * u_xlat21;
    u_xlat21 = (-u_xlat21) * u_xlat21 + 1.0;
    u_xlat10 = abs(u_xlat22) * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat23 * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat21 * abs(u_xlat22);
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTextureB0" to slot 1
Set CUBE Texture "_LightTexture0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (1) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (1) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_9;
    float u_xlat10;
    half u_xlat16_13;
    half u_xlat16_14;
    half u_xlat16_18;
    half u_xlat16_22;
    half u_xlat16_23;
    float u_xlat27;
    half u_xlat16_27;
    bool u_xlatb27;
    half u_xlat16_29;
    half u_xlat16_30;
    half u_xlat16_31;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_29 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_29));
    u_xlat16_29 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_4.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD4.xyz);
    u_xlat16_29 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_5.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb27 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb27){
        u_xlatb27 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat1.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat1.xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat1.xyz;
        u_xlat1.xyz = u_xlat1.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb27)) ? u_xlat1.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat27 = u_xlat1.y * 0.25 + 0.75;
        u_xlat10 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat27, u_xlat10);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_29 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_29 = clamp(u_xlat16_29, 0.0h, 1.0h);
    u_xlat27 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_27 = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat27)).w;
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xyz).w;
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_27);
    u_xlat16_0.x = half(u_xlat16_29 * u_xlat16_0.x);
    u_xlat16_6.x = input.TEXCOORD2.w;
    u_xlat16_6.y = input.TEXCOORD3.w;
    u_xlat16_6.z = input.TEXCOORD4.w;
    u_xlat16_29 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_7.xyz = half3(half3(u_xlat16_29) * u_xlat16_6.xyz);
    u_xlat16_8.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_30 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + (-u_xlat16_5.xyz));
    u_xlat16_29 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_29), 0.00100000005));
    u_xlat16_29 = rsqrt(u_xlat16_0.x);
    u_xlat16_6.xyz = half3(half3(u_xlat16_29) * u_xlat16_6.xyz);
    u_xlat16_29 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_31 = dot(u_xlat16_4.xyz, u_xlat16_7.xyz);
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_6.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_13 = dot(u_xlat16_7.xyz, u_xlat16_6.xyz);
    u_xlat16_13 = clamp(u_xlat16_13, 0.0h, 1.0h);
    u_xlat16_22 = half(u_xlat16_13 * u_xlat16_13);
    u_xlat16_22 = dot(half2(u_xlat16_22), half2(u_xlat16_30));
    u_xlat16_22 = half(float(u_xlat16_22) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_31)) + 1.0);
    u_xlat16_14 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_14);
    u_xlat16_5.x = half(float(u_xlat16_22) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_14 = half(-abs(float(u_xlat16_29)) + 1.0);
    u_xlat16_23 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_23);
    u_xlat16_22 = half(float(u_xlat16_22) * float(u_xlat16_14) + 1.0);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_5.x);
    u_xlat16_22 = half(u_xlat16_31 * u_xlat16_22);
    u_xlat16_5.x = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_30 = half((-float(u_xlat16_30)) * float(u_xlat16_30) + 1.0);
    u_xlat16_14 = half(abs(u_xlat16_29) * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_31 * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_29 = half(abs(u_xlat16_29) * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_14 + u_xlat16_29);
    u_xlat16_0.x = half(float(u_xlat16_29) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_29 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_4.x * u_xlat16_29 + (-u_xlat16_4.x));
    u_xlat16_9 = half(float(u_xlat16_30) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_18 = half(float(u_xlat16_29) * 0.318309873);
    u_xlat16_9 = half(float(u_xlat16_9) * float(u_xlat16_9) + 1.00000001e-07);
    u_xlat16_9 = half(u_xlat16_18 / u_xlat16_9);
    u_xlat16_29 = half(u_xlat16_9 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_29) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_0.x);
    u_xlat16_30 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_30!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_29 = half(u_xlat0.x * float(u_xlat16_29));
    u_xlat16_4.xzw = half3(half3(u_xlat16_22) * u_xlat16_8.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_29));
    u_xlat16_29 = half((-float(u_xlat16_13)) + 1.0);
    u_xlat16_30 = half(u_xlat16_29 * u_xlat16_29);
    u_xlat16_30 = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_29 * u_xlat16_30);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
bool u_xlatb21;
float u_xlat22;
float u_xlat16_22;
bool u_xlatb22;
float u_xlat23;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
    u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb21 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb21){
        u_xlatb21 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb21)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat21 = u_xlat5.y * 0.25 + 0.75;
        u_xlat22 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat21, u_xlat22);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat21 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_5 = texture(_LightTextureB0, vec2(u_xlat22));
    u_xlat10_4 = texture(_LightTexture0, u_xlat4.xyz);
    u_xlat16_22 = u_xlat10_4.w * u_xlat10_5.w;
    u_xlat21 = u_xlat21 * u_xlat16_22;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat5.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat21) * _LightColor0.xyz;
    u_xlat21 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat22) + (-u_xlat3.xyz);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = max(u_xlat22, 0.00100000005);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat4.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat22 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat21));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat22) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat21 * u_xlat21;
    u_xlat21 = (-u_xlat21) * u_xlat21 + 1.0;
    u_xlat10 = abs(u_xlat22) * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat23 * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat21 * abs(u_xlat22);
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float2 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_9;
    half u_xlat16_13;
    half u_xlat16_14;
    float u_xlat18;
    half u_xlat16_18;
    bool u_xlatb18;
    half u_xlat16_22;
    half u_xlat16_23;
    float u_xlat27;
    half u_xlat16_29;
    half u_xlat16_30;
    half u_xlat16_31;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_29 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_29));
    u_xlat16_29 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_4.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD4.xyz);
    u_xlat16_29 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_5.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD1.xyz);
    u_xlat0.xy = input.TEXCOORD5.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * input.TEXCOORD5.xx + u_xlat0.xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * input.TEXCOORD5.zz + u_xlat0.xy;
    u_xlat0.xy = u_xlat0.xy + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlatb18 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb18){
        u_xlatb18 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat1.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat1.xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat1.xyz;
        u_xlat1.xyz = u_xlat1.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb18)) ? u_xlat1.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat18 = u_xlat1.y * 0.25 + 0.75;
        u_xlat27 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat27, u_xlat18);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_30 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_30 = clamp(u_xlat16_30, 0.0h, 1.0h);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xy).w;
    u_xlat16_0.x = half(u_xlat16_30 * u_xlat16_0.x);
    u_xlat16_6.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_30 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_8.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_29) + u_xlat16_7.xyz);
    u_xlat16_29 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_29), 0.00100000005));
    u_xlat16_29 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_29) * u_xlat16_8.xyz);
    u_xlat16_29 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_31 = dot(u_xlat16_4.xyz, u_xlat16_7.xyz);
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_13 = dot(u_xlat16_7.xyz, u_xlat16_8.xyz);
    u_xlat16_13 = clamp(u_xlat16_13, 0.0h, 1.0h);
    u_xlat16_22 = half(u_xlat16_13 * u_xlat16_13);
    u_xlat16_22 = dot(half2(u_xlat16_22), half2(u_xlat16_30));
    u_xlat16_22 = half(float(u_xlat16_22) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_31)) + 1.0);
    u_xlat16_14 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_14);
    u_xlat16_5.x = half(float(u_xlat16_22) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_14 = half(-abs(float(u_xlat16_29)) + 1.0);
    u_xlat16_23 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_23);
    u_xlat16_22 = half(float(u_xlat16_22) * float(u_xlat16_14) + 1.0);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_5.x);
    u_xlat16_22 = half(u_xlat16_31 * u_xlat16_22);
    u_xlat16_5.x = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_30 = half((-float(u_xlat16_30)) * float(u_xlat16_30) + 1.0);
    u_xlat16_14 = half(abs(u_xlat16_29) * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_31 * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_29 = half(abs(u_xlat16_29) * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_14 + u_xlat16_29);
    u_xlat16_0.x = half(float(u_xlat16_29) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_29 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_4.x * u_xlat16_29 + (-u_xlat16_4.x));
    u_xlat16_9 = half(float(u_xlat16_30) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_18 = half(float(u_xlat16_29) * 0.318309873);
    u_xlat16_9 = half(float(u_xlat16_9) * float(u_xlat16_9) + 1.00000001e-07);
    u_xlat16_9 = half(u_xlat16_18 / u_xlat16_9);
    u_xlat16_29 = half(u_xlat16_9 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_29) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_0.x);
    u_xlat16_30 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_30!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_29 = half(u_xlat0.x * float(u_xlat16_29));
    u_xlat16_4.xzw = half3(half3(u_xlat16_22) * u_xlat16_6.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29));
    u_xlat16_29 = half((-float(u_xlat16_13)) + 1.0);
    u_xlat16_30 = half(u_xlat16_29 * u_xlat16_29);
    u_xlat16_30 = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_29 * u_xlat16_30);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD5.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat4.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * vs_TEXCOORD5.xx + u_xlat4.xy;
    u_xlat4.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * vs_TEXCOORD5.zz + u_xlat4.xy;
    u_xlat4.xy = u_xlat4.xy + hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlatb22 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb22){
        u_xlatb22 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb22)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat22 = u_xlat5.y * 0.25 + 0.75;
        u_xlat23 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat22, u_xlat23);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat22 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat10_4 = texture(_LightTexture0, u_xlat4.xy);
    u_xlat22 = u_xlat22 * u_xlat10_4.w;
    u_xlat4.xyz = vec3(u_xlat22) * _LightColor0.xyz;
    u_xlat22 = (-_Glossiness) + 1.0;
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat21) + u_xlat5.xyz;
    u_xlat21 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat21 = max(u_xlat21, 0.00100000005);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat6.xyz = vec3(u_xlat21) * u_xlat6.xyz;
    u_xlat21 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat22));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat21) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat22 * u_xlat22;
    u_xlat22 = (-u_xlat22) * u_xlat22 + 1.0;
    u_xlat10 = abs(u_xlat21) * u_xlat22 + u_xlat3.x;
    u_xlat22 = u_xlat23 * u_xlat22 + u_xlat3.x;
    u_xlat21 = abs(u_xlat21) * u_xlat22;
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat4.xyz;
    u_xlat3.xyz = u_xlat4.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SPOT SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3
Set 2D Texture "_ShadowMapTexture" to slot 4

Constant Buffer "Globals" (592 bytes) on slot 0 {
  Matrix4x4 unity_WorldToShadow[4] at 32
  Matrix4x4 unity_MatrixV at 320
  Matrix4x4 unity_ProbeVolumeWorldToObject at 400
  Matrix4x4 unity_WorldToLight at 528
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_OcclusionMaskSelector at 16
  VectorHalf4 _LightShadowData at 288
  Vector4 unity_ShadowFadeCenterAndType at 304
  Vector4 unity_ProbeVolumeParams at 384
  Vector3 unity_ProbeVolumeSizeInv at 464
  Vector3 unity_ProbeVolumeMin at 480
  VectorHalf4 _LightColor0 at 496
  VectorHalf4 _Color at 504
  ScalarHalf _Metallic at 512
  ScalarHalf _Glossiness at 514
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_OcclusionMaskSelector;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

constexpr sampler _mtl_xl_shadow_sampler(address::clamp_to_edge, filter::linear, compare_func::greater_equal);
fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    depth2d<float, access::sample > _ShadowMapTexture [[ texture (4) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    float3 u_xlat7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half3 u_xlat16_10;
    half u_xlat16_11;
    float3 u_xlat12;
    bool u_xlatb12;
    half u_xlat16_15;
    half u_xlat16_16;
    half u_xlat16_22;
    float u_xlat23;
    half u_xlat16_23;
    bool u_xlatb23;
    half u_xlat16_26;
    half u_xlat16_27;
    half u_xlat16_33;
    float u_xlat34;
    half u_xlat16_35;
    half u_xlat16_36;
    half u_xlat16_37;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_35 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_35));
    u_xlat16_35 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_4.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD4.xyz);
    u_xlat16_35 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_5.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD1.xyz);
    u_xlat0 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * input.TEXCOORD5.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * input.TEXCOORD5.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat12.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat12.x = dot(u_xlat12.xyz, u_xlat12.xyz);
    u_xlat12.x = sqrt(u_xlat12.x);
    u_xlat12.x = (-u_xlat1.x) + u_xlat12.x;
    u_xlat1.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat12.x + u_xlat1.x;
    u_xlat1.x = u_xlat1.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat1.x = clamp(u_xlat1.x, 0.0f, 1.0f);
    u_xlatb12 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb12){
        u_xlatb23 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb23)) ? u_xlat6.xyz : input.TEXCOORD5.xyz;
        u_xlat6.xyz = u_xlat6.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat6.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat23 = u_xlat6.y * 0.25 + 0.75;
        u_xlat34 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat34, u_xlat23);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_35 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_35 = clamp(u_xlat16_35, 0.0h, 1.0h);
    u_xlat6 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat6 = Globals.hlslcc_mtx4x4unity_WorldToShadow[0] * input.TEXCOORD5.xxxx + u_xlat6;
    u_xlat6 = Globals.hlslcc_mtx4x4unity_WorldToShadow[2] * input.TEXCOORD5.zzzz + u_xlat6;
    u_xlat6 = u_xlat6 + Globals.hlslcc_mtx4x4unity_WorldToShadow[3];
    u_xlat7.xyz = u_xlat6.xyz / u_xlat6.www;
    u_xlat16_23 = _ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat7.xy, saturate(u_xlat7.z), level(0.0));
    u_xlat16_36 = half((-float(Globals._LightShadowData.x)) + 1.0);
    u_xlat16_36 = half(u_xlat16_23 * u_xlat16_36 + Globals._LightShadowData.x);
    u_xlat16_36 = half(u_xlat1.x + float(u_xlat16_36));
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_35 = min(u_xlat16_35, u_xlat16_36);
    u_xlat16_35 = (u_xlatb12) ? u_xlat16_35 : u_xlat16_36;
    u_xlatb1 = 0.0<u_xlat0.z;
    u_xlat16_36 = (u_xlatb1) ? 1.0 : 0.0;
    u_xlat1.xy = u_xlat0.xy / u_xlat0.ww;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 0.5);
    u_xlat16_33 = _LightTexture0.sample(sampler_LightTexture0, u_xlat1.xy).w;
    u_xlat16_36 = half(u_xlat16_33 * u_xlat16_36);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_36 = half(u_xlat16_0.x * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_36);
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_36 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_36 = rsqrt(u_xlat16_36);
    u_xlat16_9.xyz = half3(half3(u_xlat16_36) * u_xlat16_8.xyz);
    u_xlat16_10.xyz = half3(half3(u_xlat16_35) * Globals._LightColor0.xyz);
    u_xlat16_35 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_36) + (-u_xlat16_5.xyz));
    u_xlat16_36 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_36), 0.00100000005));
    u_xlat16_36 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_36) * u_xlat16_8.xyz);
    u_xlat16_36 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_37 = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_37 = clamp(u_xlat16_37, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_15 = dot(u_xlat16_9.xyz, u_xlat16_8.xyz);
    u_xlat16_15 = clamp(u_xlat16_15, 0.0h, 1.0h);
    u_xlat16_26 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_26 = dot(half2(u_xlat16_26), half2(u_xlat16_35));
    u_xlat16_26 = half(float(u_xlat16_26) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_37)) + 1.0);
    u_xlat16_16 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_16);
    u_xlat16_5.x = half(float(u_xlat16_26) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_16 = half(-abs(float(u_xlat16_36)) + 1.0);
    u_xlat16_27 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_27);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_27);
    u_xlat16_26 = half(float(u_xlat16_26) * float(u_xlat16_16) + 1.0);
    u_xlat16_26 = half(u_xlat16_26 * u_xlat16_5.x);
    u_xlat16_26 = half(u_xlat16_37 * u_xlat16_26);
    u_xlat16_5.x = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_35 = half((-float(u_xlat16_35)) * float(u_xlat16_35) + 1.0);
    u_xlat16_16 = half(abs(u_xlat16_36) * u_xlat16_35 + u_xlat16_5.x);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_35 + u_xlat16_5.x);
    u_xlat16_35 = half(u_xlat16_35 * abs(u_xlat16_36));
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_16 + u_xlat16_35);
    u_xlat16_0.x = half(float(u_xlat16_35) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_35 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_4.x * u_xlat16_35 + (-u_xlat16_4.x));
    u_xlat16_11 = half(float(u_xlat16_36) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_22 = half(float(u_xlat16_35) * 0.318309873);
    u_xlat16_11 = half(float(u_xlat16_11) * float(u_xlat16_11) + 1.00000001e-07);
    u_xlat16_11 = half(u_xlat16_22 / u_xlat16_11);
    u_xlat16_35 = half(u_xlat16_11 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_35) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_0.x);
    u_xlat16_36 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_36!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_35 = half(u_xlat0.x * float(u_xlat16_35));
    u_xlat16_4.xzw = half3(half3(u_xlat16_26) * u_xlat16_10.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_10.xyz * half3(u_xlat16_35));
    u_xlat16_35 = half((-float(u_xlat16_15)) + 1.0);
    u_xlat16_36 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_36);
    u_xlat16_8.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToShadow[16];
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler3D unity_ProbeVolumeSH;
uniform  sampler2DShadow hlslcc_zcmp_ShadowMapTexture;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
bool u_xlatb23;
float u_xlat24;
float u_xlat10_24;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat4 = hlslcc_mtx4x4unity_WorldToLight[0] * vs_TEXCOORD5.xxxx + u_xlat4;
    u_xlat4 = hlslcc_mtx4x4unity_WorldToLight[2] * vs_TEXCOORD5.zzzz + u_xlat4;
    u_xlat4 = u_xlat4 + hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat21 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat22 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat22 = sqrt(u_xlat22);
    u_xlat22 = (-u_xlat21) + u_xlat22;
    u_xlat21 = unity_ShadowFadeCenterAndType.w * u_xlat22 + u_xlat21;
    u_xlat21 = u_xlat21 * _LightShadowData.z + _LightShadowData.w;
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlatb22 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb22){
        u_xlatb23 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb23)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat23 = u_xlat5.y * 0.25 + 0.75;
        u_xlat24 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat23, u_xlat24);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat23 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat5 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat5 = hlslcc_mtx4x4unity_WorldToShadow[0] * vs_TEXCOORD5.xxxx + u_xlat5;
    u_xlat5 = hlslcc_mtx4x4unity_WorldToShadow[2] * vs_TEXCOORD5.zzzz + u_xlat5;
    u_xlat5 = u_xlat5 + hlslcc_mtx4x4unity_WorldToShadow[3];
    u_xlat5.xyz = u_xlat5.xyz / u_xlat5.www;
    vec3 txVec0 = vec3(u_xlat5.xy,u_xlat5.z);
    u_xlat10_24 = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec0, 0.0);
    u_xlat5.x = (-_LightShadowData.x) + 1.0;
    u_xlat24 = u_xlat10_24 * u_xlat5.x + _LightShadowData.x;
    u_xlat21 = u_xlat21 + u_xlat24;
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlat23 = min(u_xlat21, u_xlat23);
    u_xlat21 = (u_xlatb22) ? u_xlat23 : u_xlat21;
    u_xlatb22 = 0.0<u_xlat4.z;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat5.xy = u_xlat4.xy / u_xlat4.ww;
    u_xlat5.xy = u_xlat5.xy + vec2(0.5, 0.5);
    u_xlat10_5 = texture(_LightTexture0, u_xlat5.xy);
    u_xlat22 = u_xlat22 * u_xlat10_5.w;
    u_xlat23 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_4 = texture(_LightTextureB0, vec2(u_xlat23));
    u_xlat22 = u_xlat22 * u_xlat10_4.w;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat5.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat21) * _LightColor0.xyz;
    u_xlat21 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat22) + (-u_xlat3.xyz);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = max(u_xlat22, 0.00100000005);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat4.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat22 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat21));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat22) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat21 * u_xlat21;
    u_xlat21 = (-u_xlat21) * u_xlat21 + 1.0;
    u_xlat10 = abs(u_xlat22) * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat23 * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat21 * abs(u_xlat22);
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SPOT SHADOWS_DEPTH SHADOWS_SOFT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3
Set 2D Texture "_ShadowMapTexture" to slot 4

Constant Buffer "Globals" (656 bytes) on slot 0 {
  Matrix4x4 unity_WorldToShadow[4] at 32
  Matrix4x4 unity_MatrixV at 320
  Matrix4x4 unity_ProbeVolumeWorldToObject at 400
  Matrix4x4 unity_WorldToLight at 592
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_OcclusionMaskSelector at 16
  VectorHalf4 _LightShadowData at 288
  Vector4 unity_ShadowFadeCenterAndType at 304
  Vector4 unity_ProbeVolumeParams at 384
  Vector3 unity_ProbeVolumeSizeInv at 464
  Vector3 unity_ProbeVolumeMin at 480
  VectorHalf4 _LightColor0 at 496
  Vector4 _ShadowOffsets[4] at 512
  VectorHalf4 _Color at 576
  ScalarHalf _Metallic at 584
  ScalarHalf _Glossiness at 586
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_OcclusionMaskSelector;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    float4 _ShadowOffsets[4];
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

constexpr sampler _mtl_xl_shadow_sampler(address::clamp_to_edge, filter::linear, compare_func::greater_equal);
fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    depth2d<float, access::sample > _ShadowMapTexture [[ texture (4) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    float3 u_xlat7;
    bool u_xlatb7;
    float3 u_xlat8;
    half3 u_xlat16_9;
    half3 u_xlat16_10;
    half3 u_xlat16_11;
    half u_xlat16_12;
    float3 u_xlat13;
    bool u_xlatb13;
    half u_xlat16_16;
    half u_xlat16_17;
    half u_xlat16_24;
    float u_xlat25;
    half u_xlat16_25;
    bool u_xlatb25;
    half u_xlat16_28;
    half u_xlat16_29;
    half u_xlat16_36;
    float u_xlat37;
    half u_xlat16_38;
    half u_xlat16_39;
    half u_xlat16_40;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_38 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_38));
    u_xlat16_38 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_38 = rsqrt(u_xlat16_38);
    u_xlat16_4.xyz = half3(half3(u_xlat16_38) * input.TEXCOORD4.xyz);
    u_xlat16_38 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_38 = rsqrt(u_xlat16_38);
    u_xlat16_5.xyz = half3(half3(u_xlat16_38) * input.TEXCOORD1.xyz);
    u_xlat0 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * input.TEXCOORD5.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * input.TEXCOORD5.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat13.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat13.x = dot(u_xlat13.xyz, u_xlat13.xyz);
    u_xlat13.x = sqrt(u_xlat13.x);
    u_xlat13.x = (-u_xlat1.x) + u_xlat13.x;
    u_xlat1.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat13.x + u_xlat1.x;
    u_xlat1.x = u_xlat1.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat1.x = clamp(u_xlat1.x, 0.0f, 1.0f);
    u_xlatb13 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb13){
        u_xlatb25 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb25)) ? u_xlat6.xyz : input.TEXCOORD5.xyz;
        u_xlat6.xyz = u_xlat6.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat6.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat25 = u_xlat6.y * 0.25 + 0.75;
        u_xlat37 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat37, u_xlat25);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_38 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_38 = clamp(u_xlat16_38, 0.0h, 1.0h);
    u_xlatb25 = u_xlat1.x<0.99000001;
    if(u_xlatb25){
        u_xlat6 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToShadow[1];
        u_xlat6 = Globals.hlslcc_mtx4x4unity_WorldToShadow[0] * input.TEXCOORD5.xxxx + u_xlat6;
        u_xlat6 = Globals.hlslcc_mtx4x4unity_WorldToShadow[2] * input.TEXCOORD5.zzzz + u_xlat6;
        u_xlat6 = u_xlat6 + Globals.hlslcc_mtx4x4unity_WorldToShadow[3];
        u_xlat7.xyz = u_xlat6.xyz / u_xlat6.www;
        u_xlat8.xyz = u_xlat7.xyz + Globals._ShadowOffsets[0].xyz;
        u_xlat6.x = float(_ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat8.xy, saturate(u_xlat8.z), level(0.0)));
        u_xlat8.xyz = u_xlat7.xyz + Globals._ShadowOffsets[1].xyz;
        u_xlat6.y = float(_ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat8.xy, saturate(u_xlat8.z), level(0.0)));
        u_xlat8.xyz = u_xlat7.xyz + Globals._ShadowOffsets[2].xyz;
        u_xlat6.z = float(_ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat8.xy, saturate(u_xlat8.z), level(0.0)));
        u_xlat7.xyz = u_xlat7.xyz + Globals._ShadowOffsets[3].xyz;
        u_xlat6.w = float(_ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat7.xy, saturate(u_xlat7.z), level(0.0)));
        u_xlat16_39 = half((-float(Globals._LightShadowData.x)) + 1.0);
        u_xlat16_6 = half4(u_xlat6 * float4(u_xlat16_39) + float4(Globals._LightShadowData.xxxx));
        u_xlat16_25 = half(dot(float4(u_xlat16_6), float4(0.25, 0.25, 0.25, 0.25)));
    } else {
        u_xlat16_25 = 1.0;
    }
    u_xlat16_39 = half(u_xlat1.x + float(u_xlat16_25));
    u_xlat16_39 = clamp(u_xlat16_39, 0.0h, 1.0h);
    u_xlat16_38 = min(u_xlat16_38, u_xlat16_39);
    u_xlat16_38 = (u_xlatb13) ? u_xlat16_38 : u_xlat16_39;
    u_xlatb7 = 0.0<u_xlat0.z;
    u_xlat16_39 = (u_xlatb7) ? 1.0 : 0.0;
    u_xlat7.xy = u_xlat0.xy / u_xlat0.ww;
    u_xlat7.xy = u_xlat7.xy + float2(0.5, 0.5);
    u_xlat16_36 = _LightTexture0.sample(sampler_LightTexture0, u_xlat7.xy).w;
    u_xlat16_39 = half(u_xlat16_36 * u_xlat16_39);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_39 = half(u_xlat16_0.x * u_xlat16_39);
    u_xlat16_38 = half(u_xlat16_38 * u_xlat16_39);
    u_xlat16_9.x = input.TEXCOORD2.w;
    u_xlat16_9.y = input.TEXCOORD3.w;
    u_xlat16_9.z = input.TEXCOORD4.w;
    u_xlat16_39 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlat16_39 = rsqrt(u_xlat16_39);
    u_xlat16_10.xyz = half3(half3(u_xlat16_39) * u_xlat16_9.xyz);
    u_xlat16_11.xyz = half3(half3(u_xlat16_38) * Globals._LightColor0.xyz);
    u_xlat16_38 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_9.xyz = half3(u_xlat16_9.xyz * half3(u_xlat16_39) + (-u_xlat16_5.xyz));
    u_xlat16_39 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_39), 0.00100000005));
    u_xlat16_39 = rsqrt(u_xlat16_0.x);
    u_xlat16_9.xyz = half3(half3(u_xlat16_39) * u_xlat16_9.xyz);
    u_xlat16_39 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_40 = dot(u_xlat16_4.xyz, u_xlat16_10.xyz);
    u_xlat16_40 = clamp(u_xlat16_40, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_16 = dot(u_xlat16_10.xyz, u_xlat16_9.xyz);
    u_xlat16_16 = clamp(u_xlat16_16, 0.0h, 1.0h);
    u_xlat16_28 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_28 = dot(half2(u_xlat16_28), half2(u_xlat16_38));
    u_xlat16_28 = half(float(u_xlat16_28) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_40)) + 1.0);
    u_xlat16_17 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_17);
    u_xlat16_5.x = half(float(u_xlat16_28) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_17 = half(-abs(float(u_xlat16_39)) + 1.0);
    u_xlat16_29 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_29 = half(u_xlat16_29 * u_xlat16_29);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_29);
    u_xlat16_28 = half(float(u_xlat16_28) * float(u_xlat16_17) + 1.0);
    u_xlat16_28 = half(u_xlat16_28 * u_xlat16_5.x);
    u_xlat16_28 = half(u_xlat16_40 * u_xlat16_28);
    u_xlat16_5.x = half(u_xlat16_38 * u_xlat16_38);
    u_xlat16_38 = half((-float(u_xlat16_38)) * float(u_xlat16_38) + 1.0);
    u_xlat16_17 = half(abs(u_xlat16_39) * u_xlat16_38 + u_xlat16_5.x);
    u_xlat16_38 = half(u_xlat16_40 * u_xlat16_38 + u_xlat16_5.x);
    u_xlat16_38 = half(u_xlat16_38 * abs(u_xlat16_39));
    u_xlat16_38 = half(u_xlat16_40 * u_xlat16_17 + u_xlat16_38);
    u_xlat16_0.x = half(float(u_xlat16_38) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_38 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_39 = half(u_xlat16_4.x * u_xlat16_38 + (-u_xlat16_4.x));
    u_xlat16_12 = half(float(u_xlat16_39) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_24 = half(float(u_xlat16_38) * 0.318309873);
    u_xlat16_12 = half(float(u_xlat16_12) * float(u_xlat16_12) + 1.00000001e-07);
    u_xlat16_12 = half(u_xlat16_24 / u_xlat16_12);
    u_xlat16_38 = half(u_xlat16_12 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_38) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_38 = half(u_xlat16_40 * u_xlat16_0.x);
    u_xlat16_39 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_39!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_38 = half(u_xlat0.x * float(u_xlat16_38));
    u_xlat16_4.xzw = half3(half3(u_xlat16_28) * u_xlat16_11.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_11.xyz * half3(u_xlat16_38));
    u_xlat16_38 = half((-float(u_xlat16_16)) + 1.0);
    u_xlat16_39 = half(u_xlat16_38 * u_xlat16_38);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_38 = half(u_xlat16_38 * u_xlat16_39);
    u_xlat16_9.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_9.xyz * half3(u_xlat16_38) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToShadow[16];
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _ShadowOffsets[4];
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler3D unity_ProbeVolumeSH;
uniform  sampler2DShadow hlslcc_zcmp_ShadowMapTexture;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec4 u_xlat6;
vec3 u_xlat7;
float u_xlat10;
float u_xlat11;
float u_xlat18;
float u_xlat19;
float u_xlat24;
float u_xlat25;
bool u_xlatb25;
float u_xlat26;
bool u_xlatb26;
float u_xlat27;
bool u_xlatb27;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat24 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat24) * u_xlat1.xyz;
    u_xlat24 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat24 = inversesqrt(u_xlat24);
    u_xlat2.xyz = vec3(u_xlat24) * vs_TEXCOORD4.xyz;
    u_xlat24 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat24 = inversesqrt(u_xlat24);
    u_xlat3.xyz = vec3(u_xlat24) * vs_TEXCOORD1.xyz;
    u_xlat4 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat4 = hlslcc_mtx4x4unity_WorldToLight[0] * vs_TEXCOORD5.xxxx + u_xlat4;
    u_xlat4 = hlslcc_mtx4x4unity_WorldToLight[2] * vs_TEXCOORD5.zzzz + u_xlat4;
    u_xlat4 = u_xlat4 + hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat24 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat25 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat25 = sqrt(u_xlat25);
    u_xlat25 = (-u_xlat24) + u_xlat25;
    u_xlat24 = unity_ShadowFadeCenterAndType.w * u_xlat25 + u_xlat24;
    u_xlat24 = u_xlat24 * _LightShadowData.z + _LightShadowData.w;
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlatb25 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb25){
        u_xlatb26 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb26)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat26 = u_xlat5.y * 0.25 + 0.75;
        u_xlat27 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat26, u_xlat27);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat26 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat26 = clamp(u_xlat26, 0.0, 1.0);
    u_xlatb27 = u_xlat24<0.99000001;
    if(u_xlatb27){
        u_xlat5 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToShadow[1];
        u_xlat5 = hlslcc_mtx4x4unity_WorldToShadow[0] * vs_TEXCOORD5.xxxx + u_xlat5;
        u_xlat5 = hlslcc_mtx4x4unity_WorldToShadow[2] * vs_TEXCOORD5.zzzz + u_xlat5;
        u_xlat5 = u_xlat5 + hlslcc_mtx4x4unity_WorldToShadow[3];
        u_xlat5.xyz = u_xlat5.xyz / u_xlat5.www;
        u_xlat6.xyz = u_xlat5.xyz + _ShadowOffsets[0].xyz;
        vec3 txVec0 = vec3(u_xlat6.xy,u_xlat6.z);
        u_xlat6.x = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec0, 0.0);
        u_xlat7.xyz = u_xlat5.xyz + _ShadowOffsets[1].xyz;
        vec3 txVec1 = vec3(u_xlat7.xy,u_xlat7.z);
        u_xlat6.y = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec1, 0.0);
        u_xlat7.xyz = u_xlat5.xyz + _ShadowOffsets[2].xyz;
        vec3 txVec2 = vec3(u_xlat7.xy,u_xlat7.z);
        u_xlat6.z = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec2, 0.0);
        u_xlat5.xyz = u_xlat5.xyz + _ShadowOffsets[3].xyz;
        vec3 txVec3 = vec3(u_xlat5.xy,u_xlat5.z);
        u_xlat6.w = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec3, 0.0);
        u_xlat27 = (-_LightShadowData.x) + 1.0;
        u_xlat5 = u_xlat6 * vec4(u_xlat27) + _LightShadowData.xxxx;
        u_xlat27 = dot(u_xlat5, vec4(0.25, 0.25, 0.25, 0.25));
    } else {
        u_xlat27 = 1.0;
    //ENDIF
    }
    u_xlat24 = u_xlat24 + u_xlat27;
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat26 = min(u_xlat24, u_xlat26);
    u_xlat24 = (u_xlatb25) ? u_xlat26 : u_xlat24;
    u_xlatb25 = 0.0<u_xlat4.z;
    u_xlat25 = u_xlatb25 ? 1.0 : float(0.0);
    u_xlat5.xy = u_xlat4.xy / u_xlat4.ww;
    u_xlat5.xy = u_xlat5.xy + vec2(0.5, 0.5);
    u_xlat10_5 = texture(_LightTexture0, u_xlat5.xy);
    u_xlat25 = u_xlat25 * u_xlat10_5.w;
    u_xlat26 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_4 = texture(_LightTextureB0, vec2(u_xlat26));
    u_xlat25 = u_xlat25 * u_xlat10_4.w;
    u_xlat24 = u_xlat24 * u_xlat25;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat25 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat25 = inversesqrt(u_xlat25);
    u_xlat5.xyz = vec3(u_xlat25) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat24) * _LightColor0.xyz;
    u_xlat24 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat25) + (-u_xlat3.xyz);
    u_xlat25 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat25 = max(u_xlat25, 0.00100000005);
    u_xlat25 = inversesqrt(u_xlat25);
    u_xlat4.xyz = vec3(u_xlat25) * u_xlat4.xyz;
    u_xlat25 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat26 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat26 = clamp(u_xlat26, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat10 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat10 = clamp(u_xlat10, 0.0, 1.0);
    u_xlat18 = u_xlat10 * u_xlat10;
    u_xlat18 = dot(vec2(u_xlat18), vec2(u_xlat24));
    u_xlat18 = u_xlat18 + -0.5;
    u_xlat3.x = (-u_xlat26) + 1.0;
    u_xlat11 = u_xlat3.x * u_xlat3.x;
    u_xlat11 = u_xlat11 * u_xlat11;
    u_xlat3.x = u_xlat3.x * u_xlat11;
    u_xlat3.x = u_xlat18 * u_xlat3.x + 1.0;
    u_xlat11 = -abs(u_xlat25) + 1.0;
    u_xlat19 = u_xlat11 * u_xlat11;
    u_xlat19 = u_xlat19 * u_xlat19;
    u_xlat11 = u_xlat11 * u_xlat19;
    u_xlat18 = u_xlat18 * u_xlat11 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat3.x;
    u_xlat18 = u_xlat26 * u_xlat18;
    u_xlat3.x = u_xlat24 * u_xlat24;
    u_xlat24 = (-u_xlat24) * u_xlat24 + 1.0;
    u_xlat11 = abs(u_xlat25) * u_xlat24 + u_xlat3.x;
    u_xlat24 = u_xlat26 * u_xlat24 + u_xlat3.x;
    u_xlat24 = u_xlat24 * abs(u_xlat25);
    u_xlat24 = u_xlat26 * u_xlat11 + u_xlat24;
    u_xlat24 = u_xlat24 + 9.99999975e-06;
    u_xlat24 = 0.5 / u_xlat24;
    u_xlat25 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat25 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat25 = u_xlat25 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat25 = u_xlat25 / u_xlat2.x;
    u_xlat24 = u_xlat24 * u_xlat25;
    u_xlat24 = u_xlat24 * 3.14159274;
    u_xlat24 = max(u_xlat24, 9.99999975e-05);
    u_xlat24 = sqrt(u_xlat24);
    u_xlat24 = u_xlat26 * u_xlat24;
    u_xlat25 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb25 = u_xlat25!=0.0;
    u_xlat25 = u_xlatb25 ? 1.0 : float(0.0);
    u_xlat24 = u_xlat24 * u_xlat25;
    u_xlat2.xzw = vec3(u_xlat18) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat24);
    u_xlat24 = (-u_xlat10) + 1.0;
    u_xlat25 = u_xlat24 * u_xlat24;
    u_xlat25 = u_xlat25 * u_xlat25;
    u_xlat24 = u_xlat24 * u_xlat25;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat24) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat2.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat2.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat2.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat2.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (244 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 48
  Matrix4x4 unity_ProbeVolumeWorldToObject at 128
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_OcclusionMaskSelector at 16
  VectorHalf4 _LightShadowData at 24
  Vector4 unity_ShadowFadeCenterAndType at 32
  Vector4 unity_ProbeVolumeParams at 112
  Vector3 unity_ProbeVolumeSizeInv at 192
  Vector3 unity_ProbeVolumeMin at 208
  VectorHalf4 _LightColor0 at 224
  VectorHalf4 _Color at 232
  ScalarHalf _Metallic at 240
  ScalarHalf _Glossiness at 242
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    float3 u_xlat9;
    half u_xlat16_9;
    bool u_xlatb9;
    half u_xlat16_13;
    half u_xlat16_14;
    float2 u_xlat18;
    half u_xlat16_18;
    bool u_xlatb18;
    half u_xlat16_22;
    half u_xlat16_23;
    float u_xlat27;
    half u_xlat16_29;
    half u_xlat16_30;
    half u_xlat16_31;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_29 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_29));
    u_xlat16_29 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_4.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD4.xyz);
    u_xlat16_29 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_5.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat1.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat1.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat1.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);
    u_xlat9.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat9.x = dot(u_xlat9.xyz, u_xlat9.xyz);
    u_xlat9.x = sqrt(u_xlat9.x);
    u_xlat9.x = (-u_xlat0.x) + u_xlat9.x;
    u_xlat0.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat9.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat0.x = clamp(u_xlat0.x, 0.0f, 1.0f);
    u_xlatb9 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb9){
        u_xlatb18 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat1.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat1.xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat1.xyz;
        u_xlat1.xyz = u_xlat1.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb18)) ? u_xlat1.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat18.x = u_xlat1.y * 0.25 + 0.75;
        u_xlat27 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat27, u_xlat18.x);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_30 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_30 = clamp(u_xlat16_30, 0.0h, 1.0h);
    u_xlat18.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_18 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xy).x;
    u_xlat16_31 = half(u_xlat0.x + float(u_xlat16_18));
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_30 = min(u_xlat16_30, u_xlat16_31);
    u_xlat16_30 = (u_xlatb9) ? u_xlat16_30 : u_xlat16_31;
    u_xlat16_6.xyz = half3(half3(u_xlat16_30) * Globals._LightColor0.xyz);
    u_xlat16_30 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_8.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_29) + u_xlat16_7.xyz);
    u_xlat16_29 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_29), 0.00100000005));
    u_xlat16_29 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_29) * u_xlat16_8.xyz);
    u_xlat16_29 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_31 = dot(u_xlat16_4.xyz, u_xlat16_7.xyz);
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_13 = dot(u_xlat16_7.xyz, u_xlat16_8.xyz);
    u_xlat16_13 = clamp(u_xlat16_13, 0.0h, 1.0h);
    u_xlat16_22 = half(u_xlat16_13 * u_xlat16_13);
    u_xlat16_22 = dot(half2(u_xlat16_22), half2(u_xlat16_30));
    u_xlat16_22 = half(float(u_xlat16_22) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_31)) + 1.0);
    u_xlat16_14 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_14);
    u_xlat16_5.x = half(float(u_xlat16_22) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_14 = half(-abs(float(u_xlat16_29)) + 1.0);
    u_xlat16_23 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_23);
    u_xlat16_22 = half(float(u_xlat16_22) * float(u_xlat16_14) + 1.0);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_5.x);
    u_xlat16_22 = half(u_xlat16_31 * u_xlat16_22);
    u_xlat16_5.x = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_30 = half((-float(u_xlat16_30)) * float(u_xlat16_30) + 1.0);
    u_xlat16_14 = half(abs(u_xlat16_29) * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_31 * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_29 = half(abs(u_xlat16_29) * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_14 + u_xlat16_29);
    u_xlat16_0.x = half(float(u_xlat16_29) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_29 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_4.x * u_xlat16_29 + (-u_xlat16_4.x));
    u_xlat16_9 = half(float(u_xlat16_30) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_18 = half(float(u_xlat16_29) * 0.318309873);
    u_xlat16_9 = half(float(u_xlat16_9) * float(u_xlat16_9) + 1.00000001e-07);
    u_xlat16_9 = half(u_xlat16_18 / u_xlat16_9);
    u_xlat16_29 = half(u_xlat16_9 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_29) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_0.x);
    u_xlat16_30 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_30!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_29 = half(u_xlat0.x * float(u_xlat16_29));
    u_xlat16_4.xzw = half3(half3(u_xlat16_22) * u_xlat16_6.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29));
    u_xlat16_29 = half((-float(u_xlat16_13)) + 1.0);
    u_xlat16_30 = half(u_xlat16_29 * u_xlat16_29);
    u_xlat16_30 = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_29 * u_xlat16_30);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat2.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz;
    u_xlat2.w = 0.0;
    vs_TEXCOORD2 = u_xlat2.wwwx;
    vs_TEXCOORD3 = u_xlat2.wwwy;
    vs_TEXCOORD4.w = u_xlat2.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    vs_TEXCOORD4.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat11;
float u_xlat16;
float u_xlat17;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
bool u_xlatb23;
float u_xlat24;
bool u_xlatb24;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat5.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat5.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat5.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat5.xyz);
    u_xlat4.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat23 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat23 = sqrt(u_xlat23);
    u_xlat23 = (-u_xlat22) + u_xlat23;
    u_xlat22 = unity_ShadowFadeCenterAndType.w * u_xlat23 + u_xlat22;
    u_xlat22 = u_xlat22 * _LightShadowData.z + _LightShadowData.w;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlatb23 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb23){
        u_xlatb24 = unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb24)) ? u_xlat4.xyz : vs_TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat24 = u_xlat4.y * 0.25 + 0.75;
        u_xlat11 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat24, u_xlat11);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat24 = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat22 = u_xlat22 + u_xlat10_4.x;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat24 = min(u_xlat22, u_xlat24);
    u_xlat22 = (u_xlatb23) ? u_xlat24 : u_xlat22;
    u_xlat4.xyz = vec3(u_xlat22) * _LightColor0.xyz;
    u_xlat22 = (-_Glossiness) + 1.0;
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat21) + u_xlat5.xyz;
    u_xlat21 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat21 = max(u_xlat21, 0.00100000005);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat6.xyz = vec3(u_xlat21) * u_xlat6.xyz;
    u_xlat21 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat22));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat21) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat22 * u_xlat22;
    u_xlat22 = (-u_xlat22) * u_xlat22 + 1.0;
    u_xlat10 = abs(u_xlat21) * u_xlat22 + u_xlat3.x;
    u_xlat22 = u_xlat23 * u_xlat22 + u_xlat3.x;
    u_xlat21 = abs(u_xlat21) * u_xlat22;
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat4.xyz;
    u_xlat3.xyz = u_xlat4.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL_COOKIE SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat2.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat2.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat2.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat2.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTexture0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (320 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 48
  Matrix4x4 unity_ProbeVolumeWorldToObject at 128
  Matrix4x4 unity_WorldToLight at 256
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_OcclusionMaskSelector at 16
  VectorHalf4 _LightShadowData at 24
  Vector4 unity_ShadowFadeCenterAndType at 32
  Vector4 unity_ProbeVolumeParams at 112
  Vector3 unity_ProbeVolumeSizeInv at 192
  Vector3 unity_ProbeVolumeMin at 208
  VectorHalf4 _LightColor0 at 224
  VectorHalf4 _Color at 232
  ScalarHalf _Metallic at 240
  ScalarHalf _Glossiness at 242
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float2 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float3 u_xlat6;
    half u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half u_xlat16_10;
    float3 u_xlat11;
    half u_xlat16_14;
    half u_xlat16_15;
    float u_xlat20;
    half u_xlat16_20;
    half u_xlat16_24;
    half u_xlat16_25;
    float u_xlat30;
    bool u_xlatb30;
    half u_xlat16_32;
    half u_xlat16_33;
    half u_xlat16_34;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_32 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_32));
    u_xlat16_32 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_32 = rsqrt(u_xlat16_32);
    u_xlat16_4.xyz = half3(half3(u_xlat16_32) * input.TEXCOORD4.xyz);
    u_xlat16_32 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_32 = rsqrt(u_xlat16_32);
    u_xlat16_5.xyz = half3(half3(u_xlat16_32) * input.TEXCOORD1.xyz);
    u_xlat0.xy = input.TEXCOORD5.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * input.TEXCOORD5.xx + u_xlat0.xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * input.TEXCOORD5.zz + u_xlat0.xy;
    u_xlat0.xy = u_xlat0.xy + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat20 = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat1.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat30 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat30 = sqrt(u_xlat30);
    u_xlat30 = (-u_xlat20) + u_xlat30;
    u_xlat20 = Globals.unity_ShadowFadeCenterAndType.w * u_xlat30 + u_xlat20;
    u_xlat20 = u_xlat20 * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat20 = clamp(u_xlat20, 0.0f, 1.0f);
    u_xlatb30 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb30){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat11.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat11.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat11.xyz;
        u_xlat11.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat11.xyz;
        u_xlat11.xyz = u_xlat11.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat11.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat11.x = u_xlat1.y * 0.25 + 0.75;
        u_xlat6.x = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat11.x, u_xlat6.x);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_33 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_33 = clamp(u_xlat16_33, 0.0h, 1.0h);
    u_xlat6.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_6 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat6.xy).x;
    u_xlat16_34 = half(u_xlat20 + float(u_xlat16_6));
    u_xlat16_34 = clamp(u_xlat16_34, 0.0h, 1.0h);
    u_xlat16_33 = min(u_xlat16_33, u_xlat16_34);
    u_xlat16_33 = (u_xlatb30) ? u_xlat16_33 : u_xlat16_34;
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xy).w;
    u_xlat16_0.x = half(u_xlat16_33 * u_xlat16_0.x);
    u_xlat16_7.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_33 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_9.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_32) + u_xlat16_8.xyz);
    u_xlat16_32 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_32), 0.00100000005));
    u_xlat16_32 = rsqrt(u_xlat16_0.x);
    u_xlat16_9.xyz = half3(half3(u_xlat16_32) * u_xlat16_9.xyz);
    u_xlat16_32 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_34 = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_34 = clamp(u_xlat16_34, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_14 = dot(u_xlat16_8.xyz, u_xlat16_9.xyz);
    u_xlat16_14 = clamp(u_xlat16_14, 0.0h, 1.0h);
    u_xlat16_24 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_24 = dot(half2(u_xlat16_24), half2(u_xlat16_33));
    u_xlat16_24 = half(float(u_xlat16_24) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_34)) + 1.0);
    u_xlat16_15 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_15 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_15);
    u_xlat16_5.x = half(float(u_xlat16_24) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_15 = half(-abs(float(u_xlat16_32)) + 1.0);
    u_xlat16_25 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_25 = half(u_xlat16_25 * u_xlat16_25);
    u_xlat16_15 = half(u_xlat16_15 * u_xlat16_25);
    u_xlat16_24 = half(float(u_xlat16_24) * float(u_xlat16_15) + 1.0);
    u_xlat16_24 = half(u_xlat16_24 * u_xlat16_5.x);
    u_xlat16_24 = half(u_xlat16_34 * u_xlat16_24);
    u_xlat16_5.x = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_33 = half((-float(u_xlat16_33)) * float(u_xlat16_33) + 1.0);
    u_xlat16_15 = half(abs(u_xlat16_32) * u_xlat16_33 + u_xlat16_5.x);
    u_xlat16_33 = half(u_xlat16_34 * u_xlat16_33 + u_xlat16_5.x);
    u_xlat16_32 = half(abs(u_xlat16_32) * u_xlat16_33);
    u_xlat16_32 = half(u_xlat16_34 * u_xlat16_15 + u_xlat16_32);
    u_xlat16_0.x = half(float(u_xlat16_32) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_32 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_33 = half(u_xlat16_4.x * u_xlat16_32 + (-u_xlat16_4.x));
    u_xlat16_10 = half(float(u_xlat16_33) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_20 = half(float(u_xlat16_32) * 0.318309873);
    u_xlat16_10 = half(float(u_xlat16_10) * float(u_xlat16_10) + 1.00000001e-07);
    u_xlat16_10 = half(u_xlat16_20 / u_xlat16_10);
    u_xlat16_32 = half(u_xlat16_10 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_32) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_32 = half(u_xlat16_34 * u_xlat16_0.x);
    u_xlat16_33 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_33!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_32 = half(u_xlat0.x * float(u_xlat16_32));
    u_xlat16_4.xzw = half3(half3(u_xlat16_24) * u_xlat16_7.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_32));
    u_xlat16_32 = half((-float(u_xlat16_14)) + 1.0);
    u_xlat16_33 = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_33 = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_32 = half(u_xlat16_32 * u_xlat16_33);
    u_xlat16_7.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_32) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat2.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz;
    u_xlat2.w = 0.0;
    vs_TEXCOORD2 = u_xlat2.wwwx;
    vs_TEXCOORD3 = u_xlat2.wwwy;
    vs_TEXCOORD4.w = u_xlat2.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    vs_TEXCOORD4.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
vec2 u_xlat18;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
bool u_xlatb23;
float u_xlat24;
bool u_xlatb24;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD5.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat4.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * vs_TEXCOORD5.xx + u_xlat4.xy;
    u_xlat4.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * vs_TEXCOORD5.zz + u_xlat4.xy;
    u_xlat4.xy = u_xlat4.xy + hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat22 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat23 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat23 = sqrt(u_xlat23);
    u_xlat23 = (-u_xlat22) + u_xlat23;
    u_xlat22 = unity_ShadowFadeCenterAndType.w * u_xlat23 + u_xlat22;
    u_xlat22 = u_xlat22 * _LightShadowData.z + _LightShadowData.w;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlatb23 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb23){
        u_xlatb24 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb24)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat24 = u_xlat5.y * 0.25 + 0.75;
        u_xlat18.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat24, u_xlat18.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat24 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat18.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_5 = texture(_ShadowMapTexture, u_xlat18.xy);
    u_xlat22 = u_xlat22 + u_xlat10_5.x;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat24 = min(u_xlat22, u_xlat24);
    u_xlat22 = (u_xlatb23) ? u_xlat24 : u_xlat22;
    u_xlat10_4 = texture(_LightTexture0, u_xlat4.xy);
    u_xlat22 = u_xlat22 * u_xlat10_4.w;
    u_xlat4.xyz = vec3(u_xlat22) * _LightColor0.xyz;
    u_xlat22 = (-_Glossiness) + 1.0;
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat21) + u_xlat5.xyz;
    u_xlat21 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat21 = max(u_xlat21, 0.00100000005);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat6.xyz = vec3(u_xlat21) * u_xlat6.xyz;
    u_xlat21 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat22));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat21) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat22 * u_xlat22;
    u_xlat22 = (-u_xlat22) * u_xlat22 + 1.0;
    u_xlat10 = abs(u_xlat21) * u_xlat22 + u_xlat3.x;
    u_xlat22 = u_xlat23 * u_xlat22 + u_xlat3.x;
    u_xlat21 = abs(u_xlat21) * u_xlat22;
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat4.xyz;
    u_xlat3.xyz = u_xlat4.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set CUBE Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTexture0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 64
  Matrix4x4 unity_ProbeVolumeWorldToObject at 144
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _LightPositionRange at 16
  VectorHalf4 unity_OcclusionMaskSelector at 32
  VectorHalf4 _LightShadowData at 40
  Vector4 unity_ShadowFadeCenterAndType at 48
  Vector4 unity_ProbeVolumeParams at 128
  Vector3 unity_ProbeVolumeSizeInv at 208
  Vector3 unity_ProbeVolumeMin at 224
  VectorHalf4 _LightColor0 at 240
  VectorHalf4 _Color at 248
  ScalarHalf _Metallic at 256
  ScalarHalf _Glossiness at 258
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _LightPositionRange;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    float u_xlat7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half3 u_xlat16_10;
    half u_xlat16_11;
    float3 u_xlat12;
    bool u_xlatb12;
    half u_xlat16_15;
    half u_xlat16_16;
    half u_xlat16_22;
    float u_xlat23;
    half u_xlat16_26;
    half u_xlat16_27;
    float u_xlat33;
    half u_xlat16_35;
    half u_xlat16_36;
    half u_xlat16_37;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_35 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_35));
    u_xlat16_35 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_4.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD4.xyz);
    u_xlat16_35 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_5.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat33 = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat1.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = (-u_xlat33) + u_xlat1.x;
    u_xlat33 = Globals.unity_ShadowFadeCenterAndType.w * u_xlat1.x + u_xlat33;
    u_xlat33 = u_xlat33 * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat33 = clamp(u_xlat33, 0.0f, 1.0f);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb12 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.xyz = (bool(u_xlatb12)) ? u_xlat6.xyz : input.TEXCOORD5.xyz;
        u_xlat12.xyz = u_xlat12.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat12.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat12.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat23 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat23, u_xlat12.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_35 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_35 = clamp(u_xlat16_35, 0.0h, 1.0h);
    u_xlat12.xyz = input.TEXCOORD5.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat7 = dot(u_xlat12.xyz, u_xlat12.xyz);
    u_xlat7 = sqrt(u_xlat7);
    u_xlat7 = u_xlat7 * Globals._LightPositionRange.w;
    u_xlat7 = u_xlat7 * 0.970000029;
    u_xlat12.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat12.xyz, level(0.0)).x;
    u_xlatb12 = u_xlat12.x<u_xlat7;
    u_xlat16_36 = (u_xlatb12) ? Globals._LightShadowData.x : 1.0;
    u_xlat16_36 = half(u_xlat33 + float(u_xlat16_36));
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_35 = min(u_xlat16_35, u_xlat16_36);
    u_xlat16_35 = (u_xlatb1) ? u_xlat16_35 : u_xlat16_36;
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xx).w;
    u_xlat16_0.x = half(u_xlat16_35 * u_xlat16_0.x);
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_9.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_10.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_36 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + (-u_xlat16_5.xyz));
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_35), 0.00100000005));
    u_xlat16_35 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_35 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_37 = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_37 = clamp(u_xlat16_37, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_15 = dot(u_xlat16_9.xyz, u_xlat16_8.xyz);
    u_xlat16_15 = clamp(u_xlat16_15, 0.0h, 1.0h);
    u_xlat16_26 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_26 = dot(half2(u_xlat16_26), half2(u_xlat16_36));
    u_xlat16_26 = half(float(u_xlat16_26) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_37)) + 1.0);
    u_xlat16_16 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_16);
    u_xlat16_5.x = half(float(u_xlat16_26) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_16 = half(-abs(float(u_xlat16_35)) + 1.0);
    u_xlat16_27 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_27);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_27);
    u_xlat16_26 = half(float(u_xlat16_26) * float(u_xlat16_16) + 1.0);
    u_xlat16_26 = half(u_xlat16_26 * u_xlat16_5.x);
    u_xlat16_26 = half(u_xlat16_37 * u_xlat16_26);
    u_xlat16_5.x = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_36 = half((-float(u_xlat16_36)) * float(u_xlat16_36) + 1.0);
    u_xlat16_16 = half(abs(u_xlat16_35) * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_37 * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_35 = half(abs(u_xlat16_35) * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_16 + u_xlat16_35);
    u_xlat16_0.x = half(float(u_xlat16_35) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_35 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_4.x * u_xlat16_35 + (-u_xlat16_4.x));
    u_xlat16_11 = half(float(u_xlat16_36) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_22 = half(float(u_xlat16_35) * 0.318309873);
    u_xlat16_11 = half(float(u_xlat16_11) * float(u_xlat16_11) + 1.00000001e-07);
    u_xlat16_11 = half(u_xlat16_22 / u_xlat16_11);
    u_xlat16_35 = half(u_xlat16_11 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_35) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_0.x);
    u_xlat16_36 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_36!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_35 = half(u_xlat0.x * float(u_xlat16_35));
    u_xlat16_4.xzw = half3(half3(u_xlat16_26) * u_xlat16_10.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_10.xyz * half3(u_xlat16_35));
    u_xlat16_35 = half((-float(u_xlat16_15)) + 1.0);
    u_xlat16_36 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_36);
    u_xlat16_8.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
bool u_xlatb23;
float u_xlat24;
bool u_xlatb24;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
    u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat21 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat22 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat22 = sqrt(u_xlat22);
    u_xlat22 = (-u_xlat21) + u_xlat22;
    u_xlat21 = unity_ShadowFadeCenterAndType.w * u_xlat22 + u_xlat21;
    u_xlat21 = u_xlat21 * _LightShadowData.z + _LightShadowData.w;
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlatb22 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb22){
        u_xlatb23 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb23)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat23 = u_xlat5.y * 0.25 + 0.75;
        u_xlat24 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat23, u_xlat24);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat23 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-_LightPositionRange.xyz);
    u_xlat24 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat24 = sqrt(u_xlat24);
    u_xlat24 = u_xlat24 * _LightPositionRange.w;
    u_xlat24 = u_xlat24 * 0.970000029;
    u_xlat10_5 = textureLod(_ShadowMapTexture, u_xlat5.xyz, 0.0);
    u_xlatb24 = u_xlat10_5.x<u_xlat24;
    u_xlat24 = (u_xlatb24) ? _LightShadowData.x : 1.0;
    u_xlat21 = u_xlat21 + u_xlat24;
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlat23 = min(u_xlat21, u_xlat23);
    u_xlat21 = (u_xlatb22) ? u_xlat23 : u_xlat21;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_4 = texture(_LightTexture0, vec2(u_xlat22));
    u_xlat21 = u_xlat21 * u_xlat10_4.w;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat5.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat21) * _LightColor0.xyz;
    u_xlat21 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat22) + (-u_xlat3.xyz);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = max(u_xlat22, 0.00100000005);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat4.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat22 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat21));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat22) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat21 * u_xlat21;
    u_xlat21 = (-u_xlat21) * u_xlat21 + 1.0;
    u_xlat10 = abs(u_xlat22) * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat23 * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat21 * abs(u_xlat22);
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT SHADOWS_CUBE SHADOWS_SOFT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set CUBE Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTexture0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 64
  Matrix4x4 unity_ProbeVolumeWorldToObject at 144
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _LightPositionRange at 16
  VectorHalf4 unity_OcclusionMaskSelector at 32
  VectorHalf4 _LightShadowData at 40
  Vector4 unity_ShadowFadeCenterAndType at 48
  Vector4 unity_ProbeVolumeParams at 128
  Vector3 unity_ProbeVolumeSizeInv at 208
  Vector3 unity_ProbeVolumeMin at 224
  VectorHalf4 _LightColor0 at 240
  VectorHalf4 _Color at 248
  ScalarHalf _Metallic at 256
  ScalarHalf _Glossiness at 258
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _LightPositionRange;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    bool4 u_xlatb6;
    float u_xlat7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half3 u_xlat16_10;
    half u_xlat16_11;
    float3 u_xlat12;
    bool u_xlatb12;
    half u_xlat16_15;
    half u_xlat16_16;
    float3 u_xlat18;
    half u_xlat16_22;
    float u_xlat23;
    half u_xlat16_26;
    half u_xlat16_27;
    float u_xlat33;
    half u_xlat16_35;
    half u_xlat16_36;
    half u_xlat16_37;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_35 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_35));
    u_xlat16_35 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_4.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD4.xyz);
    u_xlat16_35 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_5.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat33 = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat1.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = (-u_xlat33) + u_xlat1.x;
    u_xlat33 = Globals.unity_ShadowFadeCenterAndType.w * u_xlat1.x + u_xlat33;
    u_xlat33 = u_xlat33 * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat33 = clamp(u_xlat33, 0.0f, 1.0f);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb12 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.xyz = (bool(u_xlatb12)) ? u_xlat6.xyz : input.TEXCOORD5.xyz;
        u_xlat12.xyz = u_xlat12.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat12.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat12.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat23 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat23, u_xlat12.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_35 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_35 = clamp(u_xlat16_35, 0.0h, 1.0h);
    u_xlatb12 = u_xlat33<0.99000001;
    if(u_xlatb12){
        u_xlat12.xyz = input.TEXCOORD5.xyz + (-Globals._LightPositionRange.xyz);
        u_xlat7 = dot(u_xlat12.xyz, u_xlat12.xyz);
        u_xlat7 = sqrt(u_xlat7);
        u_xlat7 = u_xlat7 * Globals._LightPositionRange.w;
        u_xlat7 = u_xlat7 * 0.970000029;
        u_xlat18.xyz = u_xlat12.xyz + float3(0.0078125, 0.0078125, 0.0078125);
        u_xlat6.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xyz, level(0.0)).x;
        u_xlat18.xyz = u_xlat12.xyz + float3(-0.0078125, -0.0078125, 0.0078125);
        u_xlat6.y = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xyz, level(0.0)).x;
        u_xlat18.xyz = u_xlat12.xyz + float3(-0.0078125, 0.0078125, -0.0078125);
        u_xlat6.z = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xyz, level(0.0)).x;
        u_xlat12.xyz = u_xlat12.xyz + float3(0.0078125, -0.0078125, -0.0078125);
        u_xlat6.w = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat12.xyz, level(0.0)).x;
        u_xlatb6 = (u_xlat6<float4(u_xlat7));
        u_xlat6.x = (u_xlatb6.x) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat6.y = (u_xlatb6.y) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat6.z = (u_xlatb6.z) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat6.w = (u_xlatb6.w) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat16_36 = half(dot(u_xlat6, float4(0.25, 0.25, 0.25, 0.25)));
    } else {
        u_xlat16_36 = 1.0;
    }
    u_xlat16_36 = half(u_xlat33 + float(u_xlat16_36));
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_35 = min(u_xlat16_35, u_xlat16_36);
    u_xlat16_35 = (u_xlatb1) ? u_xlat16_35 : u_xlat16_36;
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xx).w;
    u_xlat16_0.x = half(u_xlat16_35 * u_xlat16_0.x);
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_9.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_10.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_36 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + (-u_xlat16_5.xyz));
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_35), 0.00100000005));
    u_xlat16_35 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_35 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_37 = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_37 = clamp(u_xlat16_37, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_15 = dot(u_xlat16_9.xyz, u_xlat16_8.xyz);
    u_xlat16_15 = clamp(u_xlat16_15, 0.0h, 1.0h);
    u_xlat16_26 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_26 = dot(half2(u_xlat16_26), half2(u_xlat16_36));
    u_xlat16_26 = half(float(u_xlat16_26) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_37)) + 1.0);
    u_xlat16_16 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_16);
    u_xlat16_5.x = half(float(u_xlat16_26) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_16 = half(-abs(float(u_xlat16_35)) + 1.0);
    u_xlat16_27 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_27);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_27);
    u_xlat16_26 = half(float(u_xlat16_26) * float(u_xlat16_16) + 1.0);
    u_xlat16_26 = half(u_xlat16_26 * u_xlat16_5.x);
    u_xlat16_26 = half(u_xlat16_37 * u_xlat16_26);
    u_xlat16_5.x = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_36 = half((-float(u_xlat16_36)) * float(u_xlat16_36) + 1.0);
    u_xlat16_16 = half(abs(u_xlat16_35) * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_37 * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_35 = half(abs(u_xlat16_35) * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_16 + u_xlat16_35);
    u_xlat16_0.x = half(float(u_xlat16_35) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_35 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_4.x * u_xlat16_35 + (-u_xlat16_4.x));
    u_xlat16_11 = half(float(u_xlat16_36) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_22 = half(float(u_xlat16_35) * 0.318309873);
    u_xlat16_11 = half(float(u_xlat16_11) * float(u_xlat16_11) + 1.00000001e-07);
    u_xlat16_11 = half(u_xlat16_22 / u_xlat16_11);
    u_xlat16_35 = half(u_xlat16_11 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_35) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_0.x);
    u_xlat16_36 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_36!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_35 = half(u_xlat0.x * float(u_xlat16_35));
    u_xlat16_4.xzw = half3(half3(u_xlat16_26) * u_xlat16_10.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_10.xyz * half3(u_xlat16_35));
    u_xlat16_35 = half((-float(u_xlat16_15)) + 1.0);
    u_xlat16_36 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_36);
    u_xlat16_8.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
bvec4 u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec4 u_xlat10_7;
vec4 u_xlat10_8;
float u_xlat11;
float u_xlat12;
vec3 u_xlat15;
float u_xlat20;
float u_xlat21;
float u_xlat27;
float u_xlat28;
bool u_xlatb28;
float u_xlat29;
bool u_xlatb29;
float u_xlat30;
bool u_xlatb30;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat27 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat27) * u_xlat1.xyz;
    u_xlat27 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat27 = inversesqrt(u_xlat27);
    u_xlat2.xyz = vec3(u_xlat27) * vs_TEXCOORD4.xyz;
    u_xlat27 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat27 = inversesqrt(u_xlat27);
    u_xlat3.xyz = vec3(u_xlat27) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
    u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat27 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat28 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat28 = sqrt(u_xlat28);
    u_xlat28 = (-u_xlat27) + u_xlat28;
    u_xlat27 = unity_ShadowFadeCenterAndType.w * u_xlat28 + u_xlat27;
    u_xlat27 = u_xlat27 * _LightShadowData.z + _LightShadowData.w;
    u_xlat27 = clamp(u_xlat27, 0.0, 1.0);
    u_xlatb28 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb28){
        u_xlatb29 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb29)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat29 = u_xlat5.y * 0.25 + 0.75;
        u_xlat30 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat29, u_xlat30);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat29 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat29 = clamp(u_xlat29, 0.0, 1.0);
    u_xlatb30 = u_xlat27<0.99000001;
    if(u_xlatb30){
        u_xlat5.xyz = vs_TEXCOORD5.xyz + (-_LightPositionRange.xyz);
        u_xlat30 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat30 = sqrt(u_xlat30);
        u_xlat30 = u_xlat30 * _LightPositionRange.w;
        u_xlat30 = u_xlat30 * 0.970000029;
        u_xlat6.xyz = u_xlat5.xyz + vec3(0.0078125, 0.0078125, 0.0078125);
        u_xlat10_6 = textureLod(_ShadowMapTexture, u_xlat6.xyz, 0.0);
        u_xlat15.xyz = u_xlat5.xyz + vec3(-0.0078125, -0.0078125, 0.0078125);
        u_xlat10_7 = textureLod(_ShadowMapTexture, u_xlat15.xyz, 0.0);
        u_xlat15.xyz = u_xlat5.xyz + vec3(-0.0078125, 0.0078125, -0.0078125);
        u_xlat10_8 = textureLod(_ShadowMapTexture, u_xlat15.xyz, 0.0);
        u_xlat5.xyz = u_xlat5.xyz + vec3(0.0078125, -0.0078125, -0.0078125);
        u_xlat5 = textureLod(_ShadowMapTexture, u_xlat5.xyz, 0.0).yzwx;
        u_xlat5.x = u_xlat10_6.x;
        u_xlat5.y = u_xlat10_7.x;
        u_xlat5.z = u_xlat10_8.x;
        u_xlatb5 = lessThan(u_xlat5, vec4(u_xlat30));
        u_xlat5.x = (u_xlatb5.x) ? _LightShadowData.x : float(1.0);
        u_xlat5.y = (u_xlatb5.y) ? _LightShadowData.x : float(1.0);
        u_xlat5.z = (u_xlatb5.z) ? _LightShadowData.x : float(1.0);
        u_xlat5.w = (u_xlatb5.w) ? _LightShadowData.x : float(1.0);
        u_xlat30 = dot(u_xlat5, vec4(0.25, 0.25, 0.25, 0.25));
    } else {
        u_xlat30 = 1.0;
    //ENDIF
    }
    u_xlat27 = u_xlat27 + u_xlat30;
    u_xlat27 = clamp(u_xlat27, 0.0, 1.0);
    u_xlat29 = min(u_xlat27, u_xlat29);
    u_xlat27 = (u_xlatb28) ? u_xlat29 : u_xlat27;
    u_xlat28 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_4 = texture(_LightTexture0, vec2(u_xlat28));
    u_xlat27 = u_xlat27 * u_xlat10_4.w;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat28 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat28 = inversesqrt(u_xlat28);
    u_xlat5.xyz = vec3(u_xlat28) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat27) * _LightColor0.xyz;
    u_xlat27 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat28) + (-u_xlat3.xyz);
    u_xlat28 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat28 = max(u_xlat28, 0.00100000005);
    u_xlat28 = inversesqrt(u_xlat28);
    u_xlat4.xyz = vec3(u_xlat28) * u_xlat4.xyz;
    u_xlat28 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat29 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat29 = clamp(u_xlat29, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat11 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat11 = clamp(u_xlat11, 0.0, 1.0);
    u_xlat20 = u_xlat11 * u_xlat11;
    u_xlat20 = dot(vec2(u_xlat20), vec2(u_xlat27));
    u_xlat20 = u_xlat20 + -0.5;
    u_xlat3.x = (-u_xlat29) + 1.0;
    u_xlat12 = u_xlat3.x * u_xlat3.x;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat3.x = u_xlat3.x * u_xlat12;
    u_xlat3.x = u_xlat20 * u_xlat3.x + 1.0;
    u_xlat12 = -abs(u_xlat28) + 1.0;
    u_xlat21 = u_xlat12 * u_xlat12;
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat12 = u_xlat12 * u_xlat21;
    u_xlat20 = u_xlat20 * u_xlat12 + 1.0;
    u_xlat20 = u_xlat20 * u_xlat3.x;
    u_xlat20 = u_xlat29 * u_xlat20;
    u_xlat3.x = u_xlat27 * u_xlat27;
    u_xlat27 = (-u_xlat27) * u_xlat27 + 1.0;
    u_xlat12 = abs(u_xlat28) * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat29 * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat27 * abs(u_xlat28);
    u_xlat27 = u_xlat29 * u_xlat12 + u_xlat27;
    u_xlat27 = u_xlat27 + 9.99999975e-06;
    u_xlat27 = 0.5 / u_xlat27;
    u_xlat28 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat28 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat28 = u_xlat28 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat28 = u_xlat28 / u_xlat2.x;
    u_xlat27 = u_xlat27 * u_xlat28;
    u_xlat27 = u_xlat27 * 3.14159274;
    u_xlat27 = max(u_xlat27, 9.99999975e-05);
    u_xlat27 = sqrt(u_xlat27);
    u_xlat27 = u_xlat29 * u_xlat27;
    u_xlat28 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb28 = u_xlat28!=0.0;
    u_xlat28 = u_xlatb28 ? 1.0 : float(0.0);
    u_xlat27 = u_xlat27 * u_xlat28;
    u_xlat2.xzw = vec3(u_xlat20) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat27);
    u_xlat27 = (-u_xlat11) + 1.0;
    u_xlat28 = u_xlat27 * u_xlat27;
    u_xlat28 = u_xlat28 * u_xlat28;
    u_xlat27 = u_xlat27 * u_xlat28;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat27) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set CUBE Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set CUBE Texture "_LightTexture0" to slot 3
Set 3D Texture "unity_ProbeVolumeSH" to slot 4

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 64
  Matrix4x4 unity_ProbeVolumeWorldToObject at 144
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _LightPositionRange at 16
  VectorHalf4 unity_OcclusionMaskSelector at 32
  VectorHalf4 _LightShadowData at 40
  Vector4 unity_ShadowFadeCenterAndType at 48
  Vector4 unity_ProbeVolumeParams at 128
  Vector3 unity_ProbeVolumeSizeInv at 208
  Vector3 unity_ProbeVolumeMin at 224
  VectorHalf4 _LightColor0 at 240
  VectorHalf4 _Color at 248
  ScalarHalf _Metallic at 256
  ScalarHalf _Glossiness at 258
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _LightPositionRange;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (3) ]] ,
    sampler sampler_LightTexture0 [[ sampler (3) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (4) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    float u_xlat7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half3 u_xlat16_10;
    half u_xlat16_11;
    float3 u_xlat12;
    bool u_xlatb12;
    half u_xlat16_15;
    half u_xlat16_16;
    half u_xlat16_22;
    float u_xlat23;
    half u_xlat16_26;
    half u_xlat16_27;
    float u_xlat33;
    half u_xlat16_33;
    half u_xlat16_35;
    half u_xlat16_36;
    half u_xlat16_37;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_35 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_35));
    u_xlat16_35 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_4.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD4.xyz);
    u_xlat16_35 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_5.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat33 = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat1.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = (-u_xlat33) + u_xlat1.x;
    u_xlat33 = Globals.unity_ShadowFadeCenterAndType.w * u_xlat1.x + u_xlat33;
    u_xlat33 = u_xlat33 * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat33 = clamp(u_xlat33, 0.0f, 1.0f);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb12 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.xyz = (bool(u_xlatb12)) ? u_xlat6.xyz : input.TEXCOORD5.xyz;
        u_xlat12.xyz = u_xlat12.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat12.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat12.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat23 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat23, u_xlat12.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_35 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_35 = clamp(u_xlat16_35, 0.0h, 1.0h);
    u_xlat12.xyz = input.TEXCOORD5.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat7 = dot(u_xlat12.xyz, u_xlat12.xyz);
    u_xlat7 = sqrt(u_xlat7);
    u_xlat7 = u_xlat7 * Globals._LightPositionRange.w;
    u_xlat7 = u_xlat7 * 0.970000029;
    u_xlat12.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat12.xyz, level(0.0)).x;
    u_xlatb12 = u_xlat12.x<u_xlat7;
    u_xlat16_36 = (u_xlatb12) ? Globals._LightShadowData.x : 1.0;
    u_xlat16_36 = half(u_xlat33 + float(u_xlat16_36));
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_35 = min(u_xlat16_35, u_xlat16_36);
    u_xlat16_35 = (u_xlatb1) ? u_xlat16_35 : u_xlat16_36;
    u_xlat33 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_33 = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat33)).w;
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xyz).w;
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_33);
    u_xlat16_0.x = half(u_xlat16_35 * u_xlat16_0.x);
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_9.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_10.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_36 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + (-u_xlat16_5.xyz));
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_35), 0.00100000005));
    u_xlat16_35 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_35 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_37 = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_37 = clamp(u_xlat16_37, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_15 = dot(u_xlat16_9.xyz, u_xlat16_8.xyz);
    u_xlat16_15 = clamp(u_xlat16_15, 0.0h, 1.0h);
    u_xlat16_26 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_26 = dot(half2(u_xlat16_26), half2(u_xlat16_36));
    u_xlat16_26 = half(float(u_xlat16_26) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_37)) + 1.0);
    u_xlat16_16 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_16);
    u_xlat16_5.x = half(float(u_xlat16_26) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_16 = half(-abs(float(u_xlat16_35)) + 1.0);
    u_xlat16_27 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_27);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_27);
    u_xlat16_26 = half(float(u_xlat16_26) * float(u_xlat16_16) + 1.0);
    u_xlat16_26 = half(u_xlat16_26 * u_xlat16_5.x);
    u_xlat16_26 = half(u_xlat16_37 * u_xlat16_26);
    u_xlat16_5.x = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_36 = half((-float(u_xlat16_36)) * float(u_xlat16_36) + 1.0);
    u_xlat16_16 = half(abs(u_xlat16_35) * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_37 * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_35 = half(abs(u_xlat16_35) * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_16 + u_xlat16_35);
    u_xlat16_0.x = half(float(u_xlat16_35) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_35 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_4.x * u_xlat16_35 + (-u_xlat16_4.x));
    u_xlat16_11 = half(float(u_xlat16_36) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_22 = half(float(u_xlat16_35) * 0.318309873);
    u_xlat16_11 = half(float(u_xlat16_11) * float(u_xlat16_11) + 1.00000001e-07);
    u_xlat16_11 = half(u_xlat16_22 / u_xlat16_11);
    u_xlat16_35 = half(u_xlat16_11 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_35) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_0.x);
    u_xlat16_36 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_36!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_35 = half(u_xlat0.x * float(u_xlat16_35));
    u_xlat16_4.xzw = half3(half3(u_xlat16_26) * u_xlat16_10.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_10.xyz * half3(u_xlat16_35));
    u_xlat16_35 = half((-float(u_xlat16_15)) + 1.0);
    u_xlat16_36 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_36);
    u_xlat16_8.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
float u_xlat21;
float u_xlat22;
float u_xlat16_22;
bool u_xlatb22;
float u_xlat23;
bool u_xlatb23;
float u_xlat24;
bool u_xlatb24;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
    u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat21 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat22 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat22 = sqrt(u_xlat22);
    u_xlat22 = (-u_xlat21) + u_xlat22;
    u_xlat21 = unity_ShadowFadeCenterAndType.w * u_xlat22 + u_xlat21;
    u_xlat21 = u_xlat21 * _LightShadowData.z + _LightShadowData.w;
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlatb22 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb22){
        u_xlatb23 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb23)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat23 = u_xlat5.y * 0.25 + 0.75;
        u_xlat24 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat23, u_xlat24);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat23 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-_LightPositionRange.xyz);
    u_xlat24 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat24 = sqrt(u_xlat24);
    u_xlat24 = u_xlat24 * _LightPositionRange.w;
    u_xlat24 = u_xlat24 * 0.970000029;
    u_xlat10_5 = textureLod(_ShadowMapTexture, u_xlat5.xyz, 0.0);
    u_xlatb24 = u_xlat10_5.x<u_xlat24;
    u_xlat24 = (u_xlatb24) ? _LightShadowData.x : 1.0;
    u_xlat21 = u_xlat21 + u_xlat24;
    u_xlat21 = clamp(u_xlat21, 0.0, 1.0);
    u_xlat23 = min(u_xlat21, u_xlat23);
    u_xlat21 = (u_xlatb22) ? u_xlat23 : u_xlat21;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_5 = texture(_LightTextureB0, vec2(u_xlat22));
    u_xlat10_4 = texture(_LightTexture0, u_xlat4.xyz);
    u_xlat16_22 = u_xlat10_4.w * u_xlat10_5.w;
    u_xlat21 = u_xlat21 * u_xlat16_22;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat5.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat21) * _LightColor0.xyz;
    u_xlat21 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat22) + (-u_xlat3.xyz);
    u_xlat22 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat22 = max(u_xlat22, 0.00100000005);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat4.xyz = vec3(u_xlat22) * u_xlat4.xyz;
    u_xlat22 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat21));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat22) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat21 * u_xlat21;
    u_xlat21 = (-u_xlat21) * u_xlat21 + 1.0;
    u_xlat10 = abs(u_xlat22) * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat23 * u_xlat21 + u_xlat3.x;
    u_xlat21 = u_xlat21 * abs(u_xlat22);
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE SHADOWS_CUBE SHADOWS_SOFT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set CUBE Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set CUBE Texture "_LightTexture0" to slot 3
Set 3D Texture "unity_ProbeVolumeSH" to slot 4

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 64
  Matrix4x4 unity_ProbeVolumeWorldToObject at 144
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _LightPositionRange at 16
  VectorHalf4 unity_OcclusionMaskSelector at 32
  VectorHalf4 _LightShadowData at 40
  Vector4 unity_ShadowFadeCenterAndType at 48
  Vector4 unity_ProbeVolumeParams at 128
  Vector3 unity_ProbeVolumeSizeInv at 208
  Vector3 unity_ProbeVolumeMin at 224
  VectorHalf4 _LightColor0 at 240
  VectorHalf4 _Color at 248
  ScalarHalf _Metallic at 256
  ScalarHalf _Glossiness at 258
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _LightPositionRange;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (3) ]] ,
    sampler sampler_LightTexture0 [[ sampler (3) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (4) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    bool4 u_xlatb6;
    float u_xlat7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half3 u_xlat16_10;
    half u_xlat16_11;
    float3 u_xlat12;
    bool u_xlatb12;
    half u_xlat16_15;
    half u_xlat16_16;
    float3 u_xlat18;
    half u_xlat16_22;
    float u_xlat23;
    half u_xlat16_26;
    half u_xlat16_27;
    float u_xlat33;
    half u_xlat16_33;
    half u_xlat16_35;
    half u_xlat16_36;
    half u_xlat16_37;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_35 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_35));
    u_xlat16_35 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_4.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD4.xyz);
    u_xlat16_35 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_5.xyz = half3(half3(u_xlat16_35) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat33 = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat1.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = (-u_xlat33) + u_xlat1.x;
    u_xlat33 = Globals.unity_ShadowFadeCenterAndType.w * u_xlat1.x + u_xlat33;
    u_xlat33 = u_xlat33 * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat33 = clamp(u_xlat33, 0.0f, 1.0f);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb12 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.xyz = (bool(u_xlatb12)) ? u_xlat6.xyz : input.TEXCOORD5.xyz;
        u_xlat12.xyz = u_xlat12.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat12.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat12.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat23 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat23, u_xlat12.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_35 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_35 = clamp(u_xlat16_35, 0.0h, 1.0h);
    u_xlatb12 = u_xlat33<0.99000001;
    if(u_xlatb12){
        u_xlat12.xyz = input.TEXCOORD5.xyz + (-Globals._LightPositionRange.xyz);
        u_xlat7 = dot(u_xlat12.xyz, u_xlat12.xyz);
        u_xlat7 = sqrt(u_xlat7);
        u_xlat7 = u_xlat7 * Globals._LightPositionRange.w;
        u_xlat7 = u_xlat7 * 0.970000029;
        u_xlat18.xyz = u_xlat12.xyz + float3(0.0078125, 0.0078125, 0.0078125);
        u_xlat6.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xyz, level(0.0)).x;
        u_xlat18.xyz = u_xlat12.xyz + float3(-0.0078125, -0.0078125, 0.0078125);
        u_xlat6.y = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xyz, level(0.0)).x;
        u_xlat18.xyz = u_xlat12.xyz + float3(-0.0078125, 0.0078125, -0.0078125);
        u_xlat6.z = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xyz, level(0.0)).x;
        u_xlat12.xyz = u_xlat12.xyz + float3(0.0078125, -0.0078125, -0.0078125);
        u_xlat6.w = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat12.xyz, level(0.0)).x;
        u_xlatb6 = (u_xlat6<float4(u_xlat7));
        u_xlat6.x = (u_xlatb6.x) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat6.y = (u_xlatb6.y) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat6.z = (u_xlatb6.z) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat6.w = (u_xlatb6.w) ? float(Globals._LightShadowData.x) : float(1.0);
        u_xlat16_36 = half(dot(u_xlat6, float4(0.25, 0.25, 0.25, 0.25)));
    } else {
        u_xlat16_36 = 1.0;
    }
    u_xlat16_36 = half(u_xlat33 + float(u_xlat16_36));
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_35 = min(u_xlat16_35, u_xlat16_36);
    u_xlat16_35 = (u_xlatb1) ? u_xlat16_35 : u_xlat16_36;
    u_xlat33 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_33 = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat33)).w;
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xyz).w;
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_33);
    u_xlat16_0.x = half(u_xlat16_35 * u_xlat16_0.x);
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_35 = rsqrt(u_xlat16_35);
    u_xlat16_9.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_10.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_36 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + (-u_xlat16_5.xyz));
    u_xlat16_35 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_35), 0.00100000005));
    u_xlat16_35 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_35) * u_xlat16_8.xyz);
    u_xlat16_35 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_37 = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_37 = clamp(u_xlat16_37, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_15 = dot(u_xlat16_9.xyz, u_xlat16_8.xyz);
    u_xlat16_15 = clamp(u_xlat16_15, 0.0h, 1.0h);
    u_xlat16_26 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_26 = dot(half2(u_xlat16_26), half2(u_xlat16_36));
    u_xlat16_26 = half(float(u_xlat16_26) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_37)) + 1.0);
    u_xlat16_16 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_16);
    u_xlat16_5.x = half(float(u_xlat16_26) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_16 = half(-abs(float(u_xlat16_35)) + 1.0);
    u_xlat16_27 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_27);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_27);
    u_xlat16_26 = half(float(u_xlat16_26) * float(u_xlat16_16) + 1.0);
    u_xlat16_26 = half(u_xlat16_26 * u_xlat16_5.x);
    u_xlat16_26 = half(u_xlat16_37 * u_xlat16_26);
    u_xlat16_5.x = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_36 = half((-float(u_xlat16_36)) * float(u_xlat16_36) + 1.0);
    u_xlat16_16 = half(abs(u_xlat16_35) * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_37 * u_xlat16_36 + u_xlat16_5.x);
    u_xlat16_35 = half(abs(u_xlat16_35) * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_16 + u_xlat16_35);
    u_xlat16_0.x = half(float(u_xlat16_35) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_35 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_36 = half(u_xlat16_4.x * u_xlat16_35 + (-u_xlat16_4.x));
    u_xlat16_11 = half(float(u_xlat16_36) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_22 = half(float(u_xlat16_35) * 0.318309873);
    u_xlat16_11 = half(float(u_xlat16_11) * float(u_xlat16_11) + 1.00000001e-07);
    u_xlat16_11 = half(u_xlat16_22 / u_xlat16_11);
    u_xlat16_35 = half(u_xlat16_11 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_35) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_35 = half(u_xlat16_37 * u_xlat16_0.x);
    u_xlat16_36 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_36!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_35 = half(u_xlat0.x * float(u_xlat16_35));
    u_xlat16_4.xzw = half3(half3(u_xlat16_26) * u_xlat16_10.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_10.xyz * half3(u_xlat16_35));
    u_xlat16_35 = half((-float(u_xlat16_15)) + 1.0);
    u_xlat16_36 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_36);
    u_xlat16_8.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_35) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bvec4 u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec4 u_xlat10_7;
vec4 u_xlat10_8;
float u_xlat11;
float u_xlat12;
vec3 u_xlat15;
float u_xlat20;
float u_xlat21;
float u_xlat27;
float u_xlat28;
float u_xlat16_28;
bool u_xlatb28;
float u_xlat29;
bool u_xlatb29;
float u_xlat30;
bool u_xlatb30;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat27 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat27) * u_xlat1.xyz;
    u_xlat27 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat27 = inversesqrt(u_xlat27);
    u_xlat2.xyz = vec3(u_xlat27) * vs_TEXCOORD4.xyz;
    u_xlat27 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat27 = inversesqrt(u_xlat27);
    u_xlat3.xyz = vec3(u_xlat27) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
    u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat27 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat28 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat28 = sqrt(u_xlat28);
    u_xlat28 = (-u_xlat27) + u_xlat28;
    u_xlat27 = unity_ShadowFadeCenterAndType.w * u_xlat28 + u_xlat27;
    u_xlat27 = u_xlat27 * _LightShadowData.z + _LightShadowData.w;
    u_xlat27 = clamp(u_xlat27, 0.0, 1.0);
    u_xlatb28 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb28){
        u_xlatb29 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb29)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat29 = u_xlat5.y * 0.25 + 0.75;
        u_xlat30 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat29, u_xlat30);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat29 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat29 = clamp(u_xlat29, 0.0, 1.0);
    u_xlatb30 = u_xlat27<0.99000001;
    if(u_xlatb30){
        u_xlat5.xyz = vs_TEXCOORD5.xyz + (-_LightPositionRange.xyz);
        u_xlat30 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat30 = sqrt(u_xlat30);
        u_xlat30 = u_xlat30 * _LightPositionRange.w;
        u_xlat30 = u_xlat30 * 0.970000029;
        u_xlat6.xyz = u_xlat5.xyz + vec3(0.0078125, 0.0078125, 0.0078125);
        u_xlat10_6 = textureLod(_ShadowMapTexture, u_xlat6.xyz, 0.0);
        u_xlat15.xyz = u_xlat5.xyz + vec3(-0.0078125, -0.0078125, 0.0078125);
        u_xlat10_7 = textureLod(_ShadowMapTexture, u_xlat15.xyz, 0.0);
        u_xlat15.xyz = u_xlat5.xyz + vec3(-0.0078125, 0.0078125, -0.0078125);
        u_xlat10_8 = textureLod(_ShadowMapTexture, u_xlat15.xyz, 0.0);
        u_xlat5.xyz = u_xlat5.xyz + vec3(0.0078125, -0.0078125, -0.0078125);
        u_xlat5 = textureLod(_ShadowMapTexture, u_xlat5.xyz, 0.0).yzwx;
        u_xlat5.x = u_xlat10_6.x;
        u_xlat5.y = u_xlat10_7.x;
        u_xlat5.z = u_xlat10_8.x;
        u_xlatb5 = lessThan(u_xlat5, vec4(u_xlat30));
        u_xlat5.x = (u_xlatb5.x) ? _LightShadowData.x : float(1.0);
        u_xlat5.y = (u_xlatb5.y) ? _LightShadowData.x : float(1.0);
        u_xlat5.z = (u_xlatb5.z) ? _LightShadowData.x : float(1.0);
        u_xlat5.w = (u_xlatb5.w) ? _LightShadowData.x : float(1.0);
        u_xlat30 = dot(u_xlat5, vec4(0.25, 0.25, 0.25, 0.25));
    } else {
        u_xlat30 = 1.0;
    //ENDIF
    }
    u_xlat27 = u_xlat27 + u_xlat30;
    u_xlat27 = clamp(u_xlat27, 0.0, 1.0);
    u_xlat29 = min(u_xlat27, u_xlat29);
    u_xlat27 = (u_xlatb28) ? u_xlat29 : u_xlat27;
    u_xlat28 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_5 = texture(_LightTextureB0, vec2(u_xlat28));
    u_xlat10_4 = texture(_LightTexture0, u_xlat4.xyz);
    u_xlat16_28 = u_xlat10_4.w * u_xlat10_5.w;
    u_xlat27 = u_xlat27 * u_xlat16_28;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat28 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat28 = inversesqrt(u_xlat28);
    u_xlat5.xyz = vec3(u_xlat28) * u_xlat4.xyz;
    u_xlat6.xyz = vec3(u_xlat27) * _LightColor0.xyz;
    u_xlat27 = (-_Glossiness) + 1.0;
    u_xlat4.xyz = u_xlat4.xyz * vec3(u_xlat28) + (-u_xlat3.xyz);
    u_xlat28 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat28 = max(u_xlat28, 0.00100000005);
    u_xlat28 = inversesqrt(u_xlat28);
    u_xlat4.xyz = vec3(u_xlat28) * u_xlat4.xyz;
    u_xlat28 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat29 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat29 = clamp(u_xlat29, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat4.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat11 = dot(u_xlat5.xyz, u_xlat4.xyz);
    u_xlat11 = clamp(u_xlat11, 0.0, 1.0);
    u_xlat20 = u_xlat11 * u_xlat11;
    u_xlat20 = dot(vec2(u_xlat20), vec2(u_xlat27));
    u_xlat20 = u_xlat20 + -0.5;
    u_xlat3.x = (-u_xlat29) + 1.0;
    u_xlat12 = u_xlat3.x * u_xlat3.x;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat3.x = u_xlat3.x * u_xlat12;
    u_xlat3.x = u_xlat20 * u_xlat3.x + 1.0;
    u_xlat12 = -abs(u_xlat28) + 1.0;
    u_xlat21 = u_xlat12 * u_xlat12;
    u_xlat21 = u_xlat21 * u_xlat21;
    u_xlat12 = u_xlat12 * u_xlat21;
    u_xlat20 = u_xlat20 * u_xlat12 + 1.0;
    u_xlat20 = u_xlat20 * u_xlat3.x;
    u_xlat20 = u_xlat29 * u_xlat20;
    u_xlat3.x = u_xlat27 * u_xlat27;
    u_xlat27 = (-u_xlat27) * u_xlat27 + 1.0;
    u_xlat12 = abs(u_xlat28) * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat29 * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat27 * abs(u_xlat28);
    u_xlat27 = u_xlat29 * u_xlat12 + u_xlat27;
    u_xlat27 = u_xlat27 + 9.99999975e-06;
    u_xlat27 = 0.5 / u_xlat27;
    u_xlat28 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat28 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat28 = u_xlat28 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat28 = u_xlat28 / u_xlat2.x;
    u_xlat27 = u_xlat27 * u_xlat28;
    u_xlat27 = u_xlat27 * 3.14159274;
    u_xlat27 = max(u_xlat27, 9.99999975e-05);
    u_xlat27 = sqrt(u_xlat27);
    u_xlat27 = u_xlat29 * u_xlat27;
    u_xlat28 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb28 = u_xlat28!=0.0;
    u_xlat28 = u_xlatb28 ? 1.0 : float(0.0);
    u_xlat27 = u_xlat27 * u_xlat28;
    u_xlat2.xzw = vec3(u_xlat20) * u_xlat6.xyz;
    u_xlat3.xyz = u_xlat6.xyz * vec3(u_xlat27);
    u_xlat27 = (-u_xlat11) + 1.0;
    u_xlat28 = u_xlat27 * u_xlat27;
    u_xlat28 = u_xlat28 * u_xlat28;
    u_xlat27 = u_xlat27 * u_xlat28;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat27) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "SHADOWCASTER"
  Tags { "LIGHTMODE"="SHADOWCASTER" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector4 _WorldSpaceLightPos0 at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat1;
    u_xlat2.xyz = (-u_xlat1.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * Globals.unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat0.xyz) * float3(u_xlat9) + u_xlat1.xyz;
    u_xlatb9 = Globals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat2;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat2;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat1.wwww + u_xlat0;
    u_xlat1.x = Globals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = Globals.unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return output;
}


-- Fragment shader for "metal":
Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
)
{
    Mtl_FragmentOut output;
    output.SV_Target0 = half4(0.0, 0.0, 0.0, 0.0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_LightShadowBias;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
vec4 u_xlat0;
vec4 u_xlat1;
vec4 u_xlat2;
float u_xlat6;
float u_xlat9;
bool u_xlatb9;
void main()
{
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat1;
    u_xlat2.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat2.xyz = vec3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat0.xyz) * vec3(u_xlat9) + u_xlat1.xyz;
    u_xlatb9 = unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat2;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat2;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat1.wwww + u_xlat0;
    u_xlat1.x = unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = clamp(u_xlat1.x, 0.0, 1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = max((-u_xlat0.w), u_xlat6);
    gl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    gl_Position.z = unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

layout(location = 0) out vec4 SV_Target0;
void main()
{
    SV_Target0 = vec4(0.0, 0.0, 0.0, 0.0);
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"

Constant Buffer "Globals" (144 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 16
  Matrix4x4 unity_MatrixVP at 80
  Vector4 _LightPositionRange at 0
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};

struct Mtl_VertexOut
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    output.TEXCOORD0.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    return output;
}


-- Fragment shader for "metal":
Constant Buffer "Globals" (32 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 unity_LightShadowBias;
};

struct Mtl_FragmentIn
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    u_xlat0.x = dot(input.TEXCOORD0.xyz, input.TEXCOORD0.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x + Globals.unity_LightShadowBias.x;
    u_xlat0 = u_xlat0.xxxx * Globals._LightPositionRange.wwww;
    output.SV_Target0 = half4(u_xlat0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
in  vec4 in_POSITION0;
out vec3 vs_TEXCOORD0;
vec4 u_xlat0;
vec4 u_xlat1;
void main()
{
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD0.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_LightShadowBias;
in  vec3 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
float u_xlat0;
void main()
{
    u_xlat0 = dot(vs_TEXCOORD0.xyz, vs_TEXCOORD0.xyz);
    u_xlat0 = sqrt(u_xlat0);
    u_xlat0 = u_xlat0 + unity_LightShadowBias.x;
    SV_Target0 = vec4(u_xlat0) * _LightPositionRange.wwww;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "DEFERRED"
  Tags { "LIGHTMODE"="DEFERRED" "RenderType"="Opaque" "PerformanceChecks"="False" }
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
No keywords set in this variant.
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat0.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    float4 u_xlat3;
    half3 u_xlat16_3;
    bool u_xlatb3;
    float4 u_xlat4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_9;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_9.x = input.TEXCOORD2.w;
        u_xlat16_9.y = input.TEXCOORD3.w;
        u_xlat16_9.z = input.TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : float3(u_xlat16_9.xyz);
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat3 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat2 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(u_xlat3, float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(u_xlat4, float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(u_xlat2, float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
vec4 u_xlat10_3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat7;
vec3 u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.x = vs_TEXCOORD2.w;
        u_xlat8.y = vs_TEXCOORD3.w;
        u_xlat8.z = vs_TEXCOORD4.w;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : u_xlat8.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8.x, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: UNITY_HDR_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat0.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    float4 u_xlat3;
    half3 u_xlat16_3;
    bool u_xlatb3;
    float4 u_xlat4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_9;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_9.x = input.TEXCOORD2.w;
        u_xlat16_9.y = input.TEXCOORD3.w;
        u_xlat16_9.z = input.TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : float3(u_xlat16_9.xyz);
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat3 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat2 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(u_xlat3, float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(u_xlat4, float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(u_xlat2, float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
vec4 u_xlat10_3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat7;
vec3 u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.x = vs_TEXCOORD2.w;
        u_xlat8.y = vs_TEXCOORD3.w;
        u_xlat8.z = vs_TEXCOORD4.w;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : u_xlat8.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8.x, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat0.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    float4 u_xlat3;
    half3 u_xlat16_3;
    bool u_xlatb3;
    float4 u_xlat4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_9;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_9.x = input.TEXCOORD2.w;
        u_xlat16_9.y = input.TEXCOORD3.w;
        u_xlat16_9.z = input.TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : float3(u_xlat16_9.xyz);
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat3 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat2 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(u_xlat3, float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(u_xlat4, float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(u_xlat2, float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
vec4 u_xlat10_3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat7;
vec3 u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.x = vs_TEXCOORD2.w;
        u_xlat8.y = vs_TEXCOORD3.w;
        u_xlat8.z = vs_TEXCOORD4.w;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : u_xlat8.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8.x, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: _EMISSION UNITY_HDR_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat0.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    float4 u_xlat3;
    half3 u_xlat16_3;
    bool u_xlatb3;
    float4 u_xlat4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_9;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_9.x = input.TEXCOORD2.w;
        u_xlat16_9.y = input.TEXCOORD3.w;
        u_xlat16_9.z = input.TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : float3(u_xlat16_9.xyz);
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat3 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat2 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(u_xlat3, float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(u_xlat4, float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(u_xlat2, float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
vec4 u_xlat10_3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat7;
vec3 u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.x = vs_TEXCOORD2.w;
        u_xlat8.y = vs_TEXCOORD3.w;
        u_xlat8.z = vs_TEXCOORD4.w;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : u_xlat8.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8.x, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
}
SubShader { 
 LOD 150
 Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }
 Pass {
  Name "FORWARD"
  Tags { "LIGHTMODE"="FORWARDBASE" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite [_ZWrite]
  Blend [_SrcBlend] [_DstBlend]
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (306 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Matrix4x4 unity_MatrixVP at 208
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHAr at 16
  VectorHalf4 unity_SHAg at 24
  VectorHalf4 unity_SHAb at 32
  VectorHalf4 unity_SHBr at 40
  VectorHalf4 unity_SHBg at 48
  VectorHalf4 unity_SHBb at 56
  VectorHalf4 unity_SHC at 64
  Vector4 _MainTex_ST at 272
  Vector4 _DetailAlbedoMap_ST at 288
  ScalarHalf _UVSec at 304
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1 = float4(u_xlat13) * u_xlat1.xyzz;
    u_xlat0.xyz = u_xlat1.xyw;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2.x = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2.x = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2.x)));
    u_xlat16_1 = half4(u_xlat1.ywzx * u_xlat1);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_1);
    u_xlat16_2.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    u_xlat0.w = 1.0;
    u_xlat16_3.x = half(dot(float4(Globals.unity_SHAr), u_xlat0));
    u_xlat16_3.y = half(dot(float4(Globals.unity_SHAg), u_xlat0));
    u_xlat16_3.z = half(dot(float4(Globals.unity_SHAb), u_xlat0));
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_2.xyz = half3(max(float3(u_xlat16_2.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat0.xyz = log2(float3(u_xlat16_2.xyz));
    u_xlat0.xyz = u_xlat0.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = max(u_xlat0.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2
Set CUBE Texture "unity_SpecCube0" to slot 3
Set 3D Texture "unity_ProbeVolumeSH" to slot 4

Constant Buffer "Globals" (164 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_OcclusionMaskSelector at 8
  VectorHalf4 unity_SpecCube0_HDR at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _LightColor0 at 144
  VectorHalf4 _Color at 152
  ScalarHalf _Metallic at 160
  ScalarHalf _Glossiness at 162
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_OcclusionMaskSelector;
    half4 unity_SpecCube0_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (3) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (4) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float u_xlat1;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half4 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_14;
    half3 u_xlat16_15;
    half u_xlat16_32;
    half u_xlat16_33;
    half u_xlat16_34;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_32 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_32));
    u_xlat16_33 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_33 = rsqrt(u_xlat16_33);
    u_xlat16_4.xyz = half3(half3(u_xlat16_33) * input.TEXCOORD4.xyz);
    u_xlatb0 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb0){
        u_xlatb0 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_15.x = input.TEXCOORD2.w;
        u_xlat16_15.y = input.TEXCOORD3.w;
        u_xlat16_15.z = input.TEXCOORD4.w;
        u_xlat0.xyz = (bool(u_xlatb0)) ? u_xlat10.xyz : float3(u_xlat16_15.xyz);
        u_xlat0.xyz = u_xlat0.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat0.yzw = u_xlat0.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat10.x = u_xlat0.y * 0.25 + 0.75;
        u_xlat1 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat0.x = max(u_xlat10.x, u_xlat1);
        u_xlat0 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat0.xzw);
        u_xlat16_0 = half4(u_xlat0);
    } else {
        u_xlat16_0.x = half(1.0);
        u_xlat16_0.y = half(1.0);
        u_xlat16_0.z = half(1.0);
        u_xlat16_0.w = half(1.0);
    }
    u_xlat16_33 = dot(u_xlat16_0, Globals.unity_OcclusionMaskSelector);
    u_xlat16_33 = clamp(u_xlat16_33, 0.0h, 1.0h);
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_0.xw = half2((-float2(Globals._Glossiness)) + float2(1.0, 1.0));
    u_xlat16_34 = dot(input.TEXCOORD1.xyz, u_xlat16_4.xyz);
    u_xlat16_34 = half(u_xlat16_34 + u_xlat16_34);
    u_xlat16_5.xyz = half3(u_xlat16_4.xyz * (-half3(u_xlat16_34)) + input.TEXCOORD1.xyz);
    u_xlat16_6.xyz = half3(half3(u_xlat16_33) * Globals._LightColor0.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD5.xyz);
    u_xlat16_33 = half((-float(u_xlat16_0.x)) * 0.699999988 + 1.70000005);
    u_xlat16_33 = half(u_xlat16_0.x * u_xlat16_33);
    u_xlat16_33 = half(float(u_xlat16_33) * 6.0);
    u_xlat16_5 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_5.xyz), level(float(u_xlat16_33)));
    u_xlat16_33 = half(float(u_xlat16_5.w) + -1.0);
    u_xlat16_33 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_33) + 1.0);
    u_xlat16_33 = half(u_xlat16_33 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_8.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_33));
    u_xlat16_8.xyz = half3(u_xlat16_1.xxx * u_xlat16_8.xyz);
    u_xlat16_33 = dot((-input.TEXCOORD1.xyz), u_xlat16_4.xyz);
    u_xlat16_34 = half(u_xlat16_33 + u_xlat16_33);
    u_xlat16_9.xyz = half3(u_xlat16_4.xyz * (-half3(u_xlat16_34)) + (-input.TEXCOORD1.xyz));
    u_xlat16_4.x = dot(u_xlat16_4.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_33 = u_xlat16_33;
    u_xlat16_33 = clamp(u_xlat16_33, 0.0h, 1.0h);
    u_xlat16_9.x = dot(u_xlat16_9.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_9.y = half((-float(u_xlat16_33)) + 1.0);
    u_xlat16_14.xy = half2(u_xlat16_9.xy * u_xlat16_9.xy);
    u_xlat16_0.yz = half2(u_xlat16_14.xy * u_xlat16_14.xy);
    u_xlat16_32 = half((-u_xlat16_32) + Globals._Glossiness);
    u_xlat16_32 = half(float(u_xlat16_32) + 1.0);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlat16_1.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_0.yw)).w;
    u_xlat16_1.x = half(float(u_xlat16_1.x) * 16.0);
    u_xlat16_14.xyz = half3(u_xlat16_1.xxx * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_4.xxx * u_xlat16_6.xyz);
    u_xlat16_9.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_32));
    u_xlat16_2.xyz = half3(u_xlat16_0.zzz * u_xlat16_9.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_8.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_7.xyz * u_xlat16_3.xyz + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_14.xyz * u_xlat16_6.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
float u_xlat12;
float u_xlat13;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    vs_TEXCOORD1.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = inversesqrt(u_xlat12);
    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = u_xlat0.x * u_xlat0.x + (-u_xlat1.x);
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat1.xyz = unity_SHC.xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(unity_SHAr, u_xlat0);
    u_xlat2.y = dot(unity_SHAg, u_xlat0);
    u_xlat2.z = dot(unity_SHAb, u_xlat0);
    u_xlat0.xyz = u_xlat1.xyz + u_xlat2.xyz;
    u_xlat0.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    vs_TEXCOORD5.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  samplerCube unity_SpecCube0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
vec3 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat10;
vec3 u_xlat12;
float u_xlat24;
float u_xlat25;
float u_xlat16_25;
bool u_xlatb25;
float u_xlat26;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat24 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat24) * u_xlat1.xyz;
    u_xlat25 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat25 = inversesqrt(u_xlat25);
    u_xlat2.xyz = vec3(u_xlat25) * vs_TEXCOORD4.xyz;
    u_xlatb25 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb25){
        u_xlatb25 = unity_ProbeVolumeParams.y==1.0;
        u_xlat3.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat3.xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat3.xyz;
        u_xlat3.xyz = u_xlat3.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.x = vs_TEXCOORD2.w;
        u_xlat12.y = vs_TEXCOORD3.w;
        u_xlat12.z = vs_TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb25)) ? u_xlat3.xyz : u_xlat12.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat3.yzw = u_xlat3.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat25 = u_xlat3.y * 0.25 + 0.75;
        u_xlat26 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat3.x = max(u_xlat25, u_xlat26);
        u_xlat3 = texture(unity_ProbeVolumeSH, u_xlat3.xzw);
    } else {
        u_xlat3.x = float(1.0);
        u_xlat3.y = float(1.0);
        u_xlat3.z = float(1.0);
        u_xlat3.w = float(1.0);
    //ENDIF
    }
    u_xlat25 = dot(u_xlat3, unity_OcclusionMaskSelector);
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat4.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat26 = dot(vs_TEXCOORD1.xyz, u_xlat2.xyz);
    u_xlat26 = u_xlat26 + u_xlat26;
    u_xlat3.xzw = u_xlat2.xyz * (-vec3(u_xlat26)) + vs_TEXCOORD1.xyz;
    u_xlat5.xyz = vec3(u_xlat25) * _LightColor0.xyz;
    u_xlat6.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat25 = (-u_xlat4.x) * 0.699999988 + 1.70000005;
    u_xlat25 = u_xlat25 * u_xlat4.x;
    u_xlat25 = u_xlat25 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat3.xzw, u_xlat25);
    u_xlat16_25 = u_xlat10_7.w + -1.0;
    u_xlat25 = unity_SpecCube0_HDR.w * u_xlat16_25 + 1.0;
    u_xlat25 = u_xlat25 * unity_SpecCube0_HDR.x;
    u_xlat3.xzw = u_xlat10_7.xyz * vec3(u_xlat25);
    u_xlat3.xyz = u_xlat10_3.yyy * u_xlat3.xzw;
    u_xlat25 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat26 = u_xlat25 + u_xlat25;
    u_xlat7.xyz = u_xlat2.xyz * (-vec3(u_xlat26)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat25 = u_xlat25;
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat7.x = dot(u_xlat7.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat7.y = (-u_xlat25) + 1.0;
    u_xlat10.xy = u_xlat7.xy * u_xlat7.xy;
    u_xlat4.yz = u_xlat10.xy * u_xlat10.xy;
    u_xlat24 = (-u_xlat24) + _Glossiness;
    u_xlat24 = u_xlat24 + 1.0;
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat10_7 = texture(unity_NHxRoughness, u_xlat4.yw);
    u_xlat16_25 = u_xlat10_7.w * 16.0;
    u_xlat10.xyz = vec3(u_xlat16_25) * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat4.xyw = u_xlat2.xxx * u_xlat5.xyz;
    u_xlat5.xyz = (-u_xlat0.xyz) + vec3(u_xlat24);
    u_xlat0.xyz = u_xlat4.zzz * u_xlat5.xyz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    u_xlat0.xyz = u_xlat6.xyz * u_xlat1.xyz + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat10.xyz * u_xlat4.xyw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 64
  Matrix4x4 unity_WorldToObject at 128
  Matrix4x4 unity_MatrixVP at 192
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHBr at 32
  VectorHalf4 unity_SHBg at 40
  VectorHalf4 unity_SHBb at 48
  VectorHalf4 unity_SHC at 56
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    float4 u_xlat2;
    half u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat17;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat17 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat17 = rsqrt(u_xlat17);
    u_xlat1.xyz = float3(u_xlat17) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat16_3 = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3 = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_1);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_3) + u_xlat16_4.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat2.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat2.zz + u_xlat2.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set CUBE Texture "unity_SpecCube0" to slot 3
Set CUBE Texture "unity_SpecCube1" to slot 4
Set 3D Texture "unity_ProbeVolumeSH" to slot 5

Constant Buffer "Globals" (406 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 80
  Matrix4x4 unity_ProbeVolumeWorldToObject at 288
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  VectorHalf4 unity_SHAr at 24
  VectorHalf4 unity_SHAg at 32
  VectorHalf4 unity_SHAb at 40
  VectorHalf4 unity_OcclusionMaskSelector at 48
  VectorHalf4 _LightShadowData at 56
  Vector4 unity_ShadowFadeCenterAndType at 64
  Vector4 unity_SpecCube0_BoxMax at 144
  Vector4 unity_SpecCube0_BoxMin at 160
  Vector4 unity_SpecCube0_ProbePosition at 176
  VectorHalf4 unity_SpecCube0_HDR at 192
  Vector4 unity_SpecCube1_BoxMax at 208
  Vector4 unity_SpecCube1_BoxMin at 224
  Vector4 unity_SpecCube1_ProbePosition at 240
  VectorHalf4 unity_SpecCube1_HDR at 256
  Vector4 unity_ProbeVolumeParams at 272
  Vector3 unity_ProbeVolumeSizeInv at 352
  Vector3 unity_ProbeVolumeMin at 368
  VectorHalf4 _LightColor0 at 384
  VectorHalf4 _Color at 392
  ScalarHalf _Metallic at 400
  ScalarHalf _Glossiness at 402
  ScalarHalf _OcclusionStrength at 404
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (3) ]] ,
    texturecube<half, access::sample > unity_SpecCube1 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (4) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (5) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    half4 u_xlat16_7;
    half3 u_xlat16_8;
    float4 u_xlat9;
    half4 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    half3 u_xlat16_11;
    float3 u_xlat12;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    bool3 u_xlatb14;
    half3 u_xlat16_15;
    float3 u_xlat17;
    bool u_xlatb17;
    half3 u_xlat16_20;
    float3 u_xlat23;
    half3 u_xlat16_23;
    float u_xlat25;
    half u_xlat16_27;
    float2 u_xlat33;
    half u_xlat16_33;
    bool u_xlatb33;
    half u_xlat16_36;
    half u_xlat16_39;
    float u_xlat49;
    half u_xlat16_49;
    bool u_xlatb49;
    half u_xlat16_50;
    half u_xlat16_51;
    half u_xlat16_52;
    half u_xlat16_53;
    half u_xlat16_55;
    half u_xlat16_56;
    half u_xlat16_58;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_50 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_50));
    u_xlat16_51 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_0.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD4.xyz);
    u_xlat16_51 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_4.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD1.xyz);
    u_xlat16_5.x = input.TEXCOORD2.w;
    u_xlat16_5.y = input.TEXCOORD3.w;
    u_xlat16_5.z = input.TEXCOORD4.w;
    u_xlat1.xyz = (-float3(u_xlat16_5.xyz)) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat17.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat17.x = dot(u_xlat17.xyz, u_xlat17.xyz);
    u_xlat17.x = sqrt(u_xlat17.x);
    u_xlat17.x = (-u_xlat1.x) + u_xlat17.x;
    u_xlat1.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat17.x + u_xlat1.x;
    u_xlat1.x = u_xlat1.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat1.x = clamp(u_xlat1.x, 0.0f, 1.0f);
    u_xlatb17 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb17){
        u_xlatb33 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb33)) ? u_xlat6.xyz : float3(u_xlat16_5.xyz);
        u_xlat6.xyz = u_xlat6.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat6.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat33.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat49 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat49, u_xlat33.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_52 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_52 = clamp(u_xlat16_52, 0.0h, 1.0h);
    u_xlat33.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_33 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat33.xy).x;
    u_xlat16_53 = half(u_xlat1.x + float(u_xlat16_33));
    u_xlat16_53 = clamp(u_xlat16_53, 0.0h, 1.0h);
    u_xlat16_52 = min(u_xlat16_52, u_xlat16_53);
    u_xlat16_52 = (u_xlatb17) ? u_xlat16_52 : u_xlat16_53;
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_53 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_53 = half(u_xlat16_1.x * Globals._OcclusionStrength + u_xlat16_53);
    u_xlat16_7.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_23.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_23.x = half(u_xlat16_23.x + u_xlat16_23.x);
    u_xlat16_23.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_23.xxx) + u_xlat16_4.xyz);
    u_xlat16_8.xyz = half3(half3(u_xlat16_52) * Globals._LightColor0.xyz);
    if(u_xlatb17){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat17.xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat17.xyz : float3(u_xlat16_5.xyz);
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat17.x = u_xlat1.y * 0.25;
        u_xlat9.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat25 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat9.x);
        u_xlat1.x = min(u_xlat25, u_xlat17.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat9.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat9 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz);
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = half(dot(u_xlat6, float4(u_xlat16_0)));
        u_xlat16_10.y = half(dot(u_xlat9, float4(u_xlat16_0)));
        u_xlat16_10.z = half(dot(u_xlat1, float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_10.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_10.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_10.xyz = half3(u_xlat16_10.xyz + input.TEXCOORD5.xyz);
    u_xlat16_10.xyz = half3(max(float3(u_xlat16_10.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_10.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb49 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb49){
        u_xlat16_52 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
        u_xlat16_52 = rsqrt(u_xlat16_52);
        u_xlat16_10.xyz = half3(half3(u_xlat16_52) * u_xlat16_23.xyz);
        u_xlat9.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_10.xyz);
        u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_10.xyz);
        u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_10.xyz));
        u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat9.x) : half(u_xlat11.x);
        u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat9.y) : half(u_xlat11.y);
        u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat9.z) : half(u_xlat11.z);
        u_xlat16_52 = min(u_xlat16_13.y, u_xlat16_13.x);
        u_xlat16_52 = min(u_xlat16_13.z, u_xlat16_52);
        u_xlat9.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = float3(u_xlat16_10.xyz) * float3(u_xlat16_52) + u_xlat9.xyz;
        u_xlat16_9.xyz = half3(u_xlat9.xyz);
    } else {
        u_xlat16_9.xyz = u_xlat16_23.xyz;
    }
    u_xlat16_52 = half((-float(u_xlat16_7.x)) * 0.699999988 + 1.70000005);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_7.x);
    u_xlat16_52 = half(float(u_xlat16_52) * 6.0);
    u_xlat16_6 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_9.xyz), level(float(u_xlat16_52)));
    u_xlat16_56 = half(float(u_xlat16_6.w) + -1.0);
    u_xlat16_56 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_56) + 1.0);
    u_xlat16_56 = half(u_xlat16_56 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_10.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_56));
    u_xlatb49 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat16_58 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
            u_xlat16_58 = rsqrt(u_xlat16_58);
            u_xlat16_13.xyz = half3(u_xlat16_23.xyz * half3(u_xlat16_58));
            u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_13.xyz);
            u_xlat12.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat12.xyz = u_xlat12.xyz / float3(u_xlat16_13.xyz);
            u_xlatb14.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_13.xyz));
            u_xlat16_15.x = (u_xlatb14.x) ? half(u_xlat11.x) : half(u_xlat12.x);
            u_xlat16_15.y = (u_xlatb14.y) ? half(u_xlat11.y) : half(u_xlat12.y);
            u_xlat16_15.z = (u_xlatb14.z) ? half(u_xlat11.z) : half(u_xlat12.z);
            u_xlat16_58 = min(u_xlat16_15.y, u_xlat16_15.x);
            u_xlat16_58 = min(u_xlat16_15.z, u_xlat16_58);
            u_xlat11.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat23.xyz = float3(u_xlat16_13.xyz) * float3(u_xlat16_58) + u_xlat11.xyz;
            u_xlat16_23.xyz = half3(u_xlat23.xyz);
        }
        u_xlat16_9 = unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_23.xyz), level(float(u_xlat16_52)));
        u_xlat16_52 = half(float(u_xlat16_9.w) + -1.0);
        u_xlat16_52 = half(float(Globals.unity_SpecCube1_HDR.w) * float(u_xlat16_52) + 1.0);
        u_xlat16_52 = half(u_xlat16_52 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_5.xyz = half3(u_xlat16_9.xyz * half3(u_xlat16_52));
        u_xlat16_11.xyz = half3(half3(u_xlat16_56) * u_xlat16_6.xyz + (-u_xlat16_5.xyz));
        u_xlat10.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_11.xyz) + float3(u_xlat16_5.xyz);
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    }
    u_xlat16_5.xyz = half3(half3(u_xlat16_53) * u_xlat16_10.xyz);
    u_xlat16_23.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_51) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_51 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
    u_xlat16_49 = half(max(float(u_xlat16_51), 0.00100000005));
    u_xlat16_51 = rsqrt(u_xlat16_49);
    u_xlat16_23.xyz = half3(half3(u_xlat16_51) * u_xlat16_23.xyz);
    u_xlat16_51 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_20.x = dot(u_xlat16_0.xyz, u_xlat16_23.xyz);
    u_xlat16_20.x = clamp(u_xlat16_20.x, 0.0h, 1.0h);
    u_xlat16_36 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_23.xyz);
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_52 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_52 = dot(half2(u_xlat16_52), u_xlat16_7.xx);
    u_xlat16_52 = half(float(u_xlat16_52) + -0.5);
    u_xlat16_23.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_39 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_39);
    u_xlat16_23.x = half(float(u_xlat16_52) * float(u_xlat16_23.x) + 1.0);
    u_xlat16_39 = half(-abs(float(u_xlat16_51)) + 1.0);
    u_xlat16_55 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_55 = half(u_xlat16_55 * u_xlat16_55);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_55);
    u_xlat16_52 = half(float(u_xlat16_52) * float(u_xlat16_39) + 1.0);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_23.x);
    u_xlat16_52 = half(u_xlat16_4.x * u_xlat16_52);
    u_xlat16_23.x = half(u_xlat16_7.x * u_xlat16_7.x);
    u_xlat16_55 = half((-float(u_xlat16_7.x)) * float(u_xlat16_7.x) + 1.0);
    u_xlat16_56 = half(abs(u_xlat16_51) * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_4.x * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_51 = half(abs(u_xlat16_51) * u_xlat16_55);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_56 + u_xlat16_51);
    u_xlat16_49 = half(float(u_xlat16_51) + 9.99999975e-06);
    u_xlat16_49 = half(0.5 / float(u_xlat16_49));
    u_xlat16_51 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_20.x * u_xlat16_51 + (-u_xlat16_20.x));
    u_xlat16_11.x = half(float(u_xlat16_55) * float(u_xlat16_20.x) + 1.0);
    u_xlat16_27 = half(float(u_xlat16_51) * 0.318309873);
    u_xlat16_11.x = half(float(u_xlat16_11.x) * float(u_xlat16_11.x) + 1.00000001e-07);
    u_xlat16_11.x = half(u_xlat16_27 / u_xlat16_11.x);
    u_xlat16_51 = half(u_xlat16_49 * u_xlat16_11.x);
    u_xlat16_49 = half(float(u_xlat16_51) * 3.14159274);
    u_xlat16_49 = half(max(float(u_xlat16_49), 9.99999975e-05));
    u_xlat16_49 = sqrt(u_xlat16_49);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_49);
    u_xlat16_4.x = half(u_xlat16_23.x * u_xlat16_7.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_20.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb49 = u_xlat16_20.x!=0.0;
    u_xlat49 = u_xlatb49 ? 1.0 : float(0.0);
    u_xlat16_51 = half(u_xlat49 * float(u_xlat16_51));
    u_xlat16_50 = half((-u_xlat16_50) + Globals._Glossiness);
    u_xlat16_50 = half(float(u_xlat16_50) + 1.0);
    u_xlat16_50 = clamp(u_xlat16_50, 0.0h, 1.0h);
    u_xlat16_7.xyw = half3(half3(u_xlat16_52) * u_xlat16_8.xyz);
    u_xlat16_7.xyw = half3(u_xlat16_1.xyz * half3(u_xlat16_53) + u_xlat16_7.xyw);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_51));
    u_xlat16_51 = half((-float(u_xlat16_36)) + 1.0);
    u_xlat16_20.x = half(u_xlat16_51 * u_xlat16_51);
    u_xlat16_20.x = half(u_xlat16_20.x * u_xlat16_20.x);
    u_xlat16_51 = half(u_xlat16_51 * u_xlat16_20.x);
    u_xlat16_20.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * half3(u_xlat16_51) + u_xlat16_2.xyz);
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * u_xlat16_8.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_7.xyw + u_xlat16_20.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_5.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_50));
    u_xlat16_2.xyz = half3(half3(u_xlat16_39) * u_xlat16_5.xyz + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    u_xlat1.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = u_xlat1.x * u_xlat1.x + (-u_xlat10);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(unity_SHBr, u_xlat2);
    u_xlat1.y = dot(unity_SHBg, u_xlat2);
    u_xlat1.z = dot(unity_SHBb, u_xlat2);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat10) + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2
Set 2D Texture "_EmissionMap" to slot 3
Set CUBE Texture "unity_SpecCube0" to slot 4
Set 3D Texture "unity_ProbeVolumeSH" to slot 5

Constant Buffer "Globals" (176 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_OcclusionMaskSelector at 8
  VectorHalf4 unity_SpecCube0_HDR at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _LightColor0 at 144
  VectorHalf4 _Color at 152
  ScalarHalf _Metallic at 160
  ScalarHalf _Glossiness at 162
  VectorHalf4 _EmissionColor at 168
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_OcclusionMaskSelector;
    half4 unity_SpecCube0_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (3) ]] ,
    sampler sampler_EmissionMap [[ sampler (3) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (4) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (5) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float u_xlat1;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half4 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_14;
    half3 u_xlat16_15;
    half u_xlat16_32;
    half u_xlat16_33;
    half u_xlat16_34;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_32 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_32));
    u_xlat16_33 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_33 = rsqrt(u_xlat16_33);
    u_xlat16_4.xyz = half3(half3(u_xlat16_33) * input.TEXCOORD4.xyz);
    u_xlatb0 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb0){
        u_xlatb0 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat16_15.x = input.TEXCOORD2.w;
        u_xlat16_15.y = input.TEXCOORD3.w;
        u_xlat16_15.z = input.TEXCOORD4.w;
        u_xlat0.xyz = (bool(u_xlatb0)) ? u_xlat10.xyz : float3(u_xlat16_15.xyz);
        u_xlat0.xyz = u_xlat0.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat0.yzw = u_xlat0.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat10.x = u_xlat0.y * 0.25 + 0.75;
        u_xlat1 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat0.x = max(u_xlat10.x, u_xlat1);
        u_xlat0 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat0.xzw);
        u_xlat16_0 = half4(u_xlat0);
    } else {
        u_xlat16_0.x = half(1.0);
        u_xlat16_0.y = half(1.0);
        u_xlat16_0.z = half(1.0);
        u_xlat16_0.w = half(1.0);
    }
    u_xlat16_33 = dot(u_xlat16_0, Globals.unity_OcclusionMaskSelector);
    u_xlat16_33 = clamp(u_xlat16_33, 0.0h, 1.0h);
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_0.xw = half2((-float2(Globals._Glossiness)) + float2(1.0, 1.0));
    u_xlat16_34 = dot(input.TEXCOORD1.xyz, u_xlat16_4.xyz);
    u_xlat16_34 = half(u_xlat16_34 + u_xlat16_34);
    u_xlat16_5.xyz = half3(u_xlat16_4.xyz * (-half3(u_xlat16_34)) + input.TEXCOORD1.xyz);
    u_xlat16_6.xyz = half3(half3(u_xlat16_33) * Globals._LightColor0.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD5.xyz);
    u_xlat16_33 = half((-float(u_xlat16_0.x)) * 0.699999988 + 1.70000005);
    u_xlat16_33 = half(u_xlat16_0.x * u_xlat16_33);
    u_xlat16_33 = half(float(u_xlat16_33) * 6.0);
    u_xlat16_5 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_5.xyz), level(float(u_xlat16_33)));
    u_xlat16_33 = half(float(u_xlat16_5.w) + -1.0);
    u_xlat16_33 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_33) + 1.0);
    u_xlat16_33 = half(u_xlat16_33 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_8.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_33));
    u_xlat16_8.xyz = half3(u_xlat16_1.xxx * u_xlat16_8.xyz);
    u_xlat16_33 = dot((-input.TEXCOORD1.xyz), u_xlat16_4.xyz);
    u_xlat16_34 = half(u_xlat16_33 + u_xlat16_33);
    u_xlat16_9.xyz = half3(u_xlat16_4.xyz * (-half3(u_xlat16_34)) + (-input.TEXCOORD1.xyz));
    u_xlat16_4.x = dot(u_xlat16_4.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_33 = u_xlat16_33;
    u_xlat16_33 = clamp(u_xlat16_33, 0.0h, 1.0h);
    u_xlat16_9.x = dot(u_xlat16_9.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_9.y = half((-float(u_xlat16_33)) + 1.0);
    u_xlat16_14.xy = half2(u_xlat16_9.xy * u_xlat16_9.xy);
    u_xlat16_0.yz = half2(u_xlat16_14.xy * u_xlat16_14.xy);
    u_xlat16_32 = half((-u_xlat16_32) + Globals._Glossiness);
    u_xlat16_32 = half(float(u_xlat16_32) + 1.0);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlat16_1.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_0.yw)).w;
    u_xlat16_1.x = half(float(u_xlat16_1.x) * 16.0);
    u_xlat16_14.xyz = half3(u_xlat16_1.xxx * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_4.xxx * u_xlat16_6.xyz);
    u_xlat16_9.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_32));
    u_xlat16_2.xyz = half3(u_xlat16_0.zzz * u_xlat16_9.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_8.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_7.xyz * u_xlat16_3.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_14.xyz * u_xlat16_6.xyz + u_xlat16_2.xyz);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_1.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set 2D Texture "_EmissionMap" to slot 3
Set CUBE Texture "unity_SpecCube0" to slot 4
Set CUBE Texture "unity_SpecCube1" to slot 5
Set 3D Texture "unity_ProbeVolumeSH" to slot 6

Constant Buffer "Globals" (416 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 80
  Matrix4x4 unity_ProbeVolumeWorldToObject at 288
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  VectorHalf4 unity_SHAr at 24
  VectorHalf4 unity_SHAg at 32
  VectorHalf4 unity_SHAb at 40
  VectorHalf4 unity_OcclusionMaskSelector at 48
  VectorHalf4 _LightShadowData at 56
  Vector4 unity_ShadowFadeCenterAndType at 64
  Vector4 unity_SpecCube0_BoxMax at 144
  Vector4 unity_SpecCube0_BoxMin at 160
  Vector4 unity_SpecCube0_ProbePosition at 176
  VectorHalf4 unity_SpecCube0_HDR at 192
  Vector4 unity_SpecCube1_BoxMax at 208
  Vector4 unity_SpecCube1_BoxMin at 224
  Vector4 unity_SpecCube1_ProbePosition at 240
  VectorHalf4 unity_SpecCube1_HDR at 256
  Vector4 unity_ProbeVolumeParams at 272
  Vector3 unity_ProbeVolumeSizeInv at 352
  Vector3 unity_ProbeVolumeMin at 368
  VectorHalf4 _LightColor0 at 384
  VectorHalf4 _Color at 392
  ScalarHalf _Metallic at 400
  ScalarHalf _Glossiness at 402
  ScalarHalf _OcclusionStrength at 404
  VectorHalf4 _EmissionColor at 408
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (3) ]] ,
    sampler sampler_EmissionMap [[ sampler (3) ]] ,
    texturecube<half, access::sample > unity_SpecCube0 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (4) ]] ,
    texturecube<half, access::sample > unity_SpecCube1 [[ texture (5) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (5) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (6) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (6) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float4 u_xlat6;
    half4 u_xlat16_6;
    half4 u_xlat16_7;
    half3 u_xlat16_8;
    float4 u_xlat9;
    half4 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    half3 u_xlat16_11;
    float3 u_xlat12;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    bool3 u_xlatb14;
    half3 u_xlat16_15;
    float3 u_xlat17;
    bool u_xlatb17;
    half3 u_xlat16_20;
    float3 u_xlat23;
    half3 u_xlat16_23;
    float u_xlat25;
    half u_xlat16_27;
    float2 u_xlat33;
    half u_xlat16_33;
    bool u_xlatb33;
    half u_xlat16_36;
    half u_xlat16_39;
    float u_xlat49;
    half u_xlat16_49;
    bool u_xlatb49;
    half u_xlat16_50;
    half u_xlat16_51;
    half u_xlat16_52;
    half u_xlat16_53;
    half u_xlat16_55;
    half u_xlat16_56;
    half u_xlat16_58;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_50 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_50));
    u_xlat16_51 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_0.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD4.xyz);
    u_xlat16_51 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_51 = rsqrt(u_xlat16_51);
    u_xlat16_4.xyz = half3(half3(u_xlat16_51) * input.TEXCOORD1.xyz);
    u_xlat16_5.x = input.TEXCOORD2.w;
    u_xlat16_5.y = input.TEXCOORD3.w;
    u_xlat16_5.z = input.TEXCOORD4.w;
    u_xlat1.xyz = (-float3(u_xlat16_5.xyz)) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat17.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat17.x = dot(u_xlat17.xyz, u_xlat17.xyz);
    u_xlat17.x = sqrt(u_xlat17.x);
    u_xlat17.x = (-u_xlat1.x) + u_xlat17.x;
    u_xlat1.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat17.x + u_xlat1.x;
    u_xlat1.x = u_xlat1.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat1.x = clamp(u_xlat1.x, 0.0f, 1.0f);
    u_xlatb17 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb17){
        u_xlatb33 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat6.xyz;
        u_xlat6.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb33)) ? u_xlat6.xyz : float3(u_xlat16_5.xyz);
        u_xlat6.xyz = u_xlat6.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat6.yzw = u_xlat6.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat33.x = u_xlat6.y * 0.25 + 0.75;
        u_xlat49 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat6.x = max(u_xlat49, u_xlat33.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat16_6 = half4(u_xlat6);
    } else {
        u_xlat16_6.x = half(1.0);
        u_xlat16_6.y = half(1.0);
        u_xlat16_6.z = half(1.0);
        u_xlat16_6.w = half(1.0);
    }
    u_xlat16_52 = dot(u_xlat16_6, Globals.unity_OcclusionMaskSelector);
    u_xlat16_52 = clamp(u_xlat16_52, 0.0h, 1.0h);
    u_xlat33.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_33 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat33.xy).x;
    u_xlat16_53 = half(u_xlat1.x + float(u_xlat16_33));
    u_xlat16_53 = clamp(u_xlat16_53, 0.0h, 1.0h);
    u_xlat16_52 = min(u_xlat16_52, u_xlat16_53);
    u_xlat16_52 = (u_xlatb17) ? u_xlat16_52 : u_xlat16_53;
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_53 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_53 = half(u_xlat16_1.x * Globals._OcclusionStrength + u_xlat16_53);
    u_xlat16_7.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_23.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_23.x = half(u_xlat16_23.x + u_xlat16_23.x);
    u_xlat16_23.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_23.xxx) + u_xlat16_4.xyz);
    u_xlat16_8.xyz = half3(half3(u_xlat16_52) * Globals._LightColor0.xyz);
    if(u_xlatb17){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = float3(input.TEXCOORD3.www) * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * float3(input.TEXCOORD2.www) + u_xlat17.xyz;
        u_xlat17.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * float3(input.TEXCOORD4.www) + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat17.xyz : float3(u_xlat16_5.xyz);
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat17.x = u_xlat1.y * 0.25;
        u_xlat9.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat25 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat9.x);
        u_xlat1.x = min(u_xlat25, u_xlat17.x);
        u_xlat6 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat9.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat9 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat9.xyz);
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz);
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = half(dot(u_xlat6, float4(u_xlat16_0)));
        u_xlat16_10.y = half(dot(u_xlat9, float4(u_xlat16_0)));
        u_xlat16_10.z = half(dot(u_xlat1, float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_10.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_10.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_10.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_10.xyz = half3(u_xlat16_10.xyz + input.TEXCOORD5.xyz);
    u_xlat16_10.xyz = half3(max(float3(u_xlat16_10.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_10.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb49 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb49){
        u_xlat16_52 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
        u_xlat16_52 = rsqrt(u_xlat16_52);
        u_xlat16_10.xyz = half3(half3(u_xlat16_52) * u_xlat16_23.xyz);
        u_xlat9.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_10.xyz);
        u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_10.xyz);
        u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_10.xyz));
        u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat9.x) : half(u_xlat11.x);
        u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat9.y) : half(u_xlat11.y);
        u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat9.z) : half(u_xlat11.z);
        u_xlat16_52 = min(u_xlat16_13.y, u_xlat16_13.x);
        u_xlat16_52 = min(u_xlat16_13.z, u_xlat16_52);
        u_xlat9.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = float3(u_xlat16_10.xyz) * float3(u_xlat16_52) + u_xlat9.xyz;
        u_xlat16_9.xyz = half3(u_xlat9.xyz);
    } else {
        u_xlat16_9.xyz = u_xlat16_23.xyz;
    }
    u_xlat16_52 = half((-float(u_xlat16_7.x)) * 0.699999988 + 1.70000005);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_7.x);
    u_xlat16_52 = half(float(u_xlat16_52) * 6.0);
    u_xlat16_6 = unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_9.xyz), level(float(u_xlat16_52)));
    u_xlat16_56 = half(float(u_xlat16_6.w) + -1.0);
    u_xlat16_56 = half(float(Globals.unity_SpecCube0_HDR.w) * float(u_xlat16_56) + 1.0);
    u_xlat16_56 = half(u_xlat16_56 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_10.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_56));
    u_xlatb49 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat16_58 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
            u_xlat16_58 = rsqrt(u_xlat16_58);
            u_xlat16_13.xyz = half3(u_xlat16_23.xyz * half3(u_xlat16_58));
            u_xlat11.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_13.xyz);
            u_xlat12.xyz = (-float3(u_xlat16_5.xyz)) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat12.xyz = u_xlat12.xyz / float3(u_xlat16_13.xyz);
            u_xlatb14.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_13.xyz));
            u_xlat16_15.x = (u_xlatb14.x) ? half(u_xlat11.x) : half(u_xlat12.x);
            u_xlat16_15.y = (u_xlatb14.y) ? half(u_xlat11.y) : half(u_xlat12.y);
            u_xlat16_15.z = (u_xlatb14.z) ? half(u_xlat11.z) : half(u_xlat12.z);
            u_xlat16_58 = min(u_xlat16_15.y, u_xlat16_15.x);
            u_xlat16_58 = min(u_xlat16_15.z, u_xlat16_58);
            u_xlat11.xyz = float3(u_xlat16_5.xyz) + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat23.xyz = float3(u_xlat16_13.xyz) * float3(u_xlat16_58) + u_xlat11.xyz;
            u_xlat16_23.xyz = half3(u_xlat23.xyz);
        }
        u_xlat16_9 = unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_23.xyz), level(float(u_xlat16_52)));
        u_xlat16_52 = half(float(u_xlat16_9.w) + -1.0);
        u_xlat16_52 = half(float(Globals.unity_SpecCube1_HDR.w) * float(u_xlat16_52) + 1.0);
        u_xlat16_52 = half(u_xlat16_52 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_5.xyz = half3(u_xlat16_9.xyz * half3(u_xlat16_52));
        u_xlat16_11.xyz = half3(half3(u_xlat16_56) * u_xlat16_6.xyz + (-u_xlat16_5.xyz));
        u_xlat10.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_11.xyz) + float3(u_xlat16_5.xyz);
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    }
    u_xlat16_5.xyz = half3(half3(u_xlat16_53) * u_xlat16_10.xyz);
    u_xlat16_23.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_51) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_51 = dot(u_xlat16_23.xyz, u_xlat16_23.xyz);
    u_xlat16_49 = half(max(float(u_xlat16_51), 0.00100000005));
    u_xlat16_51 = rsqrt(u_xlat16_49);
    u_xlat16_23.xyz = half3(half3(u_xlat16_51) * u_xlat16_23.xyz);
    u_xlat16_51 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_20.x = dot(u_xlat16_0.xyz, u_xlat16_23.xyz);
    u_xlat16_20.x = clamp(u_xlat16_20.x, 0.0h, 1.0h);
    u_xlat16_36 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_23.xyz);
    u_xlat16_36 = clamp(u_xlat16_36, 0.0h, 1.0h);
    u_xlat16_52 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_52 = dot(half2(u_xlat16_52), u_xlat16_7.xx);
    u_xlat16_52 = half(float(u_xlat16_52) + -0.5);
    u_xlat16_23.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_39 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_39);
    u_xlat16_23.x = half(float(u_xlat16_52) * float(u_xlat16_23.x) + 1.0);
    u_xlat16_39 = half(-abs(float(u_xlat16_51)) + 1.0);
    u_xlat16_55 = half(u_xlat16_39 * u_xlat16_39);
    u_xlat16_55 = half(u_xlat16_55 * u_xlat16_55);
    u_xlat16_39 = half(u_xlat16_39 * u_xlat16_55);
    u_xlat16_52 = half(float(u_xlat16_52) * float(u_xlat16_39) + 1.0);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_23.x);
    u_xlat16_52 = half(u_xlat16_4.x * u_xlat16_52);
    u_xlat16_23.x = half(u_xlat16_7.x * u_xlat16_7.x);
    u_xlat16_55 = half((-float(u_xlat16_7.x)) * float(u_xlat16_7.x) + 1.0);
    u_xlat16_56 = half(abs(u_xlat16_51) * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_4.x * u_xlat16_55 + u_xlat16_23.x);
    u_xlat16_51 = half(abs(u_xlat16_51) * u_xlat16_55);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_56 + u_xlat16_51);
    u_xlat16_49 = half(float(u_xlat16_51) + 9.99999975e-06);
    u_xlat16_49 = half(0.5 / float(u_xlat16_49));
    u_xlat16_51 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_55 = half(u_xlat16_20.x * u_xlat16_51 + (-u_xlat16_20.x));
    u_xlat16_11.x = half(float(u_xlat16_55) * float(u_xlat16_20.x) + 1.0);
    u_xlat16_27 = half(float(u_xlat16_51) * 0.318309873);
    u_xlat16_11.x = half(float(u_xlat16_11.x) * float(u_xlat16_11.x) + 1.00000001e-07);
    u_xlat16_11.x = half(u_xlat16_27 / u_xlat16_11.x);
    u_xlat16_51 = half(u_xlat16_49 * u_xlat16_11.x);
    u_xlat16_49 = half(float(u_xlat16_51) * 3.14159274);
    u_xlat16_49 = half(max(float(u_xlat16_49), 9.99999975e-05));
    u_xlat16_49 = sqrt(u_xlat16_49);
    u_xlat16_51 = half(u_xlat16_4.x * u_xlat16_49);
    u_xlat16_4.x = half(u_xlat16_23.x * u_xlat16_7.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_20.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb49 = u_xlat16_20.x!=0.0;
    u_xlat49 = u_xlatb49 ? 1.0 : float(0.0);
    u_xlat16_51 = half(u_xlat49 * float(u_xlat16_51));
    u_xlat16_50 = half((-u_xlat16_50) + Globals._Glossiness);
    u_xlat16_50 = half(float(u_xlat16_50) + 1.0);
    u_xlat16_50 = clamp(u_xlat16_50, 0.0h, 1.0h);
    u_xlat16_7.xyw = half3(half3(u_xlat16_52) * u_xlat16_8.xyz);
    u_xlat16_7.xyw = half3(u_xlat16_1.xyz * half3(u_xlat16_53) + u_xlat16_7.xyw);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_51));
    u_xlat16_51 = half((-float(u_xlat16_36)) + 1.0);
    u_xlat16_20.x = half(u_xlat16_51 * u_xlat16_51);
    u_xlat16_20.x = half(u_xlat16_20.x * u_xlat16_20.x);
    u_xlat16_51 = half(u_xlat16_51 * u_xlat16_20.x);
    u_xlat16_20.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * half3(u_xlat16_51) + u_xlat16_2.xyz);
    u_xlat16_20.xyz = half3(u_xlat16_20.xyz * u_xlat16_8.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_7.xyw + u_xlat16_20.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_5.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_50));
    u_xlat16_2.xyz = half3(half3(u_xlat16_39) * u_xlat16_5.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_1.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 192
  Matrix4x4 unity_WorldToObject at 256
  Matrix4x4 unity_MatrixVP at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHAr at 136
  VectorHalf4 unity_SHAg at 144
  VectorHalf4 unity_SHAb at 152
  VectorHalf4 unity_SHBr at 160
  VectorHalf4 unity_SHBg at 168
  VectorHalf4 unity_SHBb at 176
  VectorHalf4 unity_SHC at 184
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    half3 u_xlat16_3;
    float4 u_xlat4;
    half4 u_xlat16_4;
    float4 u_xlat5;
    half3 u_xlat16_5;
    float3 u_xlat6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    u_xlat1.w = u_xlat0.z;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat2 = float4(u_xlat21) * u_xlat2.xyzz;
    u_xlat1.xyz = u_xlat2.xyw;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat16_3.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3.x)));
    u_xlat16_4 = half4(u_xlat2.ywzx * u_xlat2);
    u_xlat16_5.x = dot(Globals.unity_SHBr, u_xlat16_4);
    u_xlat16_5.y = dot(Globals.unity_SHBg, u_xlat16_4);
    u_xlat16_5.z = dot(Globals.unity_SHBb, u_xlat16_4);
    u_xlat16_3.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_3.xxx + u_xlat16_5.xyz);
    u_xlat1.w = 1.0;
    u_xlat16_4.x = half(dot(float4(Globals.unity_SHAr), u_xlat1));
    u_xlat16_4.y = half(dot(float4(Globals.unity_SHAg), u_xlat1));
    u_xlat16_4.z = half(dot(float4(Globals.unity_SHAb), u_xlat1));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz + u_xlat16_4.xyz);
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat6.xyz = log2(float3(u_xlat16_3.xyz));
    u_xlat6.xyz = u_xlat6.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat6.xyz = max(u_xlat6.xyz, float3(0.0, 0.0, 0.0));
    u_xlat3 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat0 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat1 = u_xlat5 * u_xlat1.xxxx + u_xlat4;
    u_xlat1 = u_xlat0 * u_xlat2.wwzw + u_xlat1;
    u_xlat2 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat2;
    u_xlat0 = max(u_xlat0, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat2 = rsqrt(u_xlat0);
    u_xlat0 = u_xlat0 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat1 = u_xlat1 * u_xlat2;
    u_xlat1 = max(u_xlat1, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat1;
    u_xlat1.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat1.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat1.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    output.TEXCOORD5.xyz = half3(u_xlat6.xyz + u_xlat0.xyz);
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat19 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    vs_TEXCOORD1.xyz = vec3(u_xlat19) * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat18 = u_xlat1.y * u_xlat1.y;
    u_xlat18 = u_xlat1.x * u_xlat1.x + (-u_xlat18);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat18) + u_xlat3.xyz;
    u_xlat1.w = 1.0;
    u_xlat3.x = dot(unity_SHAr, u_xlat1);
    u_xlat3.y = dot(unity_SHAg, u_xlat1);
    u_xlat3.z = dot(unity_SHAb, u_xlat1);
    u_xlat2.xyz = u_xlat2.xyz + u_xlat3.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat3 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat0 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    u_xlat4 = u_xlat5 * u_xlat1.xxxx + u_xlat4;
    u_xlat1 = u_xlat0 * u_xlat1.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat0);
    u_xlat0 = u_xlat0 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat1 = max(u_xlat1, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat1;
    u_xlat1.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat1.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    vs_TEXCOORD5.xyz = u_xlat2.xyz + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  samplerCube unity_SpecCube0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
vec3 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat10;
vec3 u_xlat12;
float u_xlat24;
float u_xlat25;
float u_xlat16_25;
bool u_xlatb25;
float u_xlat26;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat24 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat24) * u_xlat1.xyz;
    u_xlat25 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat25 = inversesqrt(u_xlat25);
    u_xlat2.xyz = vec3(u_xlat25) * vs_TEXCOORD4.xyz;
    u_xlatb25 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb25){
        u_xlatb25 = unity_ProbeVolumeParams.y==1.0;
        u_xlat3.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat3.xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat3.xyz;
        u_xlat3.xyz = u_xlat3.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.x = vs_TEXCOORD2.w;
        u_xlat12.y = vs_TEXCOORD3.w;
        u_xlat12.z = vs_TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb25)) ? u_xlat3.xyz : u_xlat12.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat3.yzw = u_xlat3.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat25 = u_xlat3.y * 0.25 + 0.75;
        u_xlat26 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat3.x = max(u_xlat25, u_xlat26);
        u_xlat3 = texture(unity_ProbeVolumeSH, u_xlat3.xzw);
    } else {
        u_xlat3.x = float(1.0);
        u_xlat3.y = float(1.0);
        u_xlat3.z = float(1.0);
        u_xlat3.w = float(1.0);
    //ENDIF
    }
    u_xlat25 = dot(u_xlat3, unity_OcclusionMaskSelector);
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat4.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat26 = dot(vs_TEXCOORD1.xyz, u_xlat2.xyz);
    u_xlat26 = u_xlat26 + u_xlat26;
    u_xlat3.xzw = u_xlat2.xyz * (-vec3(u_xlat26)) + vs_TEXCOORD1.xyz;
    u_xlat5.xyz = vec3(u_xlat25) * _LightColor0.xyz;
    u_xlat6.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat25 = (-u_xlat4.x) * 0.699999988 + 1.70000005;
    u_xlat25 = u_xlat25 * u_xlat4.x;
    u_xlat25 = u_xlat25 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat3.xzw, u_xlat25);
    u_xlat16_25 = u_xlat10_7.w + -1.0;
    u_xlat25 = unity_SpecCube0_HDR.w * u_xlat16_25 + 1.0;
    u_xlat25 = u_xlat25 * unity_SpecCube0_HDR.x;
    u_xlat3.xzw = u_xlat10_7.xyz * vec3(u_xlat25);
    u_xlat3.xyz = u_xlat10_3.yyy * u_xlat3.xzw;
    u_xlat25 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat26 = u_xlat25 + u_xlat25;
    u_xlat7.xyz = u_xlat2.xyz * (-vec3(u_xlat26)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat25 = u_xlat25;
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat7.x = dot(u_xlat7.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat7.y = (-u_xlat25) + 1.0;
    u_xlat10.xy = u_xlat7.xy * u_xlat7.xy;
    u_xlat4.yz = u_xlat10.xy * u_xlat10.xy;
    u_xlat24 = (-u_xlat24) + _Glossiness;
    u_xlat24 = u_xlat24 + 1.0;
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat10_7 = texture(unity_NHxRoughness, u_xlat4.yw);
    u_xlat16_25 = u_xlat10_7.w * 16.0;
    u_xlat10.xyz = vec3(u_xlat16_25) * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat4.xyw = u_xlat2.xxx * u_xlat5.xyz;
    u_xlat5.xyz = (-u_xlat0.xyz) + vec3(u_xlat24);
    u_xlat0.xyz = u_xlat4.zzz * u_xlat5.xyz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    u_xlat0.xyz = u_xlat6.xyz * u_xlat1.xyz + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat10.xyz * u_xlat4.xyw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 192
  Matrix4x4 unity_WorldToObject at 256
  Matrix4x4 unity_MatrixVP at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHBr at 152
  VectorHalf4 unity_SHBg at 160
  VectorHalf4 unity_SHBb at 168
  VectorHalf4 unity_SHC at 176
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    u_xlat2.w = u_xlat1.z;
    u_xlat3.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat3.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat3.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat3.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat3 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat1);
    u_xlat1 = u_xlat1 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_2 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz * u_xlat3.xyz + float3(u_xlat16_6.xyz));
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat3 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat1);
    u_xlat1 = u_xlat1 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat3.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat19 = u_xlat2.y * u_xlat2.y;
    u_xlat19 = u_xlat2.x * u_xlat2.x + (-u_xlat19);
    u_xlat2 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat2);
    u_xlat4.y = dot(unity_SHBg, u_xlat2);
    u_xlat4.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat19) + u_xlat4.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz * u_xlat3.xyz + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (306 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Matrix4x4 unity_MatrixVP at 208
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHAr at 16
  VectorHalf4 unity_SHAg at 24
  VectorHalf4 unity_SHAb at 32
  VectorHalf4 unity_SHBr at 40
  VectorHalf4 unity_SHBg at 48
  VectorHalf4 unity_SHBb at 56
  VectorHalf4 unity_SHC at 64
  Vector4 _MainTex_ST at 272
  Vector4 _DetailAlbedoMap_ST at 288
  ScalarHalf _UVSec at 304
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1 = float4(u_xlat13) * u_xlat1.xyzz;
    u_xlat0.xyz = u_xlat1.xyw;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat16_2.x = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2.x = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2.x)));
    u_xlat16_1 = half4(u_xlat1.ywzx * u_xlat1);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_1);
    u_xlat16_2.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    u_xlat0.w = 1.0;
    u_xlat16_3.x = half(dot(float4(Globals.unity_SHAr), u_xlat0));
    u_xlat16_3.y = half(dot(float4(Globals.unity_SHAg), u_xlat0));
    u_xlat16_3.z = half(dot(float4(Globals.unity_SHAb), u_xlat0));
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_2.xyz = half3(max(float3(u_xlat16_2.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat0.xyz = log2(float3(u_xlat16_2.xyz));
    u_xlat0.xyz = u_xlat0.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = max(u_xlat0.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
float u_xlat12;
float u_xlat13;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    vs_TEXCOORD1.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = inversesqrt(u_xlat12);
    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = u_xlat0.x * u_xlat0.x + (-u_xlat1.x);
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat1.xyz = unity_SHC.xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(unity_SHAr, u_xlat0);
    u_xlat2.y = dot(unity_SHAg, u_xlat0);
    u_xlat2.z = dot(unity_SHAb, u_xlat0);
    u_xlat0.xyz = u_xlat1.xyz + u_xlat2.xyz;
    u_xlat0.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    vs_TEXCOORD5.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec3 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
vec3 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat10;
vec3 u_xlat12;
float u_xlat24;
float u_xlat25;
float u_xlat16_25;
bool u_xlatb25;
float u_xlat26;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat24 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat24) * u_xlat1.xyz;
    u_xlat25 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat25 = inversesqrt(u_xlat25);
    u_xlat2.xyz = vec3(u_xlat25) * vs_TEXCOORD4.xyz;
    u_xlatb25 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb25){
        u_xlatb25 = unity_ProbeVolumeParams.y==1.0;
        u_xlat3.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat3.xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat3.xyz;
        u_xlat3.xyz = u_xlat3.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.x = vs_TEXCOORD2.w;
        u_xlat12.y = vs_TEXCOORD3.w;
        u_xlat12.z = vs_TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb25)) ? u_xlat3.xyz : u_xlat12.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat3.yzw = u_xlat3.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat25 = u_xlat3.y * 0.25 + 0.75;
        u_xlat26 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat3.x = max(u_xlat25, u_xlat26);
        u_xlat3 = texture(unity_ProbeVolumeSH, u_xlat3.xzw);
    } else {
        u_xlat3.x = float(1.0);
        u_xlat3.y = float(1.0);
        u_xlat3.z = float(1.0);
        u_xlat3.w = float(1.0);
    //ENDIF
    }
    u_xlat25 = dot(u_xlat3, unity_OcclusionMaskSelector);
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat4.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat26 = dot(vs_TEXCOORD1.xyz, u_xlat2.xyz);
    u_xlat26 = u_xlat26 + u_xlat26;
    u_xlat3.xzw = u_xlat2.xyz * (-vec3(u_xlat26)) + vs_TEXCOORD1.xyz;
    u_xlat5.xyz = vec3(u_xlat25) * _LightColor0.xyz;
    u_xlat6.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat25 = (-u_xlat4.x) * 0.699999988 + 1.70000005;
    u_xlat25 = u_xlat25 * u_xlat4.x;
    u_xlat25 = u_xlat25 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat3.xzw, u_xlat25);
    u_xlat16_25 = u_xlat10_7.w + -1.0;
    u_xlat25 = unity_SpecCube0_HDR.w * u_xlat16_25 + 1.0;
    u_xlat25 = u_xlat25 * unity_SpecCube0_HDR.x;
    u_xlat3.xzw = u_xlat10_7.xyz * vec3(u_xlat25);
    u_xlat3.xyz = u_xlat10_3.yyy * u_xlat3.xzw;
    u_xlat25 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat26 = u_xlat25 + u_xlat25;
    u_xlat7.xyz = u_xlat2.xyz * (-vec3(u_xlat26)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat25 = u_xlat25;
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat7.x = dot(u_xlat7.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat7.y = (-u_xlat25) + 1.0;
    u_xlat10.xy = u_xlat7.xy * u_xlat7.xy;
    u_xlat4.yz = u_xlat10.xy * u_xlat10.xy;
    u_xlat24 = (-u_xlat24) + _Glossiness;
    u_xlat24 = u_xlat24 + 1.0;
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat10_7 = texture(unity_NHxRoughness, u_xlat4.yw);
    u_xlat16_25 = u_xlat10_7.w * 16.0;
    u_xlat10.xyz = vec3(u_xlat16_25) * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat4.xyw = u_xlat2.xxx * u_xlat5.xyz;
    u_xlat5.xyz = (-u_xlat0.xyz) + vec3(u_xlat24);
    u_xlat0.xyz = u_xlat4.zzz * u_xlat5.xyz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    u_xlat0.xyz = u_xlat6.xyz * u_xlat1.xyz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat10.xyz * u_xlat4.xyw + u_xlat0.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 64
  Matrix4x4 unity_WorldToObject at 128
  Matrix4x4 unity_MatrixVP at 192
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHBr at 32
  VectorHalf4 unity_SHBg at 40
  VectorHalf4 unity_SHBb at 48
  VectorHalf4 unity_SHC at 56
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    float4 u_xlat2;
    half u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat17;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyw = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyw + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat17 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat17 = rsqrt(u_xlat17);
    u_xlat1.xyz = float3(u_xlat17) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat16_3 = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3 = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_1);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_3) + u_xlat16_4.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat2.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat2.zz + u_xlat2.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    u_xlat1.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = u_xlat1.x * u_xlat1.x + (-u_xlat10);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(unity_SHBr, u_xlat2);
    u_xlat1.y = dot(unity_SHBg, u_xlat2);
    u_xlat1.z = dot(unity_SHBb, u_xlat2);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat10) + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 192
  Matrix4x4 unity_WorldToObject at 256
  Matrix4x4 unity_MatrixVP at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHAr at 136
  VectorHalf4 unity_SHAg at 144
  VectorHalf4 unity_SHAb at 152
  VectorHalf4 unity_SHBr at 160
  VectorHalf4 unity_SHBg at 168
  VectorHalf4 unity_SHBb at 176
  VectorHalf4 unity_SHC at 184
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    half3 u_xlat16_3;
    float4 u_xlat4;
    half4 u_xlat16_4;
    float4 u_xlat5;
    half3 u_xlat16_5;
    float3 u_xlat6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    u_xlat1.w = u_xlat0.z;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat2 = float4(u_xlat21) * u_xlat2.xyzz;
    u_xlat1.xyz = u_xlat2.xyw;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat16_3.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3.x)));
    u_xlat16_4 = half4(u_xlat2.ywzx * u_xlat2);
    u_xlat16_5.x = dot(Globals.unity_SHBr, u_xlat16_4);
    u_xlat16_5.y = dot(Globals.unity_SHBg, u_xlat16_4);
    u_xlat16_5.z = dot(Globals.unity_SHBb, u_xlat16_4);
    u_xlat16_3.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_3.xxx + u_xlat16_5.xyz);
    u_xlat1.w = 1.0;
    u_xlat16_4.x = half(dot(float4(Globals.unity_SHAr), u_xlat1));
    u_xlat16_4.y = half(dot(float4(Globals.unity_SHAg), u_xlat1));
    u_xlat16_4.z = half(dot(float4(Globals.unity_SHAb), u_xlat1));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz + u_xlat16_4.xyz);
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat6.xyz = log2(float3(u_xlat16_3.xyz));
    u_xlat6.xyz = u_xlat6.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat6.xyz = max(u_xlat6.xyz, float3(0.0, 0.0, 0.0));
    u_xlat3 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat0 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat1 = u_xlat5 * u_xlat1.xxxx + u_xlat4;
    u_xlat1 = u_xlat0 * u_xlat2.wwzw + u_xlat1;
    u_xlat2 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat2;
    u_xlat0 = max(u_xlat0, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat2 = rsqrt(u_xlat0);
    u_xlat0 = u_xlat0 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat1 = u_xlat1 * u_xlat2;
    u_xlat1 = max(u_xlat1, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat1;
    u_xlat1.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat1.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat1.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    output.TEXCOORD5.xyz = half3(u_xlat6.xyz + u_xlat0.xyz);
    output.TEXCOORD5.w = 0.0;
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat19 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    vs_TEXCOORD1.xyz = vec3(u_xlat19) * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat18 = u_xlat1.y * u_xlat1.y;
    u_xlat18 = u_xlat1.x * u_xlat1.x + (-u_xlat18);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat18) + u_xlat3.xyz;
    u_xlat1.w = 1.0;
    u_xlat3.x = dot(unity_SHAr, u_xlat1);
    u_xlat3.y = dot(unity_SHAg, u_xlat1);
    u_xlat3.z = dot(unity_SHAb, u_xlat1);
    u_xlat2.xyz = u_xlat2.xyz + u_xlat3.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat3 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat0 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    u_xlat4 = u_xlat5 * u_xlat1.xxxx + u_xlat4;
    u_xlat1 = u_xlat0 * u_xlat1.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat0);
    u_xlat0 = u_xlat0 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat1 = max(u_xlat1, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat1;
    u_xlat1.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat1.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    vs_TEXCOORD5.xyz = u_xlat2.xyz + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec3 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
vec3 u_xlat7;
vec4 u_xlat10_7;
vec3 u_xlat10;
vec3 u_xlat12;
float u_xlat24;
float u_xlat25;
float u_xlat16_25;
bool u_xlatb25;
float u_xlat26;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat24 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat24) * u_xlat1.xyz;
    u_xlat25 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat25 = inversesqrt(u_xlat25);
    u_xlat2.xyz = vec3(u_xlat25) * vs_TEXCOORD4.xyz;
    u_xlatb25 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb25){
        u_xlatb25 = unity_ProbeVolumeParams.y==1.0;
        u_xlat3.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat3.xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat3.xyz;
        u_xlat3.xyz = u_xlat3.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat12.x = vs_TEXCOORD2.w;
        u_xlat12.y = vs_TEXCOORD3.w;
        u_xlat12.z = vs_TEXCOORD4.w;
        u_xlat3.xyz = (bool(u_xlatb25)) ? u_xlat3.xyz : u_xlat12.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat3.yzw = u_xlat3.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat25 = u_xlat3.y * 0.25 + 0.75;
        u_xlat26 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat3.x = max(u_xlat25, u_xlat26);
        u_xlat3 = texture(unity_ProbeVolumeSH, u_xlat3.xzw);
    } else {
        u_xlat3.x = float(1.0);
        u_xlat3.y = float(1.0);
        u_xlat3.z = float(1.0);
        u_xlat3.w = float(1.0);
    //ENDIF
    }
    u_xlat25 = dot(u_xlat3, unity_OcclusionMaskSelector);
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat4.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat26 = dot(vs_TEXCOORD1.xyz, u_xlat2.xyz);
    u_xlat26 = u_xlat26 + u_xlat26;
    u_xlat3.xzw = u_xlat2.xyz * (-vec3(u_xlat26)) + vs_TEXCOORD1.xyz;
    u_xlat5.xyz = vec3(u_xlat25) * _LightColor0.xyz;
    u_xlat6.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat25 = (-u_xlat4.x) * 0.699999988 + 1.70000005;
    u_xlat25 = u_xlat25 * u_xlat4.x;
    u_xlat25 = u_xlat25 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat3.xzw, u_xlat25);
    u_xlat16_25 = u_xlat10_7.w + -1.0;
    u_xlat25 = unity_SpecCube0_HDR.w * u_xlat16_25 + 1.0;
    u_xlat25 = u_xlat25 * unity_SpecCube0_HDR.x;
    u_xlat3.xzw = u_xlat10_7.xyz * vec3(u_xlat25);
    u_xlat3.xyz = u_xlat10_3.yyy * u_xlat3.xzw;
    u_xlat25 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat26 = u_xlat25 + u_xlat25;
    u_xlat7.xyz = u_xlat2.xyz * (-vec3(u_xlat26)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat25 = u_xlat25;
    u_xlat25 = clamp(u_xlat25, 0.0, 1.0);
    u_xlat7.x = dot(u_xlat7.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat7.y = (-u_xlat25) + 1.0;
    u_xlat10.xy = u_xlat7.xy * u_xlat7.xy;
    u_xlat4.yz = u_xlat10.xy * u_xlat10.xy;
    u_xlat24 = (-u_xlat24) + _Glossiness;
    u_xlat24 = u_xlat24 + 1.0;
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat10_7 = texture(unity_NHxRoughness, u_xlat4.yw);
    u_xlat16_25 = u_xlat10_7.w * 16.0;
    u_xlat10.xyz = vec3(u_xlat16_25) * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat4.xyw = u_xlat2.xxx * u_xlat5.xyz;
    u_xlat5.xyz = (-u_xlat0.xyz) + vec3(u_xlat24);
    u_xlat0.xyz = u_xlat4.zzz * u_xlat5.xyz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    u_xlat0.xyz = u_xlat6.xyz * u_xlat1.xyz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat10.xyz * u_xlat4.xyw + u_xlat0.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 192
  Matrix4x4 unity_WorldToObject at 256
  Matrix4x4 unity_MatrixVP at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHBr at 152
  VectorHalf4 unity_SHBg at 160
  VectorHalf4 unity_SHBb at 168
  VectorHalf4 unity_SHC at 176
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    u_xlat2.w = u_xlat1.z;
    u_xlat3.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat3.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat3.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat3.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat3 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat1);
    u_xlat1 = u_xlat1 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_2 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz * u_xlat3.xyz + float3(u_xlat16_6.xyz));
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat3 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat1);
    u_xlat1 = u_xlat1 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat3.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat19 = u_xlat2.y * u_xlat2.y;
    u_xlat19 = u_xlat2.x * u_xlat2.x + (-u_xlat19);
    u_xlat2 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat2);
    u_xlat4.y = dot(unity_SHBg, u_xlat2);
    u_xlat4.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat19) + u_xlat4.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz * u_xlat3.xyz + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
vec4 u_xlat10_6;
vec3 u_xlat7;
vec4 u_xlat8;
vec4 u_xlat10_8;
vec3 u_xlat9;
vec4 u_xlat10_9;
vec3 u_xlat10;
vec4 u_xlat10_10;
vec3 u_xlat11;
vec3 u_xlat12;
bvec3 u_xlatb12;
vec3 u_xlat13;
bvec3 u_xlatb14;
vec3 u_xlat17;
float u_xlat18;
vec3 u_xlat20;
float u_xlat32;
float u_xlat33;
float u_xlat35;
float u_xlat45;
float u_xlat46;
float u_xlat47;
float u_xlat16_47;
bool u_xlatb47;
float u_xlat48;
float u_xlat16_48;
bool u_xlatb48;
float u_xlat49;
bool u_xlatb49;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat45 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat45) * u_xlat1.xyz;
    u_xlat46 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat2.xyz = vec3(u_xlat46) * vs_TEXCOORD4.xyz;
    u_xlat46 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat3.xyz = vec3(u_xlat46) * vs_TEXCOORD1.xyz;
    u_xlat4.x = vs_TEXCOORD2.w;
    u_xlat4.y = vs_TEXCOORD3.w;
    u_xlat4.z = vs_TEXCOORD4.w;
    u_xlat5.xyz = (-u_xlat4.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat48 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = u_xlat4.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat49 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat49 = sqrt(u_xlat49);
    u_xlat49 = (-u_xlat48) + u_xlat49;
    u_xlat48 = unity_ShadowFadeCenterAndType.w * u_xlat49 + u_xlat48;
    u_xlat48 = u_xlat48 * _LightShadowData.z + _LightShadowData.w;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlatb49 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb49){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat20.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat20.xyz;
        u_xlat20.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat20.xyz;
        u_xlat20.xyz = u_xlat20.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat20.xyz : u_xlat4.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat20.x = u_xlat5.y * 0.25 + 0.75;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat20.x, u_xlat6.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat5.x = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat5.x = clamp(u_xlat5.x, 0.0, 1.0);
    u_xlat20.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_6 = texture(_ShadowMapTexture, u_xlat20.xy);
    u_xlat48 = u_xlat48 + u_xlat10_6.x;
    u_xlat48 = clamp(u_xlat48, 0.0, 1.0);
    u_xlat5.x = min(u_xlat48, u_xlat5.x);
    u_xlat48 = (u_xlatb49) ? u_xlat5.x : u_xlat48;
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat5.x = (-_OcclusionStrength) + 1.0;
    u_xlat5.x = u_xlat10_5.y * _OcclusionStrength + u_xlat5.x;
    u_xlat20.x = (-_Glossiness) + 1.0;
    u_xlat35 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat35 = u_xlat35 + u_xlat35;
    u_xlat6.xyz = u_xlat2.xyz * (-vec3(u_xlat35)) + u_xlat3.xyz;
    u_xlat7.xyz = vec3(u_xlat48) * _LightColor0.xyz;
    if(u_xlatb49){
        u_xlatb48 = unity_ProbeVolumeParams.y==1.0;
        u_xlat8.xyz = vs_TEXCOORD3.www * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD2.www + u_xlat8.xyz;
        u_xlat8.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD4.www + u_xlat8.xyz;
        u_xlat8.xyz = u_xlat8.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat8.xyz = (bool(u_xlatb48)) ? u_xlat8.xyz : u_xlat4.xyz;
        u_xlat8.xyz = u_xlat8.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat8.yzw = u_xlat8.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat48 = u_xlat8.y * 0.25;
        u_xlat49 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat35 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat48 = max(u_xlat48, u_xlat49);
        u_xlat8.x = min(u_xlat35, u_xlat48);
        u_xlat10_9 = texture(unity_ProbeVolumeSH, u_xlat8.xzw);
        u_xlat10.xyz = u_xlat8.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_10 = texture(unity_ProbeVolumeSH, u_xlat10.xyz);
        u_xlat8.xyz = u_xlat8.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(u_xlat10_9, u_xlat2);
        u_xlat9.y = dot(u_xlat10_10, u_xlat2);
        u_xlat9.z = dot(u_xlat10_8, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat9.x = dot(unity_SHAr, u_xlat2);
        u_xlat9.y = dot(unity_SHAg, u_xlat2);
        u_xlat9.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat8.xyz = u_xlat9.xyz + vs_TEXCOORD5.xyz;
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat8.xyz = log2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat8.xyz = exp2(u_xlat8.xyz);
    u_xlat8.xyz = u_xlat8.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat8.xyz = max(u_xlat8.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb47 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb47){
        u_xlat47 = dot(u_xlat6.xyz, u_xlat6.xyz);
        u_xlat47 = inversesqrt(u_xlat47);
        u_xlat9.xyz = vec3(u_xlat47) * u_xlat6.xyz;
        u_xlat10.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
        u_xlat11.xyz = (-u_xlat4.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
        u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
        u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
        u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
        u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
        u_xlat47 = min(u_xlat10.y, u_xlat10.x);
        u_xlat47 = min(u_xlat10.z, u_xlat47);
        u_xlat10.xyz = u_xlat4.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat9.xyz = u_xlat9.xyz * vec3(u_xlat47) + u_xlat10.xyz;
    } else {
        u_xlat9.xyz = u_xlat6.xyz;
    //ENDIF
    }
    u_xlat47 = (-u_xlat20.x) * 0.699999988 + 1.70000005;
    u_xlat47 = u_xlat47 * u_xlat20.x;
    u_xlat47 = u_xlat47 * 6.0;
    u_xlat10_9 = textureLod(unity_SpecCube0, u_xlat9.xyz, u_xlat47);
    u_xlat16_48 = u_xlat10_9.w + -1.0;
    u_xlat48 = unity_SpecCube0_HDR.w * u_xlat16_48 + 1.0;
    u_xlat48 = u_xlat48 * unity_SpecCube0_HDR.x;
    u_xlat10.xyz = u_xlat10_9.xyz * vec3(u_xlat48);
    u_xlatb49 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb49){
        u_xlatb49 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb49){
            u_xlat49 = dot(u_xlat6.xyz, u_xlat6.xyz);
            u_xlat49 = inversesqrt(u_xlat49);
            u_xlat11.xyz = vec3(u_xlat49) * u_xlat6.xyz;
            u_xlat12.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat12.xyz = u_xlat12.xyz / u_xlat11.xyz;
            u_xlat13.xyz = (-u_xlat4.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat13.xyz = u_xlat13.xyz / u_xlat11.xyz;
            u_xlatb14.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat11.xyzx).xyz;
            u_xlat12.x = (u_xlatb14.x) ? u_xlat12.x : u_xlat13.x;
            u_xlat12.y = (u_xlatb14.y) ? u_xlat12.y : u_xlat13.y;
            u_xlat12.z = (u_xlatb14.z) ? u_xlat12.z : u_xlat13.z;
            u_xlat49 = min(u_xlat12.y, u_xlat12.x);
            u_xlat49 = min(u_xlat12.z, u_xlat49);
            u_xlat4.xyz = u_xlat4.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = u_xlat11.xyz * vec3(u_xlat49) + u_xlat4.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat6.xyz, u_xlat47);
        u_xlat16_47 = u_xlat10_4.w + -1.0;
        u_xlat47 = unity_SpecCube1_HDR.w * u_xlat16_47 + 1.0;
        u_xlat47 = u_xlat47 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat47);
        u_xlat6.xyz = vec3(u_xlat48) * u_xlat10_9.xyz + (-u_xlat4.xyz);
        u_xlat10.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = u_xlat5.xxx * u_xlat10.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat46) + _WorldSpaceLightPos0.xyz;
    u_xlat46 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat46 = max(u_xlat46, 0.00100000005);
    u_xlat46 = inversesqrt(u_xlat46);
    u_xlat6.xyz = vec3(u_xlat46) * u_xlat6.xyz;
    u_xlat46 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat47 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat47 = clamp(u_xlat47, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat17.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat17.x = clamp(u_xlat17.x, 0.0, 1.0);
    u_xlat32 = u_xlat17.x * u_xlat17.x;
    u_xlat32 = dot(vec2(u_xlat32), u_xlat20.xx);
    u_xlat32 = u_xlat32 + -0.5;
    u_xlat3.x = (-u_xlat47) + 1.0;
    u_xlat18 = u_xlat3.x * u_xlat3.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat3.x = u_xlat3.x * u_xlat18;
    u_xlat3.x = u_xlat32 * u_xlat3.x + 1.0;
    u_xlat18 = -abs(u_xlat46) + 1.0;
    u_xlat33 = u_xlat18 * u_xlat18;
    u_xlat33 = u_xlat33 * u_xlat33;
    u_xlat18 = u_xlat18 * u_xlat33;
    u_xlat32 = u_xlat32 * u_xlat18 + 1.0;
    u_xlat32 = u_xlat32 * u_xlat3.x;
    u_xlat32 = u_xlat47 * u_xlat32;
    u_xlat3.x = u_xlat20.x * u_xlat20.x;
    u_xlat33 = (-u_xlat20.x) * u_xlat20.x + 1.0;
    u_xlat48 = abs(u_xlat46) * u_xlat33 + u_xlat3.x;
    u_xlat33 = u_xlat47 * u_xlat33 + u_xlat3.x;
    u_xlat46 = abs(u_xlat46) * u_xlat33;
    u_xlat46 = u_xlat47 * u_xlat48 + u_xlat46;
    u_xlat46 = u_xlat46 + 9.99999975e-06;
    u_xlat46 = 0.5 / u_xlat46;
    u_xlat33 = u_xlat3.x * u_xlat3.x;
    u_xlat48 = u_xlat2.x * u_xlat33 + (-u_xlat2.x);
    u_xlat2.x = u_xlat48 * u_xlat2.x + 1.0;
    u_xlat33 = u_xlat33 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat33 / u_xlat2.x;
    u_xlat46 = u_xlat46 * u_xlat2.x;
    u_xlat46 = u_xlat46 * 3.14159274;
    u_xlat46 = max(u_xlat46, 9.99999975e-05);
    u_xlat46 = sqrt(u_xlat46);
    u_xlat46 = u_xlat47 * u_xlat46;
    u_xlat2.x = u_xlat3.x * u_xlat20.x;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat47 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb47 = u_xlat47!=0.0;
    u_xlat47 = u_xlatb47 ? 1.0 : float(0.0);
    u_xlat46 = u_xlat46 * u_xlat47;
    u_xlat45 = (-u_xlat45) + _Glossiness;
    u_xlat45 = u_xlat45 + 1.0;
    u_xlat45 = clamp(u_xlat45, 0.0, 1.0);
    u_xlat3.xzw = vec3(u_xlat32) * u_xlat7.xyz;
    u_xlat3.xzw = u_xlat8.xyz * u_xlat5.xxx + u_xlat3.xzw;
    u_xlat5.xyz = u_xlat7.xyz * vec3(u_xlat46);
    u_xlat46 = (-u_xlat17.x) + 1.0;
    u_xlat17.x = u_xlat46 * u_xlat46;
    u_xlat17.x = u_xlat17.x * u_xlat17.x;
    u_xlat46 = u_xlat46 * u_xlat17.x;
    u_xlat17.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat17.xyz = u_xlat17.xyz * vec3(u_xlat46) + u_xlat0.xyz;
    u_xlat17.xyz = u_xlat17.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat17.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat45);
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

 }
 Pass {
  Name "FORWARD_DELTA"
  Tags { "LIGHTMODE"="FORWARDADD" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite Off
  Blend [_SrcBlend] One
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: POINT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float4 u_xlat4;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half u_xlat16_11;
    float u_xlat24;
    bool u_xlatb24;
    float u_xlat25;
    half u_xlat16_26;
    half u_xlat16_27;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_26 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_3.x = rsqrt(u_xlat16_3.x);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD4.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb24 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb24){
        u_xlatb24 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb24)) ? u_xlat4.xyz : input.TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat4.yzw = u_xlat4.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat24 = u_xlat4.y * 0.25 + 0.75;
        u_xlat25 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat24, u_xlat25);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xzw);
        u_xlat16_4 = half4(u_xlat4);
    } else {
        u_xlat16_4.x = half(1.0);
        u_xlat16_4.y = half(1.0);
        u_xlat16_4.z = half(1.0);
        u_xlat16_4.w = half(1.0);
    }
    u_xlat16_27 = dot(u_xlat16_4, Globals.unity_OcclusionMaskSelector);
    u_xlat16_27 = clamp(u_xlat16_27, 0.0h, 1.0h);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xx).w;
    u_xlat16_0.x = half(u_xlat16_27 * u_xlat16_0.x);
    u_xlat16_5.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_27 = dot((-input.TEXCOORD1.xyz), u_xlat16_3.xyz);
    u_xlat16_27 = half(u_xlat16_27 + u_xlat16_27);
    u_xlat16_6.xyz = half3(u_xlat16_3.xyz * (-half3(u_xlat16_27)) + (-input.TEXCOORD1.xyz));
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_3.x = dot(u_xlat16_3.xyz, u_xlat16_7.xyz);
    u_xlat16_3.x = clamp(u_xlat16_3.x, 0.0h, 1.0h);
    u_xlat16_11 = dot(u_xlat16_6.xyz, u_xlat16_7.xyz);
    u_xlat16_11 = half(u_xlat16_11 * u_xlat16_11);
    u_xlat16_6.x = half(u_xlat16_11 * u_xlat16_11);
    u_xlat16_6.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_6.xy)).w;
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 16.0);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xxx);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_26) + u_xlat16_2.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat16_2;
vec4 u_xlat10_2;
vec3 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec3 u_xlat5;
float u_xlat18;
float u_xlat19;
bool u_xlatb19;
float u_xlat20;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat19 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * vs_TEXCOORD4.xyz;
    u_xlat3.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat3.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat3.xyz;
    u_xlat3.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat3.xyz;
    u_xlat3.xyz = u_xlat3.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb19 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb19){
        u_xlatb19 = unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb19)) ? u_xlat4.xyz : vs_TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19 = u_xlat4.y * 0.25 + 0.75;
        u_xlat20 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19, u_xlat20);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat19 = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat20 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat10_3 = texture(_LightTexture0, vec2(u_xlat20));
    u_xlat19 = u_xlat19 * u_xlat10_3.w;
    u_xlat3.xyz = vec3(u_xlat19) * _LightColor0.xyz;
    u_xlat19 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat19 = u_xlat19 + u_xlat19;
    u_xlat4.xyz = u_xlat2.xyz * (-vec3(u_xlat19)) + (-vs_TEXCOORD1.xyz);
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat19 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat5.xyz);
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.y = (-_Glossiness) + 1.0;
    u_xlat10_2 = texture(unity_NHxRoughness, u_xlat2.xy);
    u_xlat16_2 = u_xlat10_2.w * 16.0;
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat16_2);
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat18) + u_xlat0.xyz;
    u_xlat1.xyz = vec3(u_xlat19) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "unity_NHxRoughness" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (148 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (1) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float3 u_xlat7;
    half u_xlat16_10;
    float u_xlat22;
    half u_xlat16_22;
    half u_xlat16_23;
    half u_xlat16_24;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_23 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_3.x = rsqrt(u_xlat16_3.x);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD4.xyz);
    u_xlatb0 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb0){
        u_xlatb0 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat7.xyz;
        u_xlat7.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat0.xyz = (bool(u_xlatb0)) ? u_xlat7.xyz : input.TEXCOORD5.xyz;
        u_xlat0.xyz = u_xlat0.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat0.yzw = u_xlat0.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat7.x = u_xlat0.y * 0.25 + 0.75;
        u_xlat22 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat0.x = max(u_xlat7.x, u_xlat22);
        u_xlat0 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat0.xzw);
        u_xlat16_0 = half4(u_xlat0);
    } else {
        u_xlat16_0.x = half(1.0);
        u_xlat16_0.y = half(1.0);
        u_xlat16_0.z = half(1.0);
        u_xlat16_0.w = half(1.0);
    }
    u_xlat16_24 = dot(u_xlat16_0, Globals.unity_OcclusionMaskSelector);
    u_xlat16_24 = clamp(u_xlat16_24, 0.0h, 1.0h);
    u_xlat16_4.xyz = half3(half3(u_xlat16_24) * Globals._LightColor0.xyz);
    u_xlat16_24 = dot((-input.TEXCOORD1.xyz), u_xlat16_3.xyz);
    u_xlat16_24 = half(u_xlat16_24 + u_xlat16_24);
    u_xlat16_5.xyz = half3(u_xlat16_3.xyz * (-half3(u_xlat16_24)) + (-input.TEXCOORD1.xyz));
    u_xlat16_6.x = input.TEXCOORD2.w;
    u_xlat16_6.y = input.TEXCOORD3.w;
    u_xlat16_6.z = input.TEXCOORD4.w;
    u_xlat16_3.x = dot(u_xlat16_3.xyz, u_xlat16_6.xyz);
    u_xlat16_3.x = clamp(u_xlat16_3.x, 0.0h, 1.0h);
    u_xlat16_10 = dot(u_xlat16_5.xyz, u_xlat16_6.xyz);
    u_xlat16_10 = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_5.x = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_5.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_22 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_5.xy)).w;
    u_xlat16_22 = half(float(u_xlat16_22) * 16.0);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * half3(u_xlat16_22));
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_23) + u_xlat16_2.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * u_xlat16_4.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat16_2;
vec4 u_xlat10_2;
vec4 u_xlat3;
vec3 u_xlat4;
vec3 u_xlat5;
float u_xlat18;
float u_xlat19;
bool u_xlatb19;
float u_xlat20;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat19 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * vs_TEXCOORD4.xyz;
    u_xlatb19 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb19){
        u_xlatb19 = unity_ProbeVolumeParams.y==1.0;
        u_xlat3.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat3.xyz;
        u_xlat3.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat3.xyz;
        u_xlat3.xyz = u_xlat3.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb19)) ? u_xlat3.xyz : vs_TEXCOORD5.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat3.yzw = u_xlat3.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19 = u_xlat3.y * 0.25 + 0.75;
        u_xlat20 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat3.x = max(u_xlat19, u_xlat20);
        u_xlat3 = texture(unity_ProbeVolumeSH, u_xlat3.xzw);
    } else {
        u_xlat3.x = float(1.0);
        u_xlat3.y = float(1.0);
        u_xlat3.z = float(1.0);
        u_xlat3.w = float(1.0);
    //ENDIF
    }
    u_xlat19 = dot(u_xlat3, unity_OcclusionMaskSelector);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat3.xyz = vec3(u_xlat19) * _LightColor0.xyz;
    u_xlat19 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat19 = u_xlat19 + u_xlat19;
    u_xlat4.xyz = u_xlat2.xyz * (-vec3(u_xlat19)) + (-vs_TEXCOORD1.xyz);
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat19 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat5.xyz);
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.y = (-_Glossiness) + 1.0;
    u_xlat10_2 = texture(unity_NHxRoughness, u_xlat2.xy);
    u_xlat16_2 = u_xlat10_2.w * 16.0;
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat16_2);
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat18) + u_xlat0.xyz;
    u_xlat1.xyz = vec3(u_xlat19) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3
Set 3D Texture "unity_ProbeVolumeSH" to slot 4

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (4) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float4 u_xlat4;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float2 u_xlat6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_12;
    float u_xlat13;
    half u_xlat16_27;
    float u_xlat28;
    bool u_xlatb28;
    half u_xlat16_29;
    half u_xlat16_30;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_29 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_3.x = rsqrt(u_xlat16_3.x);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD4.xyz);
    u_xlat0 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * input.TEXCOORD5.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * input.TEXCOORD5.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlatb28 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb28){
        u_xlatb28 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb28)) ? u_xlat4.xyz : input.TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat4.yzw = u_xlat4.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat28 = u_xlat4.y * 0.25 + 0.75;
        u_xlat13 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat28, u_xlat13);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xzw);
        u_xlat16_4 = half4(u_xlat4);
    } else {
        u_xlat16_4.x = half(1.0);
        u_xlat16_4.y = half(1.0);
        u_xlat16_4.z = half(1.0);
        u_xlat16_4.w = half(1.0);
    }
    u_xlat16_30 = dot(u_xlat16_4, Globals.unity_OcclusionMaskSelector);
    u_xlat16_30 = clamp(u_xlat16_30, 0.0h, 1.0h);
    u_xlatb28 = 0.0<u_xlat0.z;
    u_xlat16_5.x = (u_xlatb28) ? 1.0 : 0.0;
    u_xlat6.xy = u_xlat0.xy / u_xlat0.ww;
    u_xlat6.xy = u_xlat6.xy + float2(0.5, 0.5);
    u_xlat16_27 = _LightTexture0.sample(sampler_LightTexture0, u_xlat6.xy).w;
    u_xlat16_5.x = half(u_xlat16_27 * u_xlat16_5.x);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_5.x = half(u_xlat16_0.x * u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_30 * u_xlat16_5.x);
    u_xlat16_5.xyz = half3(half3(u_xlat16_30) * Globals._LightColor0.xyz);
    u_xlat16_30 = dot((-input.TEXCOORD1.xyz), u_xlat16_3.xyz);
    u_xlat16_30 = half(u_xlat16_30 + u_xlat16_30);
    u_xlat16_7.xyz = half3(u_xlat16_3.xyz * (-half3(u_xlat16_30)) + (-input.TEXCOORD1.xyz));
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_3.x = dot(u_xlat16_3.xyz, u_xlat16_8.xyz);
    u_xlat16_3.x = clamp(u_xlat16_3.x, 0.0h, 1.0h);
    u_xlat16_12 = dot(u_xlat16_7.xyz, u_xlat16_8.xyz);
    u_xlat16_12 = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_7.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_7.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_7.xy)).w;
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 16.0);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xxx);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_29) + u_xlat16_2.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat16_2;
vec4 u_xlat10_2;
vec4 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat5;
float u_xlat18;
float u_xlat19;
bool u_xlatb19;
float u_xlat20;
bool u_xlatb20;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat19 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * vs_TEXCOORD4.xyz;
    u_xlat3 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat3 = hlslcc_mtx4x4unity_WorldToLight[0] * vs_TEXCOORD5.xxxx + u_xlat3;
    u_xlat3 = hlslcc_mtx4x4unity_WorldToLight[2] * vs_TEXCOORD5.zzzz + u_xlat3;
    u_xlat3 = u_xlat3 + hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlatb19 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb19){
        u_xlatb19 = unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb19)) ? u_xlat4.xyz : vs_TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19 = u_xlat4.y * 0.25 + 0.75;
        u_xlat20 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19, u_xlat20);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat19 = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlatb20 = 0.0<u_xlat3.z;
    u_xlat20 = u_xlatb20 ? 1.0 : float(0.0);
    u_xlat4.xy = u_xlat3.xy / u_xlat3.ww;
    u_xlat4.xy = u_xlat4.xy + vec2(0.5, 0.5);
    u_xlat10_4 = texture(_LightTexture0, u_xlat4.xy);
    u_xlat20 = u_xlat20 * u_xlat10_4.w;
    u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat10_3 = texture(_LightTextureB0, u_xlat3.xx);
    u_xlat20 = u_xlat20 * u_xlat10_3.w;
    u_xlat19 = u_xlat19 * u_xlat20;
    u_xlat3.xyz = vec3(u_xlat19) * _LightColor0.xyz;
    u_xlat19 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat19 = u_xlat19 + u_xlat19;
    u_xlat4.xyz = u_xlat2.xyz * (-vec3(u_xlat19)) + (-vs_TEXCOORD1.xyz);
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat19 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat5.xyz);
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.y = (-_Glossiness) + 1.0;
    u_xlat10_2 = texture(unity_NHxRoughness, u_xlat2.xy);
    u_xlat16_2 = u_xlat10_2.w * 16.0;
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat16_2);
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat18) + u_xlat0.xyz;
    u_xlat1.xyz = vec3(u_xlat19) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTextureB0" to slot 1
Set CUBE Texture "_LightTexture0" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3
Set 3D Texture "unity_ProbeVolumeSH" to slot 4

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (1) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (1) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (4) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float4 u_xlat4;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half u_xlat16_11;
    float u_xlat24;
    half u_xlat16_24;
    bool u_xlatb24;
    float u_xlat25;
    half u_xlat16_26;
    half u_xlat16_27;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_26 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_3.x = rsqrt(u_xlat16_3.x);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD4.xyz);
    u_xlat0.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb24 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb24){
        u_xlatb24 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb24)) ? u_xlat4.xyz : input.TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat4.yzw = u_xlat4.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat24 = u_xlat4.y * 0.25 + 0.75;
        u_xlat25 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat24, u_xlat25);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xzw);
        u_xlat16_4 = half4(u_xlat4);
    } else {
        u_xlat16_4.x = half(1.0);
        u_xlat16_4.y = half(1.0);
        u_xlat16_4.z = half(1.0);
        u_xlat16_4.w = half(1.0);
    }
    u_xlat16_27 = dot(u_xlat16_4, Globals.unity_OcclusionMaskSelector);
    u_xlat16_27 = clamp(u_xlat16_27, 0.0h, 1.0h);
    u_xlat24 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_24 = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat24)).w;
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xyz).w;
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_24);
    u_xlat16_0.x = half(u_xlat16_27 * u_xlat16_0.x);
    u_xlat16_5.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_27 = dot((-input.TEXCOORD1.xyz), u_xlat16_3.xyz);
    u_xlat16_27 = half(u_xlat16_27 + u_xlat16_27);
    u_xlat16_6.xyz = half3(u_xlat16_3.xyz * (-half3(u_xlat16_27)) + (-input.TEXCOORD1.xyz));
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_3.x = dot(u_xlat16_3.xyz, u_xlat16_7.xyz);
    u_xlat16_3.x = clamp(u_xlat16_3.x, 0.0h, 1.0h);
    u_xlat16_11 = dot(u_xlat16_6.xyz, u_xlat16_7.xyz);
    u_xlat16_11 = half(u_xlat16_11 * u_xlat16_11);
    u_xlat16_6.x = half(u_xlat16_11 * u_xlat16_11);
    u_xlat16_6.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_6.xy)).w;
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 16.0);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xxx);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_26) + u_xlat16_2.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat16_2;
vec4 u_xlat10_2;
vec3 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat5;
float u_xlat18;
float u_xlat19;
bool u_xlatb19;
float u_xlat20;
float u_xlat16_20;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat19 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * vs_TEXCOORD4.xyz;
    u_xlat3.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat3.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat3.xyz;
    u_xlat3.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat3.xyz;
    u_xlat3.xyz = u_xlat3.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlatb19 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb19){
        u_xlatb19 = unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb19)) ? u_xlat4.xyz : vs_TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19 = u_xlat4.y * 0.25 + 0.75;
        u_xlat20 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19, u_xlat20);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat19 = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat20 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat10_4 = texture(_LightTextureB0, vec2(u_xlat20));
    u_xlat10_3 = texture(_LightTexture0, u_xlat3.xyz);
    u_xlat16_20 = u_xlat10_3.w * u_xlat10_4.w;
    u_xlat19 = u_xlat19 * u_xlat16_20;
    u_xlat3.xyz = vec3(u_xlat19) * _LightColor0.xyz;
    u_xlat19 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat19 = u_xlat19 + u_xlat19;
    u_xlat4.xyz = u_xlat2.xyz * (-vec3(u_xlat19)) + (-vs_TEXCOORD1.xyz);
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat19 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat5.xyz);
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.y = (-_Glossiness) + 1.0;
    u_xlat10_2 = texture(unity_NHxRoughness, u_xlat2.xy);
    u_xlat16_2 = u_xlat10_2.w * 16.0;
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat16_2);
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat18) + u_xlat0.xyz;
    u_xlat1.xyz = vec3(u_xlat19) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 32
  Matrix4x4 unity_WorldToLight at 160
  VectorHalf4 unity_OcclusionMaskSelector at 0
  Vector4 unity_ProbeVolumeParams at 16
  Vector3 unity_ProbeVolumeSizeInv at 96
  Vector3 unity_ProbeVolumeMin at 112
  VectorHalf4 _LightColor0 at 128
  VectorHalf4 _Color at 136
  ScalarHalf _Metallic at 144
  ScalarHalf _Glossiness at 146
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_OcclusionMaskSelector;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float2 u_xlat0;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float4 u_xlat4;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half u_xlat16_11;
    float u_xlat16;
    bool u_xlatb16;
    float u_xlat24;
    half u_xlat16_26;
    half u_xlat16_27;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_26 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_3.x = rsqrt(u_xlat16_3.x);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD4.xyz);
    u_xlat0.xy = input.TEXCOORD5.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * input.TEXCOORD5.xx + u_xlat0.xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * input.TEXCOORD5.zz + u_xlat0.xy;
    u_xlat0.xy = u_xlat0.xy + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlatb16 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb16){
        u_xlatb16 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb16)) ? u_xlat4.xyz : input.TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat4.yzw = u_xlat4.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat16 = u_xlat4.y * 0.25 + 0.75;
        u_xlat24 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat24, u_xlat16);
        u_xlat4 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xzw);
        u_xlat16_4 = half4(u_xlat4);
    } else {
        u_xlat16_4.x = half(1.0);
        u_xlat16_4.y = half(1.0);
        u_xlat16_4.z = half(1.0);
        u_xlat16_4.w = half(1.0);
    }
    u_xlat16_27 = dot(u_xlat16_4, Globals.unity_OcclusionMaskSelector);
    u_xlat16_27 = clamp(u_xlat16_27, 0.0h, 1.0h);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xy).w;
    u_xlat16_0.x = half(u_xlat16_27 * u_xlat16_0.x);
    u_xlat16_5.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_27 = dot((-input.TEXCOORD1.xyz), u_xlat16_3.xyz);
    u_xlat16_27 = half(u_xlat16_27 + u_xlat16_27);
    u_xlat16_6.xyz = half3(u_xlat16_3.xyz * (-half3(u_xlat16_27)) + (-input.TEXCOORD1.xyz));
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_3.x = dot(u_xlat16_3.xyz, u_xlat16_7.xyz);
    u_xlat16_3.x = clamp(u_xlat16_3.x, 0.0h, 1.0h);
    u_xlat16_11 = dot(u_xlat16_6.xyz, u_xlat16_7.xyz);
    u_xlat16_11 = half(u_xlat16_11 * u_xlat16_11);
    u_xlat16_6.x = half(u_xlat16_11 * u_xlat16_11);
    u_xlat16_6.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_6.xy)).w;
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 16.0);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xxx);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_26) + u_xlat16_2.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xxx * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat16_2;
vec4 u_xlat10_2;
vec3 u_xlat3;
vec4 u_xlat10_3;
vec4 u_xlat4;
vec3 u_xlat5;
float u_xlat18;
float u_xlat19;
bool u_xlatb19;
float u_xlat20;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat19 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * vs_TEXCOORD4.xyz;
    u_xlat3.xy = vs_TEXCOORD5.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat3.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * vs_TEXCOORD5.xx + u_xlat3.xy;
    u_xlat3.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * vs_TEXCOORD5.zz + u_xlat3.xy;
    u_xlat3.xy = u_xlat3.xy + hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlatb19 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb19){
        u_xlatb19 = unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb19)) ? u_xlat4.xyz : vs_TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat19 = u_xlat4.y * 0.25 + 0.75;
        u_xlat20 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat19, u_xlat20);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat19 = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat10_3 = texture(_LightTexture0, u_xlat3.xy);
    u_xlat19 = u_xlat19 * u_xlat10_3.w;
    u_xlat3.xyz = vec3(u_xlat19) * _LightColor0.xyz;
    u_xlat19 = dot((-vs_TEXCOORD1.xyz), u_xlat2.xyz);
    u_xlat19 = u_xlat19 + u_xlat19;
    u_xlat4.xyz = u_xlat2.xyz * (-vec3(u_xlat19)) + (-vs_TEXCOORD1.xyz);
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat19 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat5.xyz);
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.x = u_xlat2.x * u_xlat2.x;
    u_xlat2.y = (-_Glossiness) + 1.0;
    u_xlat10_2 = texture(unity_NHxRoughness, u_xlat2.xy);
    u_xlat16_2 = u_xlat10_2.w * 16.0;
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat16_2);
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat18) + u_xlat0.xyz;
    u_xlat1.xyz = vec3(u_xlat19) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SPOT SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3
Set 2D Texture "_ShadowMapTexture" to slot 4

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 unity_WorldToShadow[4] at 0
  Matrix4x4 unity_WorldToLight at 288
  VectorHalf4 _LightShadowData at 256
  VectorHalf4 _LightColor0 at 264
  VectorHalf4 _Color at 272
  ScalarHalf _Metallic at 280
  ScalarHalf _Glossiness at 282
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

constexpr sampler _mtl_xl_shadow_sampler(address::clamp_to_edge, filter::linear, compare_func::greater_equal);
fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    depth2d<float, access::sample > _ShadowMapTexture [[ texture (4) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half u_xlat16_0;
    float2 u_xlat1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half u_xlat16_7;
    half u_xlat16_15;
    half u_xlat16_17;
    u_xlat0 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * input.TEXCOORD5.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * input.TEXCOORD5.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlat1.xy = u_xlat0.xy / u_xlat0.ww;
    u_xlat1.xy = u_xlat1.xy + float2(0.5, 0.5);
    u_xlat16_15 = _LightTexture0.sample(sampler_LightTexture0, u_xlat1.xy).w;
    u_xlatb1 = 0.0<u_xlat0.z;
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat16_0 = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_2.x = (u_xlatb1) ? 1.0 : 0.0;
    u_xlat16_2.x = half(u_xlat16_15 * u_xlat16_2.x);
    u_xlat16_2.x = half(u_xlat16_0 * u_xlat16_2.x);
    u_xlat0 = input.TEXCOORD5.yyyy * Globals.hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToShadow[0] * input.TEXCOORD5.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_WorldToShadow[2] * input.TEXCOORD5.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_WorldToShadow[3];
    u_xlat0.xyz = u_xlat0.xyz / u_xlat0.www;
    u_xlat16_0 = _ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat0.xy, saturate(u_xlat0.z), level(0.0));
    u_xlat16_7 = half((-float(Globals._LightShadowData.x)) + 1.0);
    u_xlat16_7 = half(u_xlat16_0 * u_xlat16_7 + Globals._LightShadowData.x);
    u_xlat16_2.x = half(u_xlat16_7 * u_xlat16_2.x);
    u_xlat16_2.xyz = half3(u_xlat16_2.xxx * Globals._LightColor0.xyz);
    u_xlat16_17 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_17 = rsqrt(u_xlat16_17);
    u_xlat16_3.xyz = half3(half3(u_xlat16_17) * input.TEXCOORD4.xyz);
    u_xlat16_4.x = input.TEXCOORD2.w;
    u_xlat16_4.y = input.TEXCOORD3.w;
    u_xlat16_4.z = input.TEXCOORD4.w;
    u_xlat16_17 = dot(u_xlat16_3.xyz, u_xlat16_4.xyz);
    u_xlat16_17 = clamp(u_xlat16_17, 0.0h, 1.0h);
    u_xlat16_2.xyz = half3(half3(u_xlat16_17) * u_xlat16_2.xyz);
    u_xlat16_17 = dot((-input.TEXCOORD1.xyz), u_xlat16_3.xyz);
    u_xlat16_17 = half(u_xlat16_17 + u_xlat16_17);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * (-half3(u_xlat16_17)) + (-input.TEXCOORD1.xyz));
    u_xlat16_17 = dot(u_xlat16_3.xyz, u_xlat16_4.xyz);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_3.x = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_3.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_3.xy)).w;
    u_xlat16_0 = half(float(u_xlat16_0) * 16.0);
    u_xlat16_5.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_5.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_5.xyz = half3(u_xlat16_5.xyz * Globals._Color.xyz);
    u_xlat16_3.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_3.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_3.xyz = half3(half3(u_xlat16_0) * u_xlat16_3.xyz);
    u_xlat16_17 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_17) + u_xlat16_3.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 hlslcc_mtx4x4unity_WorldToShadow[16];
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2DShadow hlslcc_zcmp_ShadowMapTexture;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
vec4 u_xlat1;
vec4 u_xlat10_1;
vec3 u_xlat2;
vec4 u_xlat10_2;
vec3 u_xlat3;
float u_xlat10_3;
float u_xlat6;
float u_xlat9;
float u_xlat16_9;
bool u_xlatb9;
void main()
{
    u_xlat0 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat0 = hlslcc_mtx4x4unity_WorldToLight[0] * vs_TEXCOORD5.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_WorldToLight[2] * vs_TEXCOORD5.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_WorldToLight[3];
    u_xlat1.xy = u_xlat0.xy / u_xlat0.ww;
    u_xlat1.xy = u_xlat1.xy + vec2(0.5, 0.5);
    u_xlat10_1 = texture(_LightTexture0, u_xlat1.xy);
    u_xlatb9 = 0.0<u_xlat0.z;
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat10_2 = texture(_LightTextureB0, u_xlat0.xx);
    u_xlat0.x = u_xlatb9 ? 1.0 : float(0.0);
    u_xlat0.x = u_xlat10_1.w * u_xlat0.x;
    u_xlat0.x = u_xlat10_2.w * u_xlat0.x;
    u_xlat1 = vs_TEXCOORD5.yyyy * hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[0] * vs_TEXCOORD5.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[2] * vs_TEXCOORD5.zzzz + u_xlat1;
    u_xlat1 = u_xlat1 + hlslcc_mtx4x4unity_WorldToShadow[3];
    u_xlat3.xyz = u_xlat1.xyz / u_xlat1.www;
    vec3 txVec0 = vec3(u_xlat3.xy,u_xlat3.z);
    u_xlat10_3 = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec0, 0.0);
    u_xlat6 = (-_LightShadowData.x) + 1.0;
    u_xlat3.x = u_xlat10_3 * u_xlat6 + _LightShadowData.x;
    u_xlat0.x = u_xlat3.x * u_xlat0.x;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat9 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * vs_TEXCOORD4.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat1.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat9 = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat9 * u_xlat9;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_9 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat2.xyz = vec3(u_xlat16_9) * u_xlat2.xyz;
    u_xlat9 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = u_xlat1.xyz * vec3(u_xlat9) + u_xlat2.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat2.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat2.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat2.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat2.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (244 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 48
  Matrix4x4 unity_ProbeVolumeWorldToObject at 128
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_OcclusionMaskSelector at 16
  VectorHalf4 _LightShadowData at 24
  Vector4 unity_ShadowFadeCenterAndType at 32
  Vector4 unity_ProbeVolumeParams at 112
  Vector3 unity_ProbeVolumeSizeInv at 192
  Vector3 unity_ProbeVolumeMin at 208
  VectorHalf4 _LightColor0 at 224
  VectorHalf4 _Color at 232
  ScalarHalf _Metallic at 240
  ScalarHalf _Glossiness at 242
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    float3 u_xlat9;
    half u_xlat16_9;
    bool u_xlatb9;
    half u_xlat16_13;
    half u_xlat16_14;
    float2 u_xlat18;
    half u_xlat16_18;
    bool u_xlatb18;
    half u_xlat16_22;
    half u_xlat16_23;
    float u_xlat27;
    half u_xlat16_29;
    half u_xlat16_30;
    half u_xlat16_31;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_29 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_29));
    u_xlat16_29 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_4.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD4.xyz);
    u_xlat16_29 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_29 = rsqrt(u_xlat16_29);
    u_xlat16_5.xyz = half3(half3(u_xlat16_29) * input.TEXCOORD1.xyz);
    u_xlat0.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat1.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat1.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat1.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);
    u_xlat9.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat9.x = dot(u_xlat9.xyz, u_xlat9.xyz);
    u_xlat9.x = sqrt(u_xlat9.x);
    u_xlat9.x = (-u_xlat0.x) + u_xlat9.x;
    u_xlat0.x = Globals.unity_ShadowFadeCenterAndType.w * u_xlat9.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat0.x = clamp(u_xlat0.x, 0.0f, 1.0f);
    u_xlatb9 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb9){
        u_xlatb18 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat1.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat1.xyz;
        u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat1.xyz;
        u_xlat1.xyz = u_xlat1.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb18)) ? u_xlat1.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat18.x = u_xlat1.y * 0.25 + 0.75;
        u_xlat27 = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat27, u_xlat18.x);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_30 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_30 = clamp(u_xlat16_30, 0.0h, 1.0h);
    u_xlat18.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_18 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat18.xy).x;
    u_xlat16_31 = half(u_xlat0.x + float(u_xlat16_18));
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_30 = min(u_xlat16_30, u_xlat16_31);
    u_xlat16_30 = (u_xlatb9) ? u_xlat16_30 : u_xlat16_31;
    u_xlat16_6.xyz = half3(half3(u_xlat16_30) * Globals._LightColor0.xyz);
    u_xlat16_30 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_7.x = input.TEXCOORD2.w;
    u_xlat16_7.y = input.TEXCOORD3.w;
    u_xlat16_7.z = input.TEXCOORD4.w;
    u_xlat16_8.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_29) + u_xlat16_7.xyz);
    u_xlat16_29 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_29), 0.00100000005));
    u_xlat16_29 = rsqrt(u_xlat16_0.x);
    u_xlat16_8.xyz = half3(half3(u_xlat16_29) * u_xlat16_8.xyz);
    u_xlat16_29 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_31 = dot(u_xlat16_4.xyz, u_xlat16_7.xyz);
    u_xlat16_31 = clamp(u_xlat16_31, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_13 = dot(u_xlat16_7.xyz, u_xlat16_8.xyz);
    u_xlat16_13 = clamp(u_xlat16_13, 0.0h, 1.0h);
    u_xlat16_22 = half(u_xlat16_13 * u_xlat16_13);
    u_xlat16_22 = dot(half2(u_xlat16_22), half2(u_xlat16_30));
    u_xlat16_22 = half(float(u_xlat16_22) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_31)) + 1.0);
    u_xlat16_14 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_14);
    u_xlat16_5.x = half(float(u_xlat16_22) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_14 = half(-abs(float(u_xlat16_29)) + 1.0);
    u_xlat16_23 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_23);
    u_xlat16_22 = half(float(u_xlat16_22) * float(u_xlat16_14) + 1.0);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_5.x);
    u_xlat16_22 = half(u_xlat16_31 * u_xlat16_22);
    u_xlat16_5.x = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_30 = half((-float(u_xlat16_30)) * float(u_xlat16_30) + 1.0);
    u_xlat16_14 = half(abs(u_xlat16_29) * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_31 * u_xlat16_30 + u_xlat16_5.x);
    u_xlat16_29 = half(abs(u_xlat16_29) * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_14 + u_xlat16_29);
    u_xlat16_0.x = half(float(u_xlat16_29) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_29 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_30 = half(u_xlat16_4.x * u_xlat16_29 + (-u_xlat16_4.x));
    u_xlat16_9 = half(float(u_xlat16_30) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_18 = half(float(u_xlat16_29) * 0.318309873);
    u_xlat16_9 = half(float(u_xlat16_9) * float(u_xlat16_9) + 1.00000001e-07);
    u_xlat16_9 = half(u_xlat16_18 / u_xlat16_9);
    u_xlat16_29 = half(u_xlat16_9 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_29) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_29 = half(u_xlat16_31 * u_xlat16_0.x);
    u_xlat16_30 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_30!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_29 = half(u_xlat0.x * float(u_xlat16_29));
    u_xlat16_4.xzw = half3(half3(u_xlat16_22) * u_xlat16_6.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29));
    u_xlat16_29 = half((-float(u_xlat16_13)) + 1.0);
    u_xlat16_30 = half(u_xlat16_29 * u_xlat16_29);
    u_xlat16_30 = half(u_xlat16_30 * u_xlat16_30);
    u_xlat16_29 = half(u_xlat16_29 * u_xlat16_30);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_29) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat2.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz;
    u_xlat2.w = 0.0;
    vs_TEXCOORD2 = u_xlat2.wwwx;
    vs_TEXCOORD3 = u_xlat2.wwwy;
    vs_TEXCOORD4.w = u_xlat2.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    vs_TEXCOORD4.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat10_4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat11;
float u_xlat16;
float u_xlat17;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
bool u_xlatb23;
float u_xlat24;
bool u_xlatb24;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat5.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat5.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat5.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat22 = dot(u_xlat4.xyz, u_xlat5.xyz);
    u_xlat4.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat23 = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat23 = sqrt(u_xlat23);
    u_xlat23 = (-u_xlat22) + u_xlat23;
    u_xlat22 = unity_ShadowFadeCenterAndType.w * u_xlat23 + u_xlat22;
    u_xlat22 = u_xlat22 * _LightShadowData.z + _LightShadowData.w;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlatb23 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb23){
        u_xlatb24 = unity_ProbeVolumeParams.y==1.0;
        u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
        u_xlat4.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
        u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat4.xyz = (bool(u_xlatb24)) ? u_xlat4.xyz : vs_TEXCOORD5.xyz;
        u_xlat4.xyz = u_xlat4.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat4.yzw = u_xlat4.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat24 = u_xlat4.y * 0.25 + 0.75;
        u_xlat11 = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat4.x = max(u_xlat24, u_xlat11);
        u_xlat4 = texture(unity_ProbeVolumeSH, u_xlat4.xzw);
    } else {
        u_xlat4.x = float(1.0);
        u_xlat4.y = float(1.0);
        u_xlat4.z = float(1.0);
        u_xlat4.w = float(1.0);
    //ENDIF
    }
    u_xlat24 = dot(u_xlat4, unity_OcclusionMaskSelector);
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat22 = u_xlat22 + u_xlat10_4.x;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat24 = min(u_xlat22, u_xlat24);
    u_xlat22 = (u_xlatb23) ? u_xlat24 : u_xlat22;
    u_xlat4.xyz = vec3(u_xlat22) * _LightColor0.xyz;
    u_xlat22 = (-_Glossiness) + 1.0;
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat21) + u_xlat5.xyz;
    u_xlat21 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat21 = max(u_xlat21, 0.00100000005);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat6.xyz = vec3(u_xlat21) * u_xlat6.xyz;
    u_xlat21 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat22));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat21) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat22 * u_xlat22;
    u_xlat22 = (-u_xlat22) * u_xlat22 + 1.0;
    u_xlat10 = abs(u_xlat21) * u_xlat22 + u_xlat3.x;
    u_xlat22 = u_xlat23 * u_xlat22 + u_xlat3.x;
    u_xlat21 = abs(u_xlat21) * u_xlat22;
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat4.xyz;
    u_xlat3.xyz = u_xlat4.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL_COOKIE SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 48
  Matrix4x4 unity_WorldToObject at 112
  Matrix4x4 unity_MatrixVP at 176
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float u_xlat10;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat2.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD5.xyz = u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat2.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat2.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = rsqrt(u_xlat10);
    u_xlat2.xyz = float3(u_xlat10) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat2);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTexture0" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (320 bytes) on slot 0 {
  Matrix4x4 unity_MatrixV at 48
  Matrix4x4 unity_ProbeVolumeWorldToObject at 128
  Matrix4x4 unity_WorldToLight at 256
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_OcclusionMaskSelector at 16
  VectorHalf4 _LightShadowData at 24
  Vector4 unity_ShadowFadeCenterAndType at 32
  Vector4 unity_ProbeVolumeParams at 112
  Vector3 unity_ProbeVolumeSizeInv at 192
  Vector3 unity_ProbeVolumeMin at 208
  VectorHalf4 _LightColor0 at 224
  VectorHalf4 _Color at 232
  ScalarHalf _Metallic at 240
  ScalarHalf _Glossiness at 242
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_OcclusionMaskSelector;
    half4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float2 u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    float4 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half4 u_xlat16_4;
    half3 u_xlat16_5;
    float3 u_xlat6;
    half u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    half u_xlat16_10;
    float3 u_xlat11;
    half u_xlat16_14;
    half u_xlat16_15;
    float u_xlat20;
    half u_xlat16_20;
    half u_xlat16_24;
    half u_xlat16_25;
    float u_xlat30;
    bool u_xlatb30;
    half u_xlat16_32;
    half u_xlat16_33;
    half u_xlat16_34;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_32 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_32));
    u_xlat16_32 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_32 = rsqrt(u_xlat16_32);
    u_xlat16_4.xyz = half3(half3(u_xlat16_32) * input.TEXCOORD4.xyz);
    u_xlat16_32 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_32 = rsqrt(u_xlat16_32);
    u_xlat16_5.xyz = half3(half3(u_xlat16_32) * input.TEXCOORD1.xyz);
    u_xlat0.xy = input.TEXCOORD5.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * input.TEXCOORD5.xx + u_xlat0.xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * input.TEXCOORD5.zz + u_xlat0.xy;
    u_xlat0.xy = u_xlat0.xy + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlat1.xyz = (-input.TEXCOORD5.xyz) + Globals._WorldSpaceCameraPos.xyzx.xyz;
    u_xlat6.x = Globals.hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = Globals.hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = Globals.hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat20 = dot(u_xlat1.xyz, u_xlat6.xyz);
    u_xlat1.xyz = input.TEXCOORD5.xyz + (-Globals.unity_ShadowFadeCenterAndType.xyz);
    u_xlat30 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat30 = sqrt(u_xlat30);
    u_xlat30 = (-u_xlat20) + u_xlat30;
    u_xlat20 = Globals.unity_ShadowFadeCenterAndType.w * u_xlat30 + u_xlat20;
    u_xlat20 = u_xlat20 * float(Globals._LightShadowData.z) + float(Globals._LightShadowData.w);
    u_xlat20 = clamp(u_xlat20, 0.0f, 1.0f);
    u_xlatb30 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb30){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat11.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat11.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD5.xxx + u_xlat11.xyz;
        u_xlat11.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD5.zzz + u_xlat11.xyz;
        u_xlat11.xyz = u_xlat11.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat11.xyz : input.TEXCOORD5.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat11.x = u_xlat1.y * 0.25 + 0.75;
        u_xlat6.x = Globals.unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat1.x = max(u_xlat11.x, u_xlat6.x);
        u_xlat1 = unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw);
        u_xlat16_1 = half4(u_xlat1);
    } else {
        u_xlat16_1.x = half(1.0);
        u_xlat16_1.y = half(1.0);
        u_xlat16_1.z = half(1.0);
        u_xlat16_1.w = half(1.0);
    }
    u_xlat16_33 = dot(u_xlat16_1, Globals.unity_OcclusionMaskSelector);
    u_xlat16_33 = clamp(u_xlat16_33, 0.0h, 1.0h);
    u_xlat6.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_6 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat6.xy).x;
    u_xlat16_34 = half(u_xlat20 + float(u_xlat16_6));
    u_xlat16_34 = clamp(u_xlat16_34, 0.0h, 1.0h);
    u_xlat16_33 = min(u_xlat16_33, u_xlat16_34);
    u_xlat16_33 = (u_xlatb30) ? u_xlat16_33 : u_xlat16_34;
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xy).w;
    u_xlat16_0.x = half(u_xlat16_33 * u_xlat16_0.x);
    u_xlat16_7.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_33 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_8.x = input.TEXCOORD2.w;
    u_xlat16_8.y = input.TEXCOORD3.w;
    u_xlat16_8.z = input.TEXCOORD4.w;
    u_xlat16_9.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_32) + u_xlat16_8.xyz);
    u_xlat16_32 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_32), 0.00100000005));
    u_xlat16_32 = rsqrt(u_xlat16_0.x);
    u_xlat16_9.xyz = half3(half3(u_xlat16_32) * u_xlat16_9.xyz);
    u_xlat16_32 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_34 = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_34 = clamp(u_xlat16_34, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_14 = dot(u_xlat16_8.xyz, u_xlat16_9.xyz);
    u_xlat16_14 = clamp(u_xlat16_14, 0.0h, 1.0h);
    u_xlat16_24 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_24 = dot(half2(u_xlat16_24), half2(u_xlat16_33));
    u_xlat16_24 = half(float(u_xlat16_24) + -0.5);
    u_xlat16_5.x = half((-float(u_xlat16_34)) + 1.0);
    u_xlat16_15 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_15 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_15);
    u_xlat16_5.x = half(float(u_xlat16_24) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_15 = half(-abs(float(u_xlat16_32)) + 1.0);
    u_xlat16_25 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_25 = half(u_xlat16_25 * u_xlat16_25);
    u_xlat16_15 = half(u_xlat16_15 * u_xlat16_25);
    u_xlat16_24 = half(float(u_xlat16_24) * float(u_xlat16_15) + 1.0);
    u_xlat16_24 = half(u_xlat16_24 * u_xlat16_5.x);
    u_xlat16_24 = half(u_xlat16_34 * u_xlat16_24);
    u_xlat16_5.x = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_33 = half((-float(u_xlat16_33)) * float(u_xlat16_33) + 1.0);
    u_xlat16_15 = half(abs(u_xlat16_32) * u_xlat16_33 + u_xlat16_5.x);
    u_xlat16_33 = half(u_xlat16_34 * u_xlat16_33 + u_xlat16_5.x);
    u_xlat16_32 = half(abs(u_xlat16_32) * u_xlat16_33);
    u_xlat16_32 = half(u_xlat16_34 * u_xlat16_15 + u_xlat16_32);
    u_xlat16_0.x = half(float(u_xlat16_32) + 9.99999975e-06);
    u_xlat16_0.x = half(0.5 / float(u_xlat16_0.x));
    u_xlat16_32 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_33 = half(u_xlat16_4.x * u_xlat16_32 + (-u_xlat16_4.x));
    u_xlat16_10 = half(float(u_xlat16_33) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_20 = half(float(u_xlat16_32) * 0.318309873);
    u_xlat16_10 = half(float(u_xlat16_10) * float(u_xlat16_10) + 1.00000001e-07);
    u_xlat16_10 = half(u_xlat16_20 / u_xlat16_10);
    u_xlat16_32 = half(u_xlat16_10 * u_xlat16_0.x);
    u_xlat16_0.x = half(float(u_xlat16_32) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_32 = half(u_xlat16_34 * u_xlat16_0.x);
    u_xlat16_33 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb0 = u_xlat16_33!=0.0;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat16_32 = half(u_xlat0.x * float(u_xlat16_32));
    u_xlat16_4.xzw = half3(half3(u_xlat16_24) * u_xlat16_7.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_32));
    u_xlat16_32 = half((-float(u_xlat16_14)) + 1.0);
    u_xlat16_33 = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_33 = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_32 = half(u_xlat16_32 * u_xlat16_33);
    u_xlat16_7.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_2.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_32) + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * u_xlat16_5.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_4.xzw + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat2.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz;
    u_xlat2.w = 0.0;
    vs_TEXCOORD2 = u_xlat2.wwwx;
    vs_TEXCOORD3 = u_xlat2.wwwy;
    vs_TEXCOORD4.w = u_xlat2.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    vs_TEXCOORD4.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_OcclusionMaskSelector;
uniform 	vec4 _LightShadowData;
uniform 	vec4 unity_ShadowFadeCenterAndType;
uniform 	vec4 hlslcc_mtx4x4unity_MatrixV[4];
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _LightTexture0;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
vec3 u_xlat4;
vec4 u_xlat10_4;
vec4 u_xlat5;
vec4 u_xlat10_5;
vec3 u_xlat6;
float u_xlat9;
float u_xlat10;
float u_xlat16;
float u_xlat17;
vec2 u_xlat18;
float u_xlat21;
float u_xlat22;
bool u_xlatb22;
float u_xlat23;
bool u_xlatb23;
float u_xlat24;
bool u_xlatb24;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat21 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat21) * u_xlat1.xyz;
    u_xlat21 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat2.xyz = vec3(u_xlat21) * vs_TEXCOORD4.xyz;
    u_xlat21 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat3.xyz = vec3(u_xlat21) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD5.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat4.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * vs_TEXCOORD5.xx + u_xlat4.xy;
    u_xlat4.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * vs_TEXCOORD5.zz + u_xlat4.xy;
    u_xlat4.xy = u_xlat4.xy + hlslcc_mtx4x4unity_WorldToLight[3].xy;
    u_xlat5.xyz = (-vs_TEXCOORD5.xyz) + _WorldSpaceCameraPos.xyz;
    u_xlat6.x = hlslcc_mtx4x4unity_MatrixV[0].z;
    u_xlat6.y = hlslcc_mtx4x4unity_MatrixV[1].z;
    u_xlat6.z = hlslcc_mtx4x4unity_MatrixV[2].z;
    u_xlat22 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat5.xyz = vs_TEXCOORD5.xyz + (-unity_ShadowFadeCenterAndType.xyz);
    u_xlat23 = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat23 = sqrt(u_xlat23);
    u_xlat23 = (-u_xlat22) + u_xlat23;
    u_xlat22 = unity_ShadowFadeCenterAndType.w * u_xlat23 + u_xlat22;
    u_xlat22 = u_xlat22 * _LightShadowData.z + _LightShadowData.w;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlatb23 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb23){
        u_xlatb24 = unity_ProbeVolumeParams.y==1.0;
        u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
        u_xlat5.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb24)) ? u_xlat5.xyz : vs_TEXCOORD5.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat24 = u_xlat5.y * 0.25 + 0.75;
        u_xlat18.x = unity_ProbeVolumeParams.z * 0.5 + 0.75;
        u_xlat5.x = max(u_xlat24, u_xlat18.x);
        u_xlat5 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
    } else {
        u_xlat5.x = float(1.0);
        u_xlat5.y = float(1.0);
        u_xlat5.z = float(1.0);
        u_xlat5.w = float(1.0);
    //ENDIF
    }
    u_xlat24 = dot(u_xlat5, unity_OcclusionMaskSelector);
    u_xlat24 = clamp(u_xlat24, 0.0, 1.0);
    u_xlat18.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_5 = texture(_ShadowMapTexture, u_xlat18.xy);
    u_xlat22 = u_xlat22 + u_xlat10_5.x;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat24 = min(u_xlat22, u_xlat24);
    u_xlat22 = (u_xlatb23) ? u_xlat24 : u_xlat22;
    u_xlat10_4 = texture(_LightTexture0, u_xlat4.xy);
    u_xlat22 = u_xlat22 * u_xlat10_4.w;
    u_xlat4.xyz = vec3(u_xlat22) * _LightColor0.xyz;
    u_xlat22 = (-_Glossiness) + 1.0;
    u_xlat5.x = vs_TEXCOORD2.w;
    u_xlat5.y = vs_TEXCOORD3.w;
    u_xlat5.z = vs_TEXCOORD4.w;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat21) + u_xlat5.xyz;
    u_xlat21 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat21 = max(u_xlat21, 0.00100000005);
    u_xlat21 = inversesqrt(u_xlat21);
    u_xlat6.xyz = vec3(u_xlat21) * u_xlat6.xyz;
    u_xlat21 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat23 = dot(u_xlat2.xyz, u_xlat5.xyz);
    u_xlat23 = clamp(u_xlat23, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat9 = dot(u_xlat5.xyz, u_xlat6.xyz);
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat16 = u_xlat9 * u_xlat9;
    u_xlat16 = dot(vec2(u_xlat16), vec2(u_xlat22));
    u_xlat16 = u_xlat16 + -0.5;
    u_xlat3.x = (-u_xlat23) + 1.0;
    u_xlat10 = u_xlat3.x * u_xlat3.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat3.x = u_xlat3.x * u_xlat10;
    u_xlat3.x = u_xlat16 * u_xlat3.x + 1.0;
    u_xlat10 = -abs(u_xlat21) + 1.0;
    u_xlat17 = u_xlat10 * u_xlat10;
    u_xlat17 = u_xlat17 * u_xlat17;
    u_xlat10 = u_xlat10 * u_xlat17;
    u_xlat16 = u_xlat16 * u_xlat10 + 1.0;
    u_xlat16 = u_xlat16 * u_xlat3.x;
    u_xlat16 = u_xlat23 * u_xlat16;
    u_xlat3.x = u_xlat22 * u_xlat22;
    u_xlat22 = (-u_xlat22) * u_xlat22 + 1.0;
    u_xlat10 = abs(u_xlat21) * u_xlat22 + u_xlat3.x;
    u_xlat22 = u_xlat23 * u_xlat22 + u_xlat3.x;
    u_xlat21 = abs(u_xlat21) * u_xlat22;
    u_xlat21 = u_xlat23 * u_xlat10 + u_xlat21;
    u_xlat21 = u_xlat21 + 9.99999975e-06;
    u_xlat21 = 0.5 / u_xlat21;
    u_xlat22 = u_xlat3.x * u_xlat3.x;
    u_xlat3.x = u_xlat2.x * u_xlat22 + (-u_xlat2.x);
    u_xlat2.x = u_xlat3.x * u_xlat2.x + 1.0;
    u_xlat22 = u_xlat22 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat22 = u_xlat22 / u_xlat2.x;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat21 = u_xlat21 * 3.14159274;
    u_xlat21 = max(u_xlat21, 9.99999975e-05);
    u_xlat21 = sqrt(u_xlat21);
    u_xlat21 = u_xlat23 * u_xlat21;
    u_xlat22 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb22 = u_xlat22!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat2.xzw = vec3(u_xlat16) * u_xlat4.xyz;
    u_xlat3.xyz = u_xlat4.xyz * vec3(u_xlat21);
    u_xlat21 = (-u_xlat9) + 1.0;
    u_xlat22 = u_xlat21 * u_xlat21;
    u_xlat22 = u_xlat22 * u_xlat22;
    u_xlat21 = u_xlat21 * u_xlat22;
    u_xlat4.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat0.xyz = u_xlat4.xyz * vec3(u_xlat21) + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat2.xzw + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set CUBE Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTexture0" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3

Constant Buffer "Globals" (112 bytes) on slot 0 {
  Matrix4x4 unity_WorldToLight at 48
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float3 u_xlat3;
    half u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    float u_xlat7;
    half3 u_xlat16_7;
    half u_xlat16_12;
    float u_xlat15;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3.xyz = input.TEXCOORD5.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat15 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat3.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat3.xyz).x;
    u_xlat7 = sqrt(u_xlat15);
    u_xlat7 = u_xlat7 * Globals._LightPositionRange.w;
    u_xlat7 = u_xlat7 * 0.970000029;
    u_xlatb3 = u_xlat3.x<u_xlat7;
    u_xlat16_1.x = (u_xlatb3) ? Globals._LightShadowData.x : 1.0;
    u_xlat3.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat3.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat3.xyz;
    u_xlat3.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat3.xyz;
    u_xlat3.xyz = u_xlat3.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat3.x = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat16_3 = _LightTexture0.sample(sampler_LightTexture0, u_xlat3.xx).w;
    u_xlat16_3 = half(u_xlat16_1.x * u_xlat16_3);
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec4 u_xlat10_1;
bool u_xlatb1;
vec3 u_xlat2;
vec4 u_xlat10_2;
vec3 u_xlat3;
float u_xlat16_3;
vec3 u_xlat4;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.xyz = vs_TEXCOORD5.xyz + (-_LightPositionRange.xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat1.xyz);
    u_xlat1.x = sqrt(u_xlat10);
    u_xlat1.x = u_xlat1.x * _LightPositionRange.w;
    u_xlat1.x = u_xlat1.x * 0.970000029;
    u_xlatb1 = u_xlat10_2.x<u_xlat1.x;
    u_xlat1.x = (u_xlatb1) ? _LightShadowData.x : 1.0;
    u_xlat4.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat4.xyz;
    u_xlat4.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat4.xyz;
    u_xlat4.xyz = u_xlat4.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
    u_xlat10_2 = texture(_LightTexture0, u_xlat4.xx);
    u_xlat1.x = u_xlat1.x * u_xlat10_2.w;
    u_xlat1.xyz = u_xlat1.xxx * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float2 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    output.TEXCOORD6.xy = float2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set CUBE Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set CUBE Texture "_LightTexture0" to slot 3
Set 2D Texture "unity_NHxRoughness" to slot 4

Constant Buffer "Globals" (112 bytes) on slot 0 {
  Matrix4x4 unity_WorldToLight at 48
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (3) ]] ,
    sampler sampler_LightTexture0 [[ sampler (3) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (4) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float3 u_xlat3;
    half u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    float u_xlat7;
    half3 u_xlat16_7;
    half u_xlat16_12;
    float u_xlat15;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3.xyz = input.TEXCOORD5.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat15 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat3.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat3.xyz).x;
    u_xlat7 = sqrt(u_xlat15);
    u_xlat7 = u_xlat7 * Globals._LightPositionRange.w;
    u_xlat7 = u_xlat7 * 0.970000029;
    u_xlatb3 = u_xlat3.x<u_xlat7;
    u_xlat16_1.x = (u_xlatb3) ? Globals._LightShadowData.x : 1.0;
    u_xlat3.xyz = input.TEXCOORD5.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat3.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * input.TEXCOORD5.xxx + u_xlat3.xyz;
    u_xlat3.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * input.TEXCOORD5.zzz + u_xlat3.xyz;
    u_xlat3.xyz = u_xlat3.xyz + Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat15 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat16_3 = _LightTexture0.sample(sampler_LightTexture0, u_xlat3.xyz).w;
    u_xlat16_7.x = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat15)).w;
    u_xlat16_3 = half(u_xlat16_3 * u_xlat16_7.x);
    u_xlat16_3 = half(u_xlat16_1.x * u_xlat16_3);
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec2 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz;
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD6.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
uniform  sampler2D _MainTex;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec4 u_xlat10_1;
bool u_xlatb1;
vec3 u_xlat2;
vec4 u_xlat10_2;
vec4 u_xlat10_3;
vec3 u_xlat4;
float u_xlat16_4;
vec3 u_xlat5;
float u_xlat16_5;
float u_xlat12;
float u_xlat13;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat12 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat12 = u_xlat12 + u_xlat12;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat12)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat12 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.x = u_xlat12 * u_xlat12;
    u_xlat1.x = u_xlat4.x * u_xlat4.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_4 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat4.xyz = vec3(u_xlat16_4) * u_xlat2.xyz;
    u_xlat13 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat4.xyz = u_xlat1.xyz * vec3(u_xlat13) + u_xlat4.xyz;
    u_xlat1.xyz = vs_TEXCOORD5.xyz + (-_LightPositionRange.xyz);
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat1.xyz);
    u_xlat1.x = sqrt(u_xlat13);
    u_xlat1.x = u_xlat1.x * _LightPositionRange.w;
    u_xlat1.x = u_xlat1.x * 0.970000029;
    u_xlatb1 = u_xlat10_2.x<u_xlat1.x;
    u_xlat1.x = (u_xlatb1) ? _LightShadowData.x : 1.0;
    u_xlat5.xyz = vs_TEXCOORD5.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat5.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * vs_TEXCOORD5.xxx + u_xlat5.xyz;
    u_xlat5.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * vs_TEXCOORD5.zzz + u_xlat5.xyz;
    u_xlat5.xyz = u_xlat5.xyz + hlslcc_mtx4x4unity_WorldToLight[3].xyz;
    u_xlat2.x = dot(u_xlat5.xyz, u_xlat5.xyz);
    u_xlat10_3 = texture(_LightTexture0, u_xlat5.xyz);
    u_xlat10_2 = texture(_LightTextureB0, u_xlat2.xx);
    u_xlat16_5 = u_xlat10_3.w * u_xlat10_2.w;
    u_xlat1.x = u_xlat1.x * u_xlat16_5;
    u_xlat1.xyz = u_xlat1.xxx * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat4.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "SHADOWCASTER"
  Tags { "LIGHTMODE"="SHADOWCASTER" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"

Constant Buffer "Globals" (224 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 32
  Matrix4x4 unity_WorldToObject at 96
  Matrix4x4 unity_MatrixVP at 160
  Vector4 _WorldSpaceLightPos0 at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float u_xlat6;
    float u_xlat9;
    bool u_xlatb9;
    u_xlat0.x = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat1;
    u_xlat2.xyz = (-u_xlat1.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * Globals.unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat0.xyz) * float3(u_xlat9) + u_xlat1.xyz;
    u_xlatb9 = Globals.unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat2;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat2;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat1.wwww + u_xlat0;
    u_xlat1.x = Globals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = Globals.unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return output;
}


-- Fragment shader for "metal":
Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
)
{
    Mtl_FragmentOut output;
    output.SV_Target0 = half4(0.0, 0.0, 0.0, 0.0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_LightShadowBias;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
vec4 u_xlat0;
vec4 u_xlat1;
vec4 u_xlat2;
float u_xlat6;
float u_xlat9;
bool u_xlatb9;
void main()
{
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    u_xlat1 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat1;
    u_xlat2.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat2.xyz = vec3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat0.xyz) * vec3(u_xlat9) + u_xlat1.xyz;
    u_xlatb9 = unity_LightShadowBias.z!=0.0;
    u_xlat0.xyz = (bool(u_xlatb9)) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat2 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat2 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat2;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat2;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat1.wwww + u_xlat0;
    u_xlat1.x = unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = clamp(u_xlat1.x, 0.0, 1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = max((-u_xlat0.w), u_xlat6);
    gl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    gl_Position.z = unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

layout(location = 0) out vec4 SV_Target0;
void main()
{
    SV_Target0 = vec4(0.0, 0.0, 0.0, 0.0);
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"

Constant Buffer "Globals" (144 bytes) on slot 0 {
  Matrix4x4 unity_ObjectToWorld at 16
  Matrix4x4 unity_MatrixVP at 80
  Vector4 _LightPositionRange at 0
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};

struct Mtl_VertexOut
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    output.TEXCOORD0.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = Globals.hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    return output;
}


-- Fragment shader for "metal":
Constant Buffer "Globals" (32 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 unity_LightShadowBias;
};

struct Mtl_FragmentIn
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    u_xlat0.x = dot(input.TEXCOORD0.xyz, input.TEXCOORD0.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x + Globals.unity_LightShadowBias.x;
    u_xlat0 = u_xlat0.xxxx * Globals._LightPositionRange.wwww;
    output.SV_Target0 = half4(u_xlat0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
in  vec4 in_POSITION0;
out vec3 vs_TEXCOORD0;
vec4 u_xlat0;
vec4 u_xlat1;
void main()
{
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD0.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_LightShadowBias;
in  vec3 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
float u_xlat0;
void main()
{
    u_xlat0 = dot(vs_TEXCOORD0.xyz, vs_TEXCOORD0.xyz);
    u_xlat0 = sqrt(u_xlat0);
    u_xlat0 = u_xlat0 + unity_LightShadowBias.x;
    SV_Target0 = vec4(u_xlat0) * _LightPositionRange.wwww;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
}
CustomEditor "StandardShaderGUI"
Fallback "VertexLit"
}